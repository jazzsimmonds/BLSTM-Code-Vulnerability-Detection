1 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 449
ZIP_FILENAME_LEN, NULL, 0, NULL, 0 )
char *psz_fileName = calloc( ZIP_FILENAME_LEN, 1 );
if( unzGetCurrentFileInfo( file, p_fileInfo, psz_fileName,
vlc_array_append( p_filenames, strdup( psz_fileName ) );
free( psz_fileName );
0
---------------------------------
2 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 449
char *psz_fileName = calloc( ZIP_FILENAME_LEN, 1 );
ZIP_FILENAME_LEN, NULL, 0, NULL, 0 )
if( unzGetCurrentFileInfo( file, p_fileInfo, psz_fileName,
vlc_array_append( p_filenames, strdup( psz_fileName ) );
free( psz_fileName );
0
---------------------------------
3 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c inputfunc 100
fread(buf, 13, 1, fp);
img->xsize = (buf[7] << 8) | buf[6];
img->ysize = (buf[9] << 8) | buf[8];
ncolors    = 2 << (buf[10] & 0x07);
if (buf[10] & GIF_COLORMAP)
if (gif_read_cmap(fp, ncolors, cmap, &gray))
switch (getc(fp))
fclose(fp);
buf[0] = getc(fp);
if (buf[0] == 0xf9)
gif_get_block(fp, buf);
fread(buf, 9, 1, fp);
if (buf[8] & GIF_COLORMAP)
ncolors = 2 << (buf[8] & 0x07);
if (gif_read_cmap(fp, ncolors, cmap, &gray))
img->xsize = (buf[5] << 8) | buf[4];
img->ysize = (buf[7] << 8) | buf[6];
if (img->xsize == 0 || img->ysize == 0)
img->xsize, img->ysize);
fprintf(stderr, "DEBUG: Bad GIF image dimensions: %dx%d\n",
fclose(fp);
i = gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE);
int interlace);
i = gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE);
static int	gif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,
fclose(fp);
fclose(fp);
for (i = ncolors - 1; i >= 0; i --)
cupsImageWhiteToCMYK(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageWhiteToCMY(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageWhiteToBlack(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageWhiteToRGB(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBAdjust(cmap[i], 1, saturation, hue);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToCMYK(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToCMY(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToBlack(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToWhite(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToRGB(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageLut(cmap[i], bpp, lut);
static int	gif_read_image(FILE *fp, cups_image_t *img, gif_cmap_t cmap,
fclose(fp);
static int	gif_get_block(FILE *fp, unsigned char *buffer);
if (buf[0] & 1)
transparent = buf[3];
if (transparent >= 0)
0
---------------------------------
4 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_workmonitor.cpp cppfunc 111
WCHAR installDir[MAX_PATH + 1] = {L'\0'};
if (!GetInstallationDir(argc, argv, installDir)) {
GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH + 1])
wcsncpy(aResultDir, argvTmp[2], MAX_PATH);
WCHAR* backSlash = wcsrchr(aResultDir, L'\\');
0
---------------------------------
5 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 196
DumpStyleGeneaology(nsIFrame* aFrame, const char* gap)
nsFrame::ListTag(stdout, aFrame);
nsStyleContext* sc = aFrame->GetStyleContext();
printf("%p ", sc);
psc = sc->GetParent();
sc = psc;
printf("%p ", sc);
0
---------------------------------
6 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 514
rtsp_create_conversation(packet_info *pinfo, const guchar *line_begin,
size_t line_len, gint rdt_feature_level)
guchar    buf[256];
if (line_len > sizeof(buf) - 1)
line_len = sizeof(buf) - 1;
memcpy(buf, line_begin, line_len);
0
---------------------------------
7 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4420
str[0] = '\0';
av_strlcatf(str, size, "%s:
av_strlcatf(str, size, "%s@", authorization);
av_strlcat(str, "[", size);
av_strlcat(str, hostname, size);
av_strlcat(str, "]", size);
av_strlcat(str, hostname, size);
av_strlcat(str, hostname, size);
av_strlcatf(str, size, ":%d", port);
int len = strlen(str);
vsnprintf(str + len, size > len ? size - len : 0, fmt, vl);
return strlen(str);
0
---------------------------------
8 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 241
static int Open( vlc_object_t *p_this )
char         *psz_path, *psz_uri;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
i_ret = asprintf( &psz_uri, "
free( psz_uri );
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
i_ret = asprintf( &psz_uri, "
free( psz_uri );
static void Win32AddConnection( access_t *p_access, char *psz_path,
i_ret = asprintf( &psz_uri, "
free( psz_uri );
0
---------------------------------
9 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 241
static int Open( vlc_object_t *p_this )
char         *psz_path, *psz_uri;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
i_ret = asprintf( &psz_uri, "
free( psz_uri );
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
i_ret = asprintf( &psz_uri, "
free( psz_uri );
static void Win32AddConnection( access_t *p_access, char *psz_path,
i_ret = asprintf( &psz_uri, "
free( psz_uri );
0
---------------------------------
10 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 519
buf[line_len] = '\0';
tmp = buf + STRLEN_CONST(rtsp_transport);
tmp++;
while (*tmp && isspace(*tmp))
0
---------------------------------
11 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 519
buf[line_len] = '\0';
tmp = buf + STRLEN_CONST(rtsp_transport);
tmp++;
while (*tmp && isspace(*tmp))
0
---------------------------------
12 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1349
debug_printf(const char *format,
va_start(ap, format);
vfprintf(stderr, format, ap);
0
---------------------------------
13 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 373
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
0
---------------------------------
14 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 5812
nsIFrame*           aFloat,
NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
aFloat, this,
nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
if (!aFloat->GetPrevInFlow()) {
rv = brc.ReflowBlock(aAdjustedAvailableSpace, true, margin,
if (aFloat->GetType() == nsGkAtoms::letterFrame) {
const nsHTMLReflowMetrics& metrics = brc.GetMetrics();
aFloat->SetSize(nsSize(metrics.width, metrics.height));
if (aFloat->HasView()) {
nsContainerFrame::SyncFrameViewAfterReflow(aState.mPresContext, aFloat,
aFloat->DidReflow(aState.mPresContext, &floatRS,
aFloat, metrics.width, metrics.height);
0
---------------------------------
15 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 463
path->data = NULL;
path->size = 0;
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
fidp = get_fid(pdu, fid);
err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);
V9fsPath path;
v9fs_path_init(&path);
err = v9fs_co_name_to_path(pdu, &dfidp->path, name.data, &path);
err = v9fs_mark_fids_unreclaim(pdu, &path);
static int v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
if (!memcmp(fidp->path.data, path->data, path->size)) {
void v9fs_path_init(V9fsPath *path)
v9fs_path_init(&path);
err = v9fs_mark_fids_unreclaim(pdu, &path);
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
fidp = get_fid(pdu, fid);
err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);
0
---------------------------------
16 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 404
WriteStatusFailure(LPCWSTR updateDirPath, int errorCode)
char failure[32];
sprintf(failure, "failed: %d", errorCode);
DWORD toWrite = strlen(failure);
DWORD wrote;
toWrite, &wrote, NULL);
0
---------------------------------
17 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp cfunc 401
WriteStatusFailure(LPCWSTR updateDirPath, int errorCode)
char failure[32];
sprintf(failure, "failed: %d", errorCode);
DWORD toWrite = strlen(failure);
0
---------------------------------
18 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 403
WriteStatusFailure(LPCWSTR updateDirPath, int errorCode)
char failure[32];
sprintf(failure, "failed: %d", errorCode);
DWORD toWrite = strlen(failure);
BOOL ok = WriteFile(statusFile, failure,
0
---------------------------------
19 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cppfunc 401
if (gCommandChainQueue.IsEmpty()) {
CommandChain* nextChain = gCommandChainQueue[0];
NetworkResultOptions newResult;
next(nextChain, false, newResult);
0
---------------------------------
20 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1469
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->addrname);
0
---------------------------------
21 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1469
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->addrname);
0
---------------------------------
22 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1549
hex_debug(unsigned char *buffer,
for (col = 0; len > 0; col ++, buffer ++, len --)
fprintf(stderr, " %02X", *buffer);
0
---------------------------------
23 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4732
char *endptr;
prog_id = strtol(spec, &endptr, 0);
if (*endptr++ == ':') {
int stream_idx = strtol(endptr, NULL, 0);
0
---------------------------------
24 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4732
char *endptr;
prog_id = strtol(spec, &endptr, 0);
if (*endptr++ == ':') {
int stream_idx = strtol(endptr, NULL, 0);
0
---------------------------------
25 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 378
nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
if (f->HasOverflowAreas()) {
nsRect overflowArea = f->GetVisualOverflowRect();
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
0
---------------------------------
26 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_serviceinstall.cpp cfunc 133
int rv = ReadMaintenanceServiceStrings(updaterINIPath, &serviceStrings);
MaintenanceServiceStringTable *results)
results->serviceDescription[MAX_TEXT_LEN - 1] = '\0';
MaintenanceServiceStringTable serviceStrings;
int rv = ReadMaintenanceServiceStrings(updaterINIPath, &serviceStrings);
if (rv != OK || !strlen(serviceStrings.serviceDescription)) {
0
---------------------------------
27 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_wifi_WifiUtils.cpp cfunc 44
char propP2pSupported[PROPERTY_VALUE_MAX];
property_get("ro.moz.wifi.p2p_supported", propP2pSupported, "0");
return (0 == strcmp(propP2pSupported, "1"));
0
---------------------------------
28 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 5396
nsIFrame* aOldFrame)
nsFrame::ListTag(stdout, aOldFrame);
bool hasFloats = BlockHasAnyFloats(aOldFrame);
rv = DoRemoveFrame(aOldFrame, REMOVE_FIXED_CONTINUATIONS);
return DoRemoveFrame(aOldFrame, REMOVE_FIXED_CONTINUATIONS);
if (line->Contains(aDeletedFrame)) {
NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
line->mFirstChild = aDeletedFrame->GetNextSibling();
overflowLines->mFrames.RemoveFrame(aDeletedFrame);
mFrames.RemoveFrame(aDeletedFrame);
line->NoteFrameRemoved(aDeletedFrame);
aDeletedFrame->GetNextContinuation() : aDeletedFrame->GetNextInFlow();
nsIFrame* deletedNextContinuation = (aFlags & REMOVE_FIXED_CONTINUATIONS) ?
nsFrame::ListTag(stdout, aDeletedFrame);
aDeletedFrame->GetPrevSibling(), deletedNextContinuation);
deletedNextContinuation->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
deletedNextContinuation = nullptr;
aDeletedFrame = deletedNextContinuation;
NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
mFrames.RemoveFrame(aDeletedFrame);
line->NoteFrameRemoved(aDeletedFrame);
aDeletedFrame->GetNextContinuation() : aDeletedFrame->GetNextInFlow();
nsIFrame* deletedNextContinuation = (aFlags & REMOVE_FIXED_CONTINUATIONS) ?
nsFrame::ListTag(stdout, aDeletedFrame);
aDeletedFrame->GetPrevSibling(), deletedNextContinuation);
nsIFrame*      aNextInFlow,
NS_PRECONDITION(aNextInFlow->GetPrevInFlow(), "bad next-in-flow");
if (aNextInFlow->GetStateBits() &
nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(aNextInFlow);
DoRemoveFrame(aNextInFlow,
static nsresult RemoveBlockChild(nsIFrame* aFrame,
nsBlockFrame* nextBlock = nsLayoutUtils::GetAsBlock(aFrame->GetParent());
return nextBlock->DoRemoveFrame(aFrame,
nsBlockFrame::DoRemoveFrame(nsIFrame* aDeletedFrame, uint32_t aFlags)
if (aDeletedFrame->GetStateBits() &
NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
mFrames.RemoveFrame(aDeletedFrame);
line->NoteFrameRemoved(aDeletedFrame);
aDeletedFrame->GetNextContinuation() : aDeletedFrame->GetNextInFlow();
nsIFrame* deletedNextContinuation = (aFlags & REMOVE_FIXED_CONTINUATIONS) ?
nsFrame::ListTag(stdout, aDeletedFrame);
aDeletedFrame->GetPrevSibling(), deletedNextContinuation);
0
---------------------------------
29 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 981
! memcmp( &oggpacket.packet[1], "tarkin", 6 ) )
! memcmp( oggpacket.packet, "Annodex", 7 ) )
! memcmp( oggpacket.packet, "\x01vorbis", 7 ) )
! memcmp( oggpacket.packet, "Speex", 5 ) )
! memcmp( oggpacket.packet, "fLaC", 4 ) )
! memcmp( oggpacket.packet, "\x80theora", 7 ) )
! memcmp( oggpacket.packet, "KW-DIRAC\x00", 9 ) ) )
! memcmp( oggpacket.packet, "BBCD\x00", 5 ) ) ||
0
---------------------------------
30 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 179
const uint8_t *p_peek;
if( stream_Peek( s->p_source, &p_peek, i_zip_marker ) < i_zip_marker )
if( memcmp( p_peek, p_zip_marker, i_zip_marker ) )
0
---------------------------------
31 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 373
const char pending[] = "pending";
DWORD wrote;
sizeof(pending) - 1, &wrote, NULL);
0
---------------------------------
32 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4169
PRINT(" %02x", buf[i+j]);
PRINT("   ");
PRINT(" ");
PRINT("%c", c);
PRINT("\n");
PRINT("%08x ", i);
PRINT(" ");
PRINT("%c", c);
hex_dump_internal(avcl, NULL, level, buf, size);
PRINT("stream #%d:\n", pkt->stream_index);
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
PRINT("  dts=");
PRINT("N/A");
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
PRINT("  pts=");
PRINT("N/A");
PRINT("%0.3f", pkt->pts * av_q2d(time_base));
PRINT("\n");
PRINT("  size=%d\n", pkt->size);
av_hex_dump(f, pkt->data, pkt->size);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
void av_hex_dump(FILE *f, uint8_t *buf, int size)
hex_dump_internal(NULL, f, 0, buf, size);
static void hex_dump_internal(void *avcl, FILE *f, int level, uint8_t *buf, int size)
PRINT("%c", c);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
av_hex_dump(f, pkt->data, pkt->size);
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
33 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4164
PRINT("%c", c);
PRINT("\n");
PRINT("%08x ", i);
PRINT(" ");
hex_dump_internal(avcl, NULL, level, buf, size);
PRINT("stream #%d:\n", pkt->stream_index);
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
PRINT("  dts=");
PRINT("N/A");
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
PRINT("  pts=");
PRINT("N/A");
PRINT("%0.3f", pkt->pts * av_q2d(time_base));
PRINT("\n");
PRINT("  size=%d\n", pkt->size);
av_hex_dump(f, pkt->data, pkt->size);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
static void hex_dump_internal(void *avcl, FILE *f, int level, uint8_t *buf, int size)
PRINT(" ");
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
av_hex_dump(f, pkt->data, pkt->size);
void av_hex_dump(FILE *f, uint8_t *buf, int size)
hex_dump_internal(NULL, f, 0, buf, size);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
0
---------------------------------
34 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4162
PRINT(" %02x", buf[i+j]);
PRINT("   ");
PRINT(" ");
PRINT("%c", c);
PRINT("\n");
PRINT("%08x ", i);
PRINT("   ");
hex_dump_internal(avcl, NULL, level, buf, size);
PRINT("stream #%d:\n", pkt->stream_index);
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
PRINT("  dts=");
PRINT("N/A");
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
PRINT("  pts=");
PRINT("N/A");
PRINT("%0.3f", pkt->pts * av_q2d(time_base));
PRINT("\n");
PRINT("  size=%d\n", pkt->size);
av_hex_dump(f, pkt->data, pkt->size);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
void av_hex_dump(FILE *f, uint8_t *buf, int size)
hex_dump_internal(NULL, f, 0, buf, size);
static void hex_dump_internal(void *avcl, FILE *f, int level, uint8_t *buf, int size)
PRINT("   ");
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
av_hex_dump(f, pkt->data, pkt->size);
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
35 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4160
PRINT(" ");
PRINT("%c", c);
PRINT("\n");
PRINT("%08x ", i);
PRINT(" %02x", buf[i+j]);
hex_dump_internal(avcl, NULL, level, buf, size);
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
PRINT("N/A");
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
PRINT("\n");
av_hex_dump(f, pkt->data, pkt->size);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
void av_hex_dump(FILE *f, uint8_t *buf, int size)
hex_dump_internal(NULL, f, 0, buf, size);
static void hex_dump_internal(void *avcl, FILE *f, int level, uint8_t *buf, int size)
PRINT(" %02x", buf[i+j]);
PRINT("   ");
PRINT(" %02x", buf[i+j]);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("stream #%d:\n", pkt->stream_index);
PRINT("  dts=");
PRINT("  pts=");
PRINT("N/A");
PRINT("%0.3f", pkt->pts * av_q2d(time_base));
PRINT("  size=%d\n", pkt->size);
av_hex_dump(f, pkt->data, pkt->size);
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
0
---------------------------------
36 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 577
HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
if (!Process32FirstW(snapshot, &processEntry)) {
} while (Process32NextW(snapshot, &processEntry));
CloseHandle(snapshot);
0
---------------------------------
37 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 573
HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
if (!Process32FirstW(snapshot, &processEntry)) {
} while (Process32NextW(snapshot, &processEntry));
CloseHandle(snapshot);
0
---------------------------------
38 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 773
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(0, ret);
int el;
if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
0
---------------------------------
39 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1624
unsigned char *selected;
unsigned char selected_len;
ctx->next_proto_select_cb(s, &selected, &selected_len, data,
s->next_proto_negotiated = OPENSSL_malloc(selected_len);
memcpy(s->next_proto_negotiated, selected, selected_len);
0
---------------------------------
40 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_workmonitor.cpp cfunc 78
char buf[32] = { 0 };
if (!ReadFile(statusFile, buf, sizeof(buf), &read, NULL)) {
LOG(("updater.exe returned status: %s", buf));
const char kApplying[] = "applying";
isApplying = strncmp(buf, kApplying,
0
---------------------------------
41 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1720
char		uri[1024],
if (!try_connect(&(device->address), device->addrname, 5353))
snprintf(uri, sizeof(uri), "lpd:
static int		try_connect(http_addr_t *addr, const char *addrname,
if (!try_connect(&(device->address), device->addrname, 9100))
static int		try_connect(http_addr_t *addr, const char *addrname,
else if (!try_connect(&(device->address), device->addrname, 515))
static int		try_connect(http_addr_t *addr, const char *addrname,
debug_printf("DEBUG: %s supports LPD!\n", device->addrname);
static void		debug_printf(const char *format, ...);
snprintf(uri, sizeof(uri), "lpd:
update_cache(device, uri, NULL, NULL);
const char   *uri,
device->uri = strdup(uri);
snprintf(uri, sizeof(uri), "lpd:
0
---------------------------------
42 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 497
if ((device_uri = calloc(1, sizeof(device_uri_t))) == NULL)
if ((device_uri->uris = cupsArrayNew(NULL, NULL)) == NULL)
if (regcomp(&(device_uri->re), start, REG_EXTENDED | REG_ICASE))
cupsArrayDelete(device_uri->uris);
free(device_uri);
0
---------------------------------
43 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 497
if ((device_uri = calloc(1, sizeof(device_uri_t))) == NULL)
if ((device_uri->uris = cupsArrayNew(NULL, NULL)) == NULL)
if (regcomp(&(device_uri->re), start, REG_EXTENDED | REG_ICASE))
cupsArrayDelete(device_uri->uris);
free(device_uri);
0
---------------------------------
44 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 462
static int AVI_ChunkRead_idx1( stream_t *s, avi_chunk_t *p_chk )
AVI_READCHUNK_ENTER;
i_count = __MIN( (int64_t)p_chk->common.i_chunk_size, i_read ) / 16;
p_chk->idx1.entry = calloc( i_count, sizeof( idx1_entry_t ) );
0
---------------------------------
45 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cppfunc 462
static int AVI_ChunkRead_idx1( stream_t *s, avi_chunk_t *p_chk )
AVI_READCHUNK_ENTER;
i_count = __MIN( (int64_t)p_chk->common.i_chunk_size, i_read ) / 16;
p_chk->idx1.entry = calloc( i_count, sizeof( idx1_entry_t ) );
0
---------------------------------
46 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_workmonitor.cpp API 70
WCHAR updateStatusFilePath[MAX_PATH + 1] = {L'\0'};
wcsncpy(updateStatusFilePath, updateDirPath, MAX_PATH);
if (!PathAppendSafe(updateStatusFilePath, L"update.status")) {
FILE_SHARE_WRITE |
NULL, OPEN_EXISTING, 0, NULL));
nsAutoHandle statusFile(CreateFileW(updateStatusFilePath, GENERIC_READ,
FILE_SHARE_WRITE |
FILE_SHARE_READ |
FILE_SHARE_WRITE |
char buf[32] = { 0 };
DWORD read;
if (!ReadFile(statusFile, buf, sizeof(buf), &read, NULL)) {
0
---------------------------------
47 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 368
AVI_READCHUNK_ENTER;
p_chk->strf.auds.p_wf = malloc( __MAX( p_chk->common.i_chunk_size, sizeof( WAVEFORMATEX ) ) );
AVI_READ2BYTES( p_chk->strf.auds.p_wf->wFormatTag );
AVI_READ2BYTES( p_chk->strf.auds.p_wf->nChannels );
AVI_READ4BYTES( p_chk->strf.auds.p_wf->nSamplesPerSec );
AVI_READ4BYTES( p_chk->strf.auds.p_wf->nAvgBytesPerSec );
AVI_READ2BYTES( p_chk->strf.auds.p_wf->nBlockAlign );
AVI_READ2BYTES( p_chk->strf.auds.p_wf->wBitsPerSample );
&& p_chk->common.i_chunk_size > sizeof( WAVEFORMATEX ) )
AVI_READ2BYTES( p_chk->strf.auds.p_wf->cbSize );
p_chk->common.i_chunk_size - sizeof( WAVEFORMATEX ) )
p_chk->common.i_chunk_size - sizeof( WAVEFORMATEX );
p_chk->strf.auds.p_wf->cbSize =
p_chk->strf.auds.p_wf->cbSize = 0;
memcpy( &p_chk->strf.auds.p_wf[1] ,
0
---------------------------------
48 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 333
strcat(result, array[i].get());
for (uint32_t i = 1; i < array.Length(); i++) {
CHECK_LENGTH(len, strlen(array[i].get()), maxlen)
0
---------------------------------
49 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 331
static void join(nsTArray<nsCString>& array,
if (array.Length() > 0) {
CHECK_LENGTH(len, strlen(array[0].get()), maxlen)
strcpy(result, array[0].get());
for (uint32_t i = 1; i < array.Length(); i++) {
strcat(result, sep);
CHECK_LENGTH(len, strlen(array[i].get()), maxlen)
strcat(result, array[i].get());
strcat(result, sep);
0
---------------------------------
50 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 334
static void join(nsTArray<nsCString>& array,
const char* sep,
char* result)
uint32_t seplen = strlen(sep);
if (array.Length() > 0) {
CHECK_LENGTH(len, strlen(array[0].get()), maxlen)
strcpy(result, array[0].get());
for (uint32_t i = 1; i < array.Length(); i++) {
strcat(result, sep);
CHECK_LENGTH(len, strlen(array[i].get()), maxlen)
strcat(result, array[i].get());
0
---------------------------------
51 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_workmonitor.cpp API 211
PROCESS_INFORMATION pi = {0};
NULL, &si, &pi);
CloseHandle(pi.hThread);
0
---------------------------------
52 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 300
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
const char *name,
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
const char *name,
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/dst", x1, y1, w, h)) {
const char *name,
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
const char *name,
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
dpy_cursor_define(s->vga.con, qc);
dx = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/dst", x1, y1, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
vmsvga_fifo_run(s);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
s->vga.vram_ptr);
dpy_gfx_replace_surface(s->vga.con, surface);
struct vmsvga_state_s *s = opaque;
vmsvga_value_write(s, addr, data);
static inline int vmsvga_fill_rect(struct vmsvga_state_s *s,
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
return le32_to_cpu(vmsvga_fifo_read_raw(s));
vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
args = 7 + (vmsvga_fifo_read(s) >> 2);
vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
x = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
return le32_to_cpu(vmsvga_fifo_read_raw(s));
static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
x = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
x = vmsvga_fifo_read(s);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
vmsvga_fifo_run(s);
static void vmsvga_update_display(void *opaque)
vmsvga_check_size(s);
static inline void vmsvga_check_size(struct vmsvga_state_s *s)
vmsvga_check_size(s);
vmsvga_fifo_run(s);
static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
static inline int vmsvga_copy_rect(struct vmsvga_state_s *s,
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
x = vmsvga_fifo_read(s);
static void vmsvga_io_write(void *opaque, hwaddr addr,
vmsvga_value_write(s, addr, data);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
vmsvga_cursor_define(s, &cursor);
vmsvga_fifo_read(s);
0
---------------------------------
53 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1795
char		filename[1024],
if ((cups_serverroot = getenv("CUPS_SERVERROOT")) == NULL)
cups_serverroot = CUPS_SERVERROOT;
snprintf(filename, sizeof(filename), "%s/snmp.conf", cups_serverroot);
if ((fp = cupsFileOpen(filename, "r")) != NULL)
linenum = 0;
while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
fprintf(stderr, "ERROR: Missing value on line %d of %s!\n", linenum,
filename);
line, linenum, filename);
"line %d of %s!\n", linenum, filename);
0
---------------------------------
54 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 304
if (x > SVGA_MAX_WIDTH) {
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
const char *name,
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
const char *name,
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/dst", x1, y1, w, h)) {
DisplaySurface *surface = qemu_console_surface(s->vga.con);
dpy_cursor_define(s->vga.con, qc);
x = vmsvga_fifo_read(s);
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
uint32_t c, int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
dx = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/dst", x1, y1, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
vmsvga_fifo_run(s);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
qemu_default_pixman_format(s->new_depth, true);
trace_vmware_setmode(s->new_width, s->new_height, s->new_depth);
s->vga.vram_ptr);
dpy_gfx_replace_surface(s->vga.con, surface);
struct vmsvga_state_s *s = opaque;
vmsvga_value_write(s, addr, data);
static inline int vmsvga_copy_rect(struct vmsvga_state_s *s,
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
x = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
return le32_to_cpu(vmsvga_fifo_read_raw(s));
vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
args = 7 + (vmsvga_fifo_read(s) >> 2);
vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
x = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
static void vmsvga_update_display(void *opaque)
vmsvga_check_size(s);
static inline void vmsvga_check_size(struct vmsvga_state_s *s)
vmsvga_check_size(s);
vmsvga_fifo_run(s);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
x = vmsvga_fifo_read(s);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
vmsvga_fifo_run(s);
static inline void vmsvga_update_rect(struct vmsvga_state_s *s,
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
static inline int vmsvga_fill_rect(struct vmsvga_state_s *s,
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
vmsvga_fifo_read(s);
static void vmsvga_io_write(void *opaque, hwaddr addr,
vmsvga_value_write(s, addr, data);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
vmsvga_cursor_define(s, &cursor);
vmsvga_fifo_read(s);
0
---------------------------------
55 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 145
const BlockDebugFlags* bdf = gFlags;
const BlockDebugFlags* end = gFlags + NUM_DEBUG_FLAGS;
*(bdf->on) = true;
for (; bdf < end; bdf++) {
if (PL_strcasecmp(bdf->name, flags) == 0) {
printf("nsBlockFrame: setting %s debug flag on\n", bdf->name);
0
---------------------------------
56 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_wifi_WifiUtils.cpp cfunc 386
char propVersion[PROPERTY_VALUE_MAX];
property_get("ro.build.version.sdk", propVersion, "0");
mSdkVersion = strtol(propVersion, nullptr, 10);
0
---------------------------------
57 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_wifi_WifiUtils.cpp cppfunc 386
char propVersion[PROPERTY_VALUE_MAX];
property_get("ro.build.version.sdk", propVersion, "0");
mSdkVersion = strtol(propVersion, nullptr, 10);
0
---------------------------------
58 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 722
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
int           indent)
fprintf(stderr, "DEBUG: %*sINTEGER %d bytes %d\n", indent, "",
asn1_debug(buffer, value_length, indent + 4);
fprintf(stderr, "DEBUG: %*sOCTET STRING %d bytes \"%s\"\n", indent, "",
fprintf(stderr, ".%d", oid[i]);
putc('\n', stderr);
fprintf(stderr, "DEBUG: %*sBOOLEAN %d bytes %d\n", indent, "",
0
---------------------------------
59 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 723
value_length = asn1_get_length(&buffer, bufend);
integer = asn1_get_integer(&buffer, bufend, value_length);
int length);
value_length, integer);
0
---------------------------------
60 CVE-2014-6431/Wireshark_1.12.0_CVE_2014_6431_wiretap_ngsniffer.c cfunc 934
process_rec_header2_v2(wtap *wth, unsigned char *buffer, guint16 length,
static const char x_25_str[] = "HDLC\nX.25\n";
if (length < sizeof x_25_str - 1) {
if (strncmp((char *)buffer, x_25_str, sizeof x_25_str - 1) == 0) {
0
---------------------------------
61 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 413
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
0
---------------------------------
62 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c cfunc 100
static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,
const uint8_t *buf = avpkt->data;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {
samples     = s->frame.data[0];
memcpy(samples, buf, out_size);
0
---------------------------------
63 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 1310
process_rtsp_request(tvbuff_t *tvb, int offset, const guchar *data,
(len == linelen || isspace(data[len])))
g_ascii_strncasecmp(rtsp_methods[ii], data, len) == 0 &&
url = data;
while (url < lineend && !isspace(*url))
url++;
while (url < lineend && isspace(*url))
url++;
while (url < lineend && !isspace(*url))
url++;
while (url < lineend && !isspace(*url))
0
---------------------------------
64 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 1310
process_rtsp_request(tvbuff_t *tvb, int offset, const guchar *data,
(len == linelen || isspace(data[len])))
g_ascii_strncasecmp(rtsp_methods[ii], data, len) == 0 &&
url = data;
while (url < lineend && !isspace(*url))
url++;
while (url < lineend && isspace(*url))
url++;
while (url < lineend && !isspace(*url))
url++;
while (url < lineend && !isspace(*url))
0
---------------------------------
65 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 729
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
int           indent)
fprintf(stderr, "DEBUG: %*sBOOLEAN %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sOCTET STRING %d bytes \"%s\"\n", indent, "",
fprintf(stderr, "DEBUG: %*sOID %d bytes ", indent, "",
fprintf(stderr, ".%d", oid[i]);
putc('\n', stderr);
fprintf(stderr, "DEBUG: %*sINTEGER %d bytes %d\n", indent, "",
0
---------------------------------
66 CVE-2016-0799/OpenSSL_1.0.1_CVE-2016-0799_b_print.c cfunc 252
const char *format,
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
if (isdigit((unsigned char)ch)) {
0
---------------------------------
67 CVE-2016-0799/OpenSSL_1.0.1_CVE-2016-0799_b_print.c cppfunc 252
const char *format,
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
if (isdigit((unsigned char)ch)) {
0
---------------------------------
68 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 848
unsigned char *buf = NULL;
unsigned char *bitmask = NULL;
frag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));
return NULL;
return NULL;
frag->fragment = buf;
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
return NULL;
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
frag->reassembly = bitmask;
return frag;
frag = dtls1_hm_fragment_new(frag_len, 0);
memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
unsigned char wire[DTLS1_HM_HEADER_LENGTH];
struct hm_header_st msg_hdr;
i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, wire,
dtls1_get_message_header(wire, &msg_hdr);
n2l3(data, msg_hdr->msg_len);
n2s(data, msg_hdr->seq);
n2l3(data, msg_hdr->frag_off);
n2l3(data, msg_hdr->frag_len);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr,
unsigned long frag_len = msg_hdr->frag_len;
frag = dtls1_hm_fragment_new(frag_len, 0);
static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len,
buf = (unsigned char *)OPENSSL_malloc(frag_len);
frag->fragment = buf;
return frag;
frag = dtls1_hm_fragment_new(frag_len, 0);
memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
msg_hdr->type = *(data++);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
0
---------------------------------
69 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 2160
int            version,
const unsigned request_id,
packet.version      = version;
packet.request_type = ASN1_GET_REQUEST;
packet.request_id   = request_id;
packet.object_type  = ASN1_NULL_VALUE;
strlcpy(packet.community, community, sizeof(packet.community));
bytes = asn1_encode_snmp(buffer, sizeof(buffer), &packet);
snmp_packet_t *packet);
memset(&packet, 0, sizeof(packet));
bytes = asn1_encode_snmp(buffer, sizeof(buffer), &packet);
snmp_packet_t	packet;
bytes = asn1_encode_snmp(buffer, sizeof(buffer), &packet);
packet.error);
0
---------------------------------
70 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 454
unz_file_info *p_fileInfo = calloc( 1, sizeof( unz_file_info ) );
if( unzGetCurrentFileInfo( file, p_fileInfo, psz_fileName,
free( p_fileInfo );
0
---------------------------------
71 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 454
unz_file_info *p_fileInfo = calloc( 1, sizeof( unz_file_info ) );
if( unzGetCurrentFileInfo( file, p_fileInfo, psz_fileName,
free( p_fileInfo );
0
---------------------------------
72 CVE-2013-0799/Firefox_19.0_CVE_2013_0799_toolkit_components_maintenanceservice_workmonitor.cpp cfunc 276
LPWSTR cmdLine = MakeCommandLine(argc, argv);
LOG(("Starting service with cmdline: %ls", cmdLine));
processStarted = CreateProcessW(argv[0], cmdLine,
free(cmdLine);
0
---------------------------------
73 CVE-2013-0799/Firefox_19.0_CVE_2013_0799_toolkit_components_maintenanceservice_workmonitor.cpp cppfunc 276
LPWSTR cmdLine = MakeCommandLine(argc, argv);
LOG(("Starting service with cmdline: %ls", cmdLine));
processStarted = CreateProcessW(argv[0], cmdLine,
free(cmdLine);
0
---------------------------------
74 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_workmonitor.cpp cfunc 396
char updaterIdentity[64];
updaterIdentity, sizeof(updaterIdentity))) {
if (strcmp(updaterIdentity, UPDATER_IDENTITY_STRING)) {
0
---------------------------------
75 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1168
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
size -= 2;
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
if (!tls1_process_sigalgs(s, data, dsize))
size -= 2;
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
0
---------------------------------
76 CVE-2016-4441/qemu_2.3.0_CVE-2016-4441_esp.c cfunc 365
static void sysbus_esp_gpio_demux(void *opaque, int irq, int level)
SysBusESPState *sysbus = ESP(opaque);
ESPState *s = &sysbus->esp;
parent_esp_reset(s, irq, level);
static void parent_esp_reset(ESPState *s, int irq, int level)
esp_soft_reset(s);
static void esp_soft_reset(ESPState *s)
qemu_irq_lower(s->irq);
esp_hard_reset(s);
void esp_hard_reset(ESPState *s)
memset(s->rregs, 0, ESP_REGS);
static void sysbus_esp_mem_write(void *opaque, hwaddr addr,
esp_reg_write(&sysbus->esp, saddr, val);
void esp_reg_write(ESPState *s, uint32_t saddr, uint64_t val)
esp_soft_reset(s);
static void sysbus_esp_hard_reset(DeviceState *dev)
SysBusESPState *sysbus = ESP(dev);
esp_hard_reset(&sysbus->esp);
0
---------------------------------
77 CVE-2016-4441/qemu_2.3.0_CVE-2016-4441_esp.c cfunc 366
static void sysbus_esp_gpio_demux(void *opaque, int irq, int level)
SysBusESPState *sysbus = ESP(opaque);
ESPState *s = &sysbus->esp;
parent_esp_reset(s, irq, level);
static void parent_esp_reset(ESPState *s, int irq, int level)
esp_soft_reset(s);
static void esp_soft_reset(ESPState *s)
esp_hard_reset(s);
void esp_hard_reset(ESPState *s)
memset(s->rregs, 0, ESP_REGS);
memset(s->wregs, 0, ESP_REGS);
static void sysbus_esp_hard_reset(DeviceState *dev)
SysBusESPState *sysbus = ESP(dev);
esp_hard_reset(&sysbus->esp);
static void sysbus_esp_mem_write(void *opaque, hwaddr addr,
esp_reg_write(&sysbus->esp, saddr, val);
void esp_reg_write(ESPState *s, uint32_t saddr, uint64_t val)
esp_soft_reset(s);
0
---------------------------------
78 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4746
const char *spec)
char *endptr;
sid = strtol(spec + 1, &endptr, 0);
0
---------------------------------
79 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4746
const char *spec)
char *endptr;
sid = strtol(spec + 1, &endptr, 0);
0
---------------------------------
80 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 323
static void Close( vlc_object_t *p_this )
access_sys_t *p_sys = p_access->p_sys;
p_sys->p_smb->close( p_sys->p_smb, p_sys->p_file );
smbc_free_context( p_sys->p_smb, 1 );
free( p_sys );
0
---------------------------------
81 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 323
static void Close( vlc_object_t *p_this )
access_sys_t *p_sys = p_access->p_sys;
p_sys->p_smb->close( p_sys->p_smb, p_sys->p_file );
smbc_free_context( p_sys->p_smb, 1 );
free( p_sys );
0
---------------------------------
82 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 487
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
0
---------------------------------
83 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4460
if (!(ptr = strchr(key, '=')))
ptr++;
for (; *ptr && !(isspace(*ptr) || *ptr == ','); ptr++)
key = ptr;
if (!(ptr = strchr(key, '=')))
0
---------------------------------
84 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 408
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
0
---------------------------------
85 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1381
const char *old_make_model,
if (!strncasecmp(old_make_model, "Hewlett-Packard", 15))
mmptr = (char *)old_make_model + 15;
mmptr ++;
while (isspace(*mmptr & 255))
0
---------------------------------
86 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1381
const char *old_make_model,
if (!strncasecmp(old_make_model, "Hewlett-Packard", 15))
mmptr = (char *)old_make_model + 15;
mmptr ++;
while (isspace(*mmptr & 255))
0
---------------------------------
87 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 401
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
0
---------------------------------
88 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1388
const char *old_make_model,
if (!strncasecmp(old_make_model, "Hewlett-Packard", 15))
mmptr = (char *)old_make_model + 15;
while (isspace(*mmptr & 255))
mmptr ++;
if (!strncasecmp(mmptr, "hp", 2))
mmptr += 2;
mmptr ++;
while (isspace(*mmptr & 255))
0
---------------------------------
89 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1388
const char *old_make_model,
if (!strncasecmp(old_make_model, "Hewlett-Packard", 15))
mmptr = (char *)old_make_model + 15;
while (isspace(*mmptr & 255))
mmptr ++;
if (!strncasecmp(mmptr, "hp", 2))
mmptr += 2;
mmptr ++;
while (isspace(*mmptr & 255))
0
---------------------------------
90 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 402
nsAutoString atomString;
pseudoTag->ToString(atomString);
NS_LossyConvertUTF16toASCII(atomString).get());
0
---------------------------------
91 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 405
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
0
---------------------------------
92 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 775
size_t        len,
asn1_debug(buffer, value_length, indent + 4);
value_length = asn1_get_length(&buffer, bufend);
value_length);
0
---------------------------------
93 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 1150
if(strcmp(s->iformat->name, "mov,mp4,m4a,3gp,3g2,mj2"))
!strcmp(s->iformat->name, "mpegts"))){
&& (!strcmp(s->iformat->name, "mpeg") ||
0
---------------------------------
94 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1980
snmp_cache_t	key,
key.addrname = addrname;
device       = (snmp_cache_t *)cupsArrayFind(Devices, &key);
free(device->make_and_model);
0
---------------------------------
95 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1980
snmp_cache_t	key,
key.addrname = addrname;
device       = (snmp_cache_t *)cupsArrayFind(Devices, &key);
free(device->make_and_model);
0
---------------------------------
96 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_workmonitor.cpp API 400
wcsncpy(aResultDir, argvTmp[2], MAX_PATH);
bool backgroundUpdate = IsUpdateBeingStaged(argcTmp, argvTmp);
LOAD_LIBRARY_AS_DATAFILE);
HMODULE updaterModule = LoadLibraryEx(argv[0], NULL,
if (!LoadStringA(updaterModule, IDS_UPDATER_IDENTITY,
FreeLibrary(updaterModule);
if (!PathRemoveFileSpecW(serviceUpdaterPath)) {
if (!PathAppendSafe(serviceUpdaterPath, L"update")) {
CreateDirectoryW(serviceUpdaterPath, NULL);
if (!PathAppendSafe(serviceUpdaterPath, L"updater.exe")) {
result = DeleteFileW(serviceUpdaterPath);
serviceUpdaterPath));
if (PathGetSiblingFilePath(updaterINIPath, serviceUpdaterPath,
WCHAR secureUpdaterPath[MAX_PATH + 1] = { L'\0' };
result = GetSecureUpdaterPath(secureUpdaterPath);
oldUpdaterPath, secureUpdaterPath));
DeleteSecureUpdater(secureUpdaterPath);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
IsUpdateBeingStaged(int argc, LPWSTR *argv)
return argc == 4 && !wcscmp(argv[3], L"-1");
bool replaceRequest = (argcTmp >= 4 && wcsstr(argvTmp[3], L"/replace"));
if (!IsLocalFile(argv[0], isLocal) || !isLocal) {
nsAutoHandle noWriteLock(CreateFileW(argv[0], GENERIC_READ, FILE_SHARE_READ,
if (result && !VerifySameFiles(argv[0], installDirUpdater,
HMODULE updaterModule = LoadLibraryEx(argv[0], NULL,
if (!LoadStringA(updaterModule, IDS_UPDATER_IDENTITY,
FreeLibrary(updaterModule);
DeleteSecureUpdater(WCHAR serviceUpdaterPath[MAX_PATH + 1])
result = CopyFileW(oldUpdaterPath, secureUpdaterPath, FALSE);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv)
if (!GetInstallationDir(argc, argv, installDir)) {
GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH + 1])
if (!IsLocalFile(argv[0], isLocal) || !isLocal) {
nsAutoHandle noWriteLock(CreateFileW(argv[0], GENERIC_READ, FILE_SHARE_READ,
if (result && !VerifySameFiles(argv[0], installDirUpdater,
HMODULE updaterModule = LoadLibraryEx(argv[0], NULL,
if (!LoadStringA(updaterModule, IDS_UPDATER_IDENTITY,
FreeLibrary(updaterModule);
BOOL PathGetSiblingFilePath(LPWSTR destinationBuffer,  LPCWSTR siblingFilePath,
result = CopyFileW(oldUpdaterPath, secureUpdaterPath, FALSE);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
GetSecureUpdaterPath(WCHAR serviceUpdaterPath[MAX_PATH + 1])
if (!GetModuleFileNameW(NULL, serviceUpdaterPath, MAX_PATH)) {
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
0
---------------------------------
97 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 377
uint8_t* frame_buffer,
size_t frame_buffer_length,
memset(fragmentation->fragmentationLength, 0,
(*it).dataPtr - frame_buffer;
fragmentation->fragmentationOffset[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
fragmentation->fragmentationOffset[0] = 0;
for (int i = 1; i < fragmentation->fragmentationVectorSize; ++i) {
fragmentation->fragmentationOffset[i - 1] +
fragmentation->fragmentationLength[i - 1];
fragmentation->fragmentationOffset[i] =
fragmentation->fragmentationOffset[i - 1]);
fragmentation->fragmentationOffset[i] >=
assert(i == 0 ||
0
---------------------------------
98 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cppfunc 377
uint8_t* frame_buffer,
size_t frame_buffer_length,
memset(fragmentation->fragmentationLength, 0,
(*it).dataPtr - frame_buffer;
fragmentation->fragmentationOffset[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
fragmentation->fragmentationOffset[0] = 0;
for (int i = 1; i < fragmentation->fragmentationVectorSize; ++i) {
fragmentation->fragmentationOffset[i - 1] +
fragmentation->fragmentationLength[i - 1];
fragmentation->fragmentationOffset[i] =
fragmentation->fragmentationOffset[i - 1]);
fragmentation->fragmentationOffset[i] >=
assert(i == 0 ||
0
---------------------------------
99 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 149
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
"  <track>\n"
if( astrcatf( pp_buffer,
" </trackList>\n"
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  <vlc:node title=\"%s\">\n", n->name ) < 0 )
if( astrcatf( pp_buffer, "   <vlc:item tid=\"%d\" />\n", i->id ) < 0 )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
if( astrcatf( pp_buffer,
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
0
---------------------------------
100 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 147
va_list args;
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
va_end( args );
0
---------------------------------
100 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 147
va_list args;
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
va_end( args );
0
---------------------------------
101 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 147
va_list args;
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
va_end( args );
0
---------------------------------
102 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 196
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
psz_domain = strdup( psz_tmp );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( !psz_pwd ) psz_pwd = var_CreateGetString( p_access, "smb-pwd" );
if( !psz_domain ) psz_domain = var_CreateGetString( p_access, "smb-domain" );
if( psz_domain && !*psz_domain ) { free( psz_domain ); psz_domain = 0; }
0
---------------------------------
103 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 196
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
psz_domain = strdup( psz_tmp );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( !psz_pwd ) psz_pwd = var_CreateGetString( p_access, "smb-pwd" );
if( !psz_domain ) psz_domain = var_CreateGetString( p_access, "smb-domain" );
if( psz_domain && !*psz_domain ) { free( psz_domain ); psz_domain = 0; }
0
---------------------------------
104 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 194
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_pwd = strdup( psz_parser+1 );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( !psz_pwd ) psz_pwd = var_CreateGetString( p_access, "smb-pwd" );
if( psz_pwd && !*psz_pwd ) { free( psz_pwd ); psz_pwd = 0; }
0
---------------------------------
105 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 194
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_pwd = strdup( psz_parser+1 );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( !psz_pwd ) psz_pwd = var_CreateGetString( p_access, "smb-pwd" );
if( psz_pwd && !*psz_pwd ) { free( psz_pwd ); psz_pwd = 0; }
0
---------------------------------
106 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 192
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
*psz_parser = 0; psz_parser++;
else psz_parser = psz_tmp;
psz_user = strdup( psz_parser );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( psz_user && !*psz_user ) { free( psz_user ); psz_user = 0; }
0
---------------------------------
107 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 192
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
*psz_parser = 0; psz_parser++;
else psz_parser = psz_tmp;
psz_user = strdup( psz_parser );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( psz_user && !*psz_user ) { free( psz_user ); psz_user = 0; }
0
---------------------------------
108 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 616
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
i_num++;
*ppsz_encoded = malloc( i_len + 1 );
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
char *psz_ret = malloc( i_len + 3*i_num + 2 );
*ppsz_encoded = psz_ret;
char *psz_pathtozip;
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
int i_track = 0;
psz_file = convert_xml_special_chars( psz_file ?
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
psz_path, psz_file, i_track ) < 0 ) return -1;
parent->media = new_item( i_track );
tmp->next = new_item( i_track );
inline static item* new_item( int id )
psz_path, psz_file, i_track ) < 0 ) return -1;
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
psz_path, psz_file, i_track ) < 0 ) return -1;
free( psz_path );
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
escapeToXml( &psz_pathtozip, psz_zippath );
char *psz_path = strdup( psz_pathtozip );
psz_path, psz_file, i_track ) < 0 ) return -1;
0
---------------------------------
109 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 616
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
i_num++;
*ppsz_encoded = malloc( i_len + 1 );
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
char *psz_ret = malloc( i_len + 3*i_num + 2 );
*ppsz_encoded = psz_ret;
char *psz_pathtozip;
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
int i_track = 0;
psz_file = convert_xml_special_chars( psz_file ?
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
psz_path, psz_file, i_track ) < 0 ) return -1;
parent->media = new_item( i_track );
tmp->next = new_item( i_track );
inline static item* new_item( int id )
psz_path, psz_file, i_track ) < 0 ) return -1;
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
psz_path, psz_file, i_track ) < 0 ) return -1;
free( psz_path );
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
escapeToXml( &psz_pathtozip, psz_zippath );
char *psz_path = strdup( psz_pathtozip );
psz_path, psz_file, i_track ) < 0 ) return -1;
0
---------------------------------
110 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 214
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
psz_domain = strdup( psz_tmp );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( !psz_pwd ) psz_pwd = var_CreateGetString( p_access, "smb-pwd" );
if( !psz_domain ) psz_domain = var_CreateGetString( p_access, "smb-domain" );
if( psz_domain && !*psz_domain ) { free( psz_domain ); psz_domain = 0; }
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
free( psz_domain );
char *psz_domain )
VLC_UNUSED( psz_domain );
free( psz_domain );
0
---------------------------------
111 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 214
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
psz_domain = strdup( psz_tmp );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( !psz_pwd ) psz_pwd = var_CreateGetString( p_access, "smb-pwd" );
if( !psz_domain ) psz_domain = var_CreateGetString( p_access, "smb-domain" );
if( psz_domain && !*psz_domain ) { free( psz_domain ); psz_domain = 0; }
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
free( psz_domain );
char *psz_domain )
VLC_UNUSED( psz_domain );
free( psz_domain );
0
---------------------------------
112 CVE-2013-0799/Firefox_19.0_CVE_2013_0799_toolkit_components_maintenanceservice_workmonitor.cpp API 210
PROCESS_INFORMATION pi = {0};
NULL, &si, &pi);
DWORD waitRes = WaitForSingleObject(pi.hProcess, TIME_TO_WAIT_ON_UPDATER);
TerminateProcess(pi.hProcess, 1);
if (GetExitCodeProcess(pi.hProcess, &returnCode)) {
CloseHandle(pi.hProcess);
0
---------------------------------
113 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 212
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
*psz_parser = 0; psz_parser++;
else psz_parser = psz_tmp;
psz_user = strdup( psz_parser );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( psz_user && !*psz_user ) { free( psz_user ); psz_user = 0; }
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
free( psz_user );
char *psz_user, char *psz_pwd,
free( psz_user );
i_result = OurWNetAddConnection2( &net_resource, psz_pwd, psz_user, 0 );
free( psz_user );
0
---------------------------------
114 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 212
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
*psz_parser = 0; psz_parser++;
else psz_parser = psz_tmp;
psz_user = strdup( psz_parser );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( psz_user && !*psz_user ) { free( psz_user ); psz_user = 0; }
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
free( psz_user );
char *psz_user, char *psz_pwd,
free( psz_user );
i_result = OurWNetAddConnection2( &net_resource, psz_pwd, psz_user, 0 );
free( psz_user );
0
---------------------------------
115 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 213
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_pwd = strdup( psz_parser+1 );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( !psz_pwd ) psz_pwd = var_CreateGetString( p_access, "smb-pwd" );
if( psz_pwd && !*psz_pwd ) { free( psz_pwd ); psz_pwd = 0; }
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
free( psz_pwd );
char *psz_user, char *psz_pwd,
free( psz_pwd );
i_result = OurWNetAddConnection2( &net_resource, psz_pwd, psz_user, 0 );
free( psz_pwd );
0
---------------------------------
116 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 213
static int Open( vlc_object_t *p_this )
access_t     *p_access = (access_t*)p_this;
char         *psz_user = 0, *psz_pwd = 0, *psz_domain = 0;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_pwd = strdup( psz_parser+1 );
if( !psz_user ) psz_user = var_CreateGetString( p_access, "smb-user" );
if( !psz_pwd ) psz_pwd = var_CreateGetString( p_access, "smb-pwd" );
if( psz_pwd && !*psz_pwd ) { free( psz_pwd ); psz_pwd = 0; }
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
free( psz_pwd );
char *psz_user, char *psz_pwd,
free( psz_pwd );
i_result = OurWNetAddConnection2( &net_resource, psz_pwd, psz_user, 0 );
free( psz_pwd );
0
---------------------------------
117 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 466
if ((device_uri = calloc(1, sizeof(device_uri_t))) == NULL)
if ((device_uri->uris = cupsArrayNew(NULL, NULL)) == NULL)
free(device_uri);
0
---------------------------------
118 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 466
if ((device_uri = calloc(1, sizeof(device_uri_t))) == NULL)
if ((device_uri->uris = cupsArrayNew(NULL, NULL)) == NULL)
free(device_uri);
0
---------------------------------
119 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 56
avi_chunk_t chk;
if( AVI_ChunkReadCommon( s, &chk ) )
int  _AVI_ChunkRead( stream_t *s, avi_chunk_t *p_chk, avi_chunk_t *p_father )
if( AVI_ChunkReadCommon( s, p_chk ) )
static int AVI_ChunkReadCommon( stream_t *s, avi_chunk_t *p_chk )
memset( p_chk, 0, sizeof( avi_chunk_t ) );
0
---------------------------------
120 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 970
void NetworkUtils::disableNat(CommandChain* aChain,
if (!GET_FIELD(mIp).IsEmpty() && !GET_FIELD(mPrefix).IsEmpty()) {
uint32_t prefix = atoi(GET_CHAR(mPrefix));
uint32_t ip = inet_addr(GET_CHAR(mIp));
char* networkAddr = getNetworkAddr(ip, prefix);
GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname), networkAddr,
0
---------------------------------
121 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 971
void NetworkUtils::disableNat(CommandChain* aChain,
if (!GET_FIELD(mIp).IsEmpty() && !GET_FIELD(mPrefix).IsEmpty()) {
uint32_t prefix = atoi(GET_CHAR(mPrefix));
uint32_t ip = inet_addr(GET_CHAR(mIp));
GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname), networkAddr,
GET_CHAR(mPrefix));
0
---------------------------------
122 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 703
folder = path;
char *sep = strchr( folder, '/' );
*sep = '\0';
return findOrCreateParentNode( current, sep );
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
char *path = strdup( fullpath );
free( path );
0
---------------------------------
123 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 703
folder = path;
char *sep = strchr( folder, '/' );
*sep = '\0';
return findOrCreateParentNode( current, sep );
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
char *path = strdup( fullpath );
free( path );
0
---------------------------------
124 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 367
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
0
---------------------------------
125 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 233
PROCESS_INFORMATION pi = {0};
NULL, installDir, &si, &pi);
CloseHandle(pi.hThread);
0
---------------------------------
126 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 232
PROCESS_INFORMATION pi = {0};
NULL, installDir, &si, &pi);
CloseHandle(pi.hProcess);
0
---------------------------------
127 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 2518
path->data = NULL;
path->size = 0;
if (!strncmp(s1->data, s2->data, s1->size - 1)) {
V9fsPath oldpath, newpath;
v9fs_path_init(&oldpath);
v9fs_co_name_to_path(pdu, olddir, old_name->data, &oldpath);
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &newpath, strlen(oldpath.data));
static int v9fs_path_is_ancestor(V9fsPath *s1, V9fsPath *s2)
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &newpath, strlen(oldpath.data));
void v9fs_path_init(V9fsPath *path)
v9fs_path_init(&oldpath);
v9fs_fix_path(&tfidp->path, &newpath, strlen(oldpath.data));
0
---------------------------------
128 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4726
const char *spec)
char *endptr;
spec += 2;
prog_id = strtol(spec, &endptr, 0);
0
---------------------------------
129 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4726
const char *spec)
char *endptr;
spec += 2;
prog_id = strtol(spec, &endptr, 0);
0
---------------------------------
130 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 1416
Ogg_LogicalStreamDelete( p_demux, p_ogg->pp_stream[i_stream] );
static void Ogg_LogicalStreamDelete( demux_t *p_demux, logical_stream_t *p_stream );
free( p_ogg->pp_stream );
0
---------------------------------
131 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cppfunc 1416
Ogg_LogicalStreamDelete( p_demux, p_ogg->pp_stream[i_stream] );
static void Ogg_LogicalStreamDelete( demux_t *p_demux, logical_stream_t *p_stream );
free( p_ogg->pp_stream );
0
---------------------------------
132 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 242
void StreamClose( vlc_object_t *p_this )
stream_sys_t *p_sys = s->p_sys;
unzClose( p_sys->zipFile );
free( p_sys->fileFunctions );
free( p_sys->psz_xspf );
free( p_sys->psz_path );
free( p_sys );
0
---------------------------------
133 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 242
void StreamClose( vlc_object_t *p_this )
stream_sys_t *p_sys = s->p_sys;
unzClose( p_sys->zipFile );
free( p_sys->fileFunctions );
free( p_sys->psz_xspf );
free( p_sys->psz_path );
free( p_sys );
0
---------------------------------
134 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 488
void *data, int *data_size,
const uint8_t *buf, int buf_size)
unsigned char *output_samples = (unsigned char *)data;
const unsigned char *p = buf + 16;
*data_size = vmdaudio_loadsound(s, output_samples, p, 0, buf_size - 16);
uint32_t flags = AV_RB32(p);
int raw_block_size = s->block_align * s->bits / 8;
silent_chunks = 32;
silent_chunks = av_log2(flags + 1);
memset(output_samples, 0, raw_block_size * silent_chunks);
output_samples += raw_block_size * silent_chunks;
*data_size += vmdaudio_loadsound(s, output_samples, p + 4, 0, buf_size - 20);
*data_size = vmdaudio_loadsound(s, output_samples, p, 1, 0);
const uint8_t *buf, int silence, int data_size)
memset(data, 0, data_size * 2);
static int vmdaudio_loadsound(VmdAudioContext *s, unsigned char *data,
memset(data, 0, data_size * 2);
0
---------------------------------
135 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 510
add_device_uri(char *value)
value ++;
for (start = value; *value && *value != '\"'; value ++)
*value++ = '\0';
while (isspace(*value & 255))
value ++;
for (start = value; *value && !isspace(*value & 255); value ++);
*value++ = '\0';
for (start = value; *value && !isspace(*value & 255); value ++);
0
---------------------------------
136 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 510
add_device_uri(char *value)
value ++;
for (start = value; *value && *value != '\"'; value ++)
*value++ = '\0';
while (isspace(*value & 255))
value ++;
for (start = value; *value && !isspace(*value & 255); value ++);
*value++ = '\0';
for (start = value; *value && !isspace(*value & 255); value ++);
0
---------------------------------
137 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 1026
! memcmp( &oggpacket.packet[1], "kate\0\0\0", 7 ) )
! memcmp( oggpacket.packet, "\x01vorbis", 7 ) )
! memcmp( oggpacket.packet, "Speex", 5 ) )
! memcmp( oggpacket.packet, "fLaC", 4 ) )
! memcmp( oggpacket.packet, "\x80theora", 7 ) )
! memcmp( oggpacket.packet, "KW-DIRAC\x00", 9 ) ) )
! memcmp( oggpacket.packet, "BBCD\x00", 5 ) ) ||
! memcmp( oggpacket.packet, "Annodex", 7 ) )
! memcmp( oggpacket.packet, "AnxData", 7 ) )
0
---------------------------------
138 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 759
size_t        len,
asn1_debug(buffer, value_length, indent + 4);
value_length = asn1_get_length(&buffer, bufend);
value_length);
0
---------------------------------
139 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 930
static uint32_t vmsvga_value_read(void *opaque, uint32_t address)
printf("%s: Bad register %02x\n", __func__, s->index);
static uint64_t vmsvga_io_read(void *opaque, hwaddr addr, unsigned size)
struct vmsvga_state_s *s = opaque;
case SVGA_IO_MUL * SVGA_VALUE_PORT: return vmsvga_value_read(s, addr);
0
---------------------------------
140 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 711
unsigned char *buf = NULL;
unsigned char *bitmask = NULL;
frag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));
return NULL;
return NULL;
frag->fragment = buf;
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
return NULL;
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
frag->reassembly = bitmask;
return frag;
frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
unsigned char wire[DTLS1_HM_HEADER_LENGTH];
struct hm_header_st msg_hdr;
i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, wire,
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_reassemble_fragment(s, &msg_hdr, ok);
n2l3(data, msg_hdr->msg_len);
n2s(data, msg_hdr->seq);
n2l3(data, msg_hdr->frag_off);
n2l3(data, msg_hdr->frag_len);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr, int *ok)
frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len,
buf = (unsigned char *)OPENSSL_malloc(frag_len);
frag->fragment = buf;
return frag;
frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
msg_hdr->type = *(data++);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_reassemble_fragment(s, &msg_hdr, ok);
dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr,
return dtls1_reassemble_fragment(s, msg_hdr, ok);
0
---------------------------------
141 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 1297
size_t len = strlen(rtsp_methods[ii]);
g_ascii_strncasecmp(rtsp_methods[ii], data, len) == 0 &&
for (ii = 0; ii < RTSP_NMETHODS; ii++) {
if (ii == RTSP_NMETHODS) {
(gint) strlen(rtsp_methods[ii]), rtsp_methods[ii]);
0
---------------------------------
142 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 815
nsBlockFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
InlinePrefWidthData data;
curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
line == curFrame->begin_lines()) {
if (!curFrame->GetPrevContinuation() &&
const nsStyleCoord &indent = GetStyleText()->mTextIndent;
if (indent.ConvertsToLength())
data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
data.lineContainer = curFrame;
for (int32_t i = 0, i_end = line->GetChildCount(); i != i_end;
data.line = &line;
kid->AddInlinePrefWidth(aRenderingContext, &data);
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
kid->AddInlinePrefWidth(aRenderingContext, &data);
data.prevLines, data.currentLine);
kid->AddInlinePrefWidth(aRenderingContext, &data);
data.prevLines, data.currentLine);
return nsBidiPresUtils::Resolve(this);
for (nsBlockFrame* curFrame = this; curFrame;
for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
line->IsBlock() ? "block" : "inline",
line->IsEmpty() ? ", empty" : "");
if (line->IsBlock()) {
line->mFirstChild, nsLayoutUtils::PREF_WIDTH);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.ForceBreak(aRenderingContext);
data.ForceBreak(aRenderingContext);
data.line = &line;
data.ForceBreak(aRenderingContext);
data.ForceBreak(aRenderingContext);
kid->AddInlinePrefWidth(aRenderingContext, &data);
data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
data.prevLines, data.currentLine);
0
---------------------------------
143 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 671
char   *p;
buf[line_len] = '\0';
tmp = buf + STRLEN_CONST(rtsp_content_length);
while (*tmp && isspace(*tmp))
tmp++;
content_length = strtol(tmp, &p, 10);
0
---------------------------------
144 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 671
char   *p;
buf[line_len] = '\0';
tmp = buf + STRLEN_CONST(rtsp_content_length);
while (*tmp && isspace(*tmp))
tmp++;
content_length = strtol(tmp, &p, 10);
0
---------------------------------
145 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 673
char   *p;
content_length = strtol(tmp, &p, 10);
up = p;
if (up == tmp || (*up != '\0' && !isspace(*up)))
0
---------------------------------
146 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 673
char   *p;
content_length = strtol(tmp, &p, 10);
up = p;
if (up == tmp || (*up != '\0' && !isspace(*up)))
0
---------------------------------
147 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 969
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
ssl_check_for_safari(s, data, limit);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
unsigned short type, size;
static const unsigned char kSafariTLS12ExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
0
---------------------------------
148 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_maintenanceservice.cpp API 228
NULL, 0, NULL);
HANDLE thread = CreateThread(NULL, 0, EnsureProcessTerminatedThread,
CloseHandle(thread);
0
---------------------------------
149 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 887
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(0, ret);
int el;
if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(0, ret);
s2n(TLSEXT_TYPE_status_request, ret);
s2n(0, ret);
size_t sol = s->s3->server_opaque_prf_input_len;
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(sol + 2, ret);
s2n(sol, ret);
memcpy(ret, s->s3->server_opaque_prf_input, sol);
ret += sol;
int el;
ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);
s2n(TLSEXT_TYPE_use_srtp, ret);
s2n(el, ret);
if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {
ret += el;
memcpy(ret, cryptopro_ext, 36);
ret += 36;
s2n(TLSEXT_TYPE_heartbeat, ret);
s2n(1, ret);
*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
*(ret++) = SSL_TLSEXT_HB_ENABLED;
const unsigned char *npa;
unsigned int npalen;
r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,
s2n(TLSEXT_TYPE_next_proto_neg, ret);
s2n(npalen, ret);
memcpy(ret, npa, npalen);
0
---------------------------------
150 CVE-2011-3940/Ffmpeg_0.7.11_CVE_2011_3940_libavformat_nsvdec.c cfunc 683
static int nsv_read_packet(AVFormatContext *s, AVPacket *pkt)
memcpy(pkt, &nsv->ahead[i], sizeof(AVPacket));
nsv->ahead[i].data = NULL;
memcpy(pkt, &nsv->ahead[i], sizeof(AVPacket));
0
---------------------------------
151 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp cfunc 275
char *entity = nullptr;
rv = mEntityConverter->ConvertUTF32ToEntity(inUCS4, mEntityVersion, &entity);
if (!entity || (int32_t)strlen(entity) > bufferLength) {
0
---------------------------------
152 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 2754
st = ic->streams[pkt->stream_index];
double dts= (is_relative(pkt->dts) ?  pkt->dts - RELATIVE_TS_BASE : pkt->dts) * av_q2d(st->time_base);
double sdts= dts*framerate/(1001*12);
int ticks= lrintf(sdts+j*0.5);
static int is_relative(int64_t ts) {
double dts= (is_relative(pkt->dts) ?  pkt->dts - RELATIVE_TS_BASE : pkt->dts) * av_q2d(st->time_base);
double sdts= dts*framerate/(1001*12);
int ticks= lrintf(sdts+j*0.5);
0
---------------------------------
153 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 1345
process_rtsp_reply(tvbuff_t *tvb, int offset, const guchar *data,
const guchar *status   = data;
while (status < lineend && !isspace(*status))
status++;
while (status < lineend && isspace(*status))
status++;
while (status < lineend && isspace(*status))
0
---------------------------------
154 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 1345
process_rtsp_reply(tvbuff_t *tvb, int offset, const guchar *data,
const guchar *status   = data;
while (status < lineend && !isspace(*status))
status++;
while (status < lineend && isspace(*status))
status++;
while (status < lineend && isspace(*status))
0
---------------------------------
155 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 435
int x0, int y0, int x1, int y1, int w, int h)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
width = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
DisplaySurface *surface = qemu_console_surface(s->vga.con);
int bypl = surface_stride(surface);
int bypp = surface_bytes_per_pixel(surface);
int width = bypp * w;
memmove(ptr[1], ptr[0], width);
0
---------------------------------
156 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1808
char		filename[1024],
line[1024],
if ((cups_serverroot = getenv("CUPS_SERVERROOT")) == NULL)
cups_serverroot = CUPS_SERVERROOT;
snprintf(filename, sizeof(filename), "%s/snmp.conf", cups_serverroot);
if ((fp = cupsFileOpen(filename, "r")) != NULL)
linenum = 0;
while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
fprintf(stderr, "ERROR: Missing value on line %d of %s!\n", linenum,
filename);
else if (!strcasecmp(line, "Address"))
else if (!strcasecmp(line, "Community"))
else if (!strcasecmp(line, "DebugLevel"))
else if (!strcasecmp(line, "DeviceURI"))
else if (!strcasecmp(line, "HostNameLookups"))
else if (!strcasecmp(line, "MaxRunTime"))
line, linenum, filename);
0
---------------------------------
157 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 901
int passes = 0;
growth = 0;
delta = 0;
passes++;
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
growth += delta;
passes, offset + growth, offset, growth);
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
growth += delta;
passes, offset + growth, offset, growth);
0
---------------------------------
158 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 900
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
growth += delta;
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
passes, offset + growth, offset, growth);
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
0
---------------------------------
159 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 766
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
int           indent)
fprintf(stderr, "DEBUG: %*sBOOLEAN %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sINTEGER %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sOCTET STRING %d bytes \"%s\"\n", indent, "",
fprintf(stderr, "DEBUG: %*sOID %d bytes ", indent, "",
asn1_debug(buffer, value_length, indent + 4);
fprintf(stderr, ".%d", oid[i]);
putc('\n', stderr);
fprintf(stderr, "DEBUG: %*sGet-Response-PDU %d bytes\n", indent, "",
fprintf(stderr, "DEBUG: %*sGet-Request-PDU %d bytes\n", indent, "",
0
---------------------------------
160 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 767
size_t        len,
asn1_debug(buffer, value_length, indent + 4);
value_length = asn1_get_length(&buffer, bufend);
value_length);
0
---------------------------------
161 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1805
*value;
while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
DebugLevel = atoi(value);
add_device_uri(value);
!strcasecmp(value, "double");
!strcasecmp(value, "true") ||
!strcasecmp(value, "yes") ||
HostNameLookups = !strcasecmp(value, "on") ||
MaxRunTime = atoi(value);
static device_uri_t	*add_device_uri(char *value);
MaxRunTime = atoi(value);
0
---------------------------------
162 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1805
*value;
while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
DebugLevel = atoi(value);
add_device_uri(value);
!strcasecmp(value, "double");
!strcasecmp(value, "true") ||
!strcasecmp(value, "yes") ||
HostNameLookups = !strcasecmp(value, "on") ||
MaxRunTime = atoi(value);
static device_uri_t	*add_device_uri(char *value);
MaxRunTime = atoi(value);
0
---------------------------------
163 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 626
HKEY testOnlyFallbackKey;
&testOnlyFallbackKey) != ERROR_SUCCESS) {
RegCloseKey(testOnlyFallbackKey);
0
---------------------------------
164 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1819
nsBlockFrame::BlockNeedsFloatManager(nsIFrame* aBlock)
NS_PRECONDITION(aBlock, "Must have a frame");
NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlock), "aBlock must be a block");
nsIFrame* parent = aBlock->GetParent();
return (aBlock->GetStateBits() & NS_BLOCK_FLOAT_MGR) ||
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
(parent && !parent->IsFloatContainingBlock());
return (aBlock->GetStateBits() & NS_BLOCK_FLOAT_MGR) ||
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nsBlockFrame::DrainPushedFloats(nsBlockReflowState& aState)
DrainPushedFloats(state);
rv = ReflowPushedFloats(state, fcBounds, fcStatus);
*aBottomMarginRoot = GetNextInFlow() == nullptr;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
*aTopMarginRoot = true;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
*aBottomMarginRoot = true;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nsBlockFrame::ReflowPushedFloats(nsBlockReflowState& aState,
rv = ReflowPushedFloats(state, fcBounds, fcStatus);
rv = ReflowDirtyLines(state);
if (0 != aState.ClearFloats(0, NS_STYLE_CLEAR_LEFT_AND_RIGHT)) {
nsBlockFrame::ReflowPushedFloats(nsBlockReflowState& aState,
rv = ReflowPushedFloats(state, fcBounds, fcStatus);
rv = ReflowDirtyLines(state);
nsBlockFrame::ReflowDirtyLines(nsBlockReflowState& aState)
printf(" computedWidth=%d\n", aState.mReflowState.ComputedWidth());
nsBlockFrame::GetEffectiveComputedHeight(const nsHTMLReflowState& aReflowState) const
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nscoord height = aReflowState.ComputedHeight();
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nsBlockFrame::Reflow(nsPresContext*           aPresContext,
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
*aTopMarginRoot = false;
*aBottomMarginRoot = false;
*aTopMarginRoot = GetPrevInFlow() == nullptr;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nsBlockFrame::IsMarginRoot(bool* aTopMarginRoot, bool* aBottomMarginRoot)
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
0
---------------------------------
165 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1424
unsigned char save_write_sequence[8];
memcpy(save_write_sequence, s->s3->write_sequence,
memcpy(s->s3->write_sequence, s->d1->last_write_sequence,
memcpy(s->d1->last_write_sequence, s->s3->write_sequence,
memcpy(s->s3->write_sequence, save_write_sequence,
0
---------------------------------
166 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1051
int dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen)
sender, slen,
i = s->method->ssl3_enc->final_finish_mac(s,
s->s3->tmp.finish_md);
i = s->method->ssl3_enc->final_finish_mac(s,
memcpy(p, s->s3->tmp.finish_md, i);
OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
memcpy(s->s3->previous_server_finished, s->s3->tmp.finish_md, i);
0
---------------------------------
167 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 758
fprintf(stderr, "DEBUG: %*sGet-Request-PDU %d bytes\n", indent, "",
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
int           indent)
asn1_debug(buffer, value_length, indent + 4);
fprintf(stderr, "DEBUG: %*sBOOLEAN %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sINTEGER %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sOCTET STRING %d bytes \"%s\"\n", indent, "",
fprintf(stderr, "DEBUG: %*sOID %d bytes ", indent, "",
fprintf(stderr, ".%d", oid[i]);
putc('\n', stderr);
fprintf(stderr, "DEBUG: %*sGet-Response-PDU %d bytes\n", indent, "",
fprintf(stderr, "DEBUG: %*sSEQUENCE %d bytes\n", indent, "",
0
---------------------------------
168 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 324
nullptr, nullptr, nullptr);
png_structp pngread = png_create_read_struct(PNG_LIBPNG_VER_STRING,
png_infop pnginfo = png_create_info_struct(pngread);
if (setjmp(png_jmpbuf(pngread))) {
0
---------------------------------
169 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cppfunc 324
nullptr, nullptr, nullptr);
png_structp pngread = png_create_read_struct(PNG_LIBPNG_VER_STRING,
png_infop pnginfo = png_create_info_struct(pngread);
if (setjmp(png_jmpbuf(pngread))) {
0
---------------------------------
170 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 871
static void print_sg(struct iovec *sg, int cnt)
printf("sg[%d]: {", cnt);
QEMUIOVector qiov;
qemu_iovec_init(&qiov, qiov_full.niov);
qemu_iovec_reset(&qiov);
qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);
print_sg(qiov.iov, qiov.niov);
QEMUIOVector qiov;
qemu_iovec_init(&qiov, qiov_full.niov);
print_sg(qiov.iov, qiov.niov);
len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);
qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);
qemu_iovec_reset(&qiov);
print_sg(qiov.iov, qiov.niov);
0
---------------------------------
171 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 876
printf("(%p, %zd)", sg[i].iov_base, sg[i].iov_len);
QEMUIOVector qiov;
qemu_iovec_init(&qiov, qiov_full.niov);
qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);
print_sg(qiov.iov, qiov.niov);
QEMUIOVector qiov;
qemu_iovec_init(&qiov, qiov_full.niov);
qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);
print_sg(qiov.iov, qiov.niov);
static void print_sg(struct iovec *sg, int cnt)
printf("sg[%d]: {", cnt);
printf("(%p, %zd)", sg[i].iov_base, sg[i].iov_len);
len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);
qemu_iovec_reset(&qiov);
print_sg(qiov.iov, qiov.niov);
len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);
qemu_iovec_reset(&qiov);
print_sg(qiov.iov, qiov.niov);
0
---------------------------------
172 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 120
const BlockDebugFlags* bdf = gFlags;
for (; bdf < end; bdf++) {
printf("  %s\n", bdf->name);
0
---------------------------------
173 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 347
if( CreatePlaylist( s, &p_sys->psz_xspf ) < 0 )
static int CreatePlaylist( stream_t *s, char **pp_buffer );
if( CreatePlaylist( s, &p_sys->psz_xspf ) < 0 )
p_sys->i_len = strlen( p_sys->psz_xspf );
0
---------------------------------
174 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 209
int StreamOpen( vlc_object_t *p_this )
stream_t *s = (stream_t*) p_this;
stream_sys_t *p_sys;
if( stream_Peek( s->p_source, &p_peek, i_zip_marker ) < i_zip_marker )
s->p_sys = p_sys = calloc( 1, sizeof( *p_sys ) );
s->pf_read = Read;
s->pf_peek = Peek;
s->pf_control = Control;
calloc( 1, sizeof( zlib_filefunc_def ) );
p_sys->fileFunctions = ( zlib_filefunc_def * )
p_sys->fileFunctions->zopen_file   = ZipIO_Open;
p_sys->fileFunctions->zread_file   = ZipIO_Read;
p_sys->fileFunctions->zwrite_file  = ZipIO_Write;
p_sys->fileFunctions->ztell_file   = ZipIO_Tell;
p_sys->fileFunctions->zseek_file   = ZipIO_Seek;
p_sys->fileFunctions->zclose_file  = ZipIO_Close;
p_sys->fileFunctions->zerror_file  = ZipIO_Error;
p_sys->fileFunctions->opaque       = ( void * ) s;
p_sys->zipFile = unzOpen2( NULL
free( p_sys->fileFunctions );
0
---------------------------------
175 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 209
int StreamOpen( vlc_object_t *p_this )
stream_t *s = (stream_t*) p_this;
stream_sys_t *p_sys;
if( stream_Peek( s->p_source, &p_peek, i_zip_marker ) < i_zip_marker )
s->p_sys = p_sys = calloc( 1, sizeof( *p_sys ) );
s->pf_read = Read;
s->pf_peek = Peek;
s->pf_control = Control;
calloc( 1, sizeof( zlib_filefunc_def ) );
p_sys->fileFunctions = ( zlib_filefunc_def * )
p_sys->fileFunctions->zopen_file   = ZipIO_Open;
p_sys->fileFunctions->zread_file   = ZipIO_Read;
p_sys->fileFunctions->zwrite_file  = ZipIO_Write;
p_sys->fileFunctions->ztell_file   = ZipIO_Tell;
p_sys->fileFunctions->zseek_file   = ZipIO_Seek;
p_sys->fileFunctions->zclose_file  = ZipIO_Close;
p_sys->fileFunctions->zerror_file  = ZipIO_Error;
p_sys->fileFunctions->opaque       = ( void * ) s;
p_sys->zipFile = unzOpen2( NULL
free( p_sys->fileFunctions );
0
---------------------------------
176 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 505
void *data, int *data_size,
const uint8_t *buf, int buf_size)
unsigned char *output_samples = (unsigned char *)data;
const unsigned char *p = buf + 16;
*data_size = vmdaudio_loadsound(s, output_samples, p, 0, buf_size - 16);
uint32_t flags = AV_RB32(p);
int raw_block_size = s->block_align * s->bits / 8;
silent_chunks = 32;
silent_chunks = av_log2(flags + 1);
memset(output_samples, 0, raw_block_size * silent_chunks);
output_samples += raw_block_size * silent_chunks;
*data_size += vmdaudio_loadsound(s, output_samples, p + 4, 0, buf_size - 20);
*data_size = vmdaudio_loadsound(s, output_samples, p, 1, 0);
const uint8_t *buf, int silence, int data_size)
memset(data, 0, data_size * 2);
static int vmdaudio_loadsound(VmdAudioContext *s, unsigned char *data,
memset(data, 0, data_size * 2);
0
---------------------------------
177 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 804
path->data = NULL;
path->size = 0;
path->data = NULL;
path->size = 0;
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
fidp = get_fid(pdu, fid);
err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);
err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);
V9fsPath path;
v9fs_path_init(&path);
err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);
v9fs_path_free(&path);
err = v9fs_co_lstat(pdu, &path, &stbuf);
err = v9fs_co_name_to_path(pdu, &fidp->path, dent->d_name, &path);
v9fs_path_init(&path);
static int stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,
str = strrchr(name->data, '/');
void v9fs_path_init(V9fsPath *path)
v9fs_path_init(&path);
err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
fidp = get_fid(pdu, fid);
err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);
void v9fs_path_free(V9fsPath *path)
v9fs_path_free(&path);
err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);
0
---------------------------------
178 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7175
js_FinishTakingSrcNotes(JSContext *cx, JSCodeGenerator *cg, jssrcnote *notes)
prologCount = cg->prolog.noteCount;
prologCount = cg->prolog.noteCount;
memcpy(notes, cg->prolog.notes, SRCNOTE_SIZE(prologCount));
0
---------------------------------
179 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 651
frag = NULL;
(unsigned char *)s->init_buf->data + DTLS1_HM_HEADER_LENGTH;
unsigned char *p =
memcpy(&p[frag->msg_header.frag_off], frag->fragment,
0
---------------------------------
180 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 372
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
fprintf(stderr, "%s: w was < 0 (%d)\n", name, w);
fprintf(stderr, "%s: w was > %d (%d)\n", name, SVGA_MAX_WIDTH, w);
if (x + w > surface_width(surface)) {
name, surface_width(surface), x, w);
fprintf(stderr, "%s: y was < 0 (%d)\n", name, y);
fprintf(stderr, "%s: y was > %d (%d)\n", name, SVGA_MAX_HEIGHT, y);
if (y + h > surface_height(surface)) {
name, surface_height(surface), y, h);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
x = 0;
y = 0;
w = surface_width(surface);
h = surface_height(surface);
bypl = surface_stride(surface);
width = surface_bytes_per_pixel(surface) * w;
start = surface_bytes_per_pixel(surface) * x + bypl * y;
src = s->vga.vram_ptr + start;
dst = surface_data(surface) + start;
for (line = h; line > 0; line--, src += bypl, dst += bypl) {
memcpy(dst, src, width);
qemu_default_pixman_format(s->new_depth, true);
trace_vmware_setmode(s->new_width, s->new_height, s->new_depth);
static void vmsvga_update_display(void *opaque)
vmsvga_check_size(s);
static inline void vmsvga_check_size(struct vmsvga_state_s *s)
vmsvga_check_size(s);
vmsvga_fifo_run(s);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
width = surface_bytes_per_pixel(surface) * w;
start = surface_bytes_per_pixel(surface) * x + bypl * y;
src = s->vga.vram_ptr + start;
dst = surface_data(surface) + start;
memcpy(dst, src, width);
static inline void vmsvga_update_rect(struct vmsvga_state_s *s,
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
width = surface_bytes_per_pixel(surface) * w;
start = surface_bytes_per_pixel(surface) * x + bypl * y;
src = s->vga.vram_ptr + start;
dst = surface_data(surface) + start;
memcpy(dst, src, width);
for (line = h; line > 0; line--, src += bypl, dst += bypl) {
memcpy(dst, src, width);
static inline bool vmsvga_verify_rect(DisplaySurface *surface,
bypl = surface_stride(surface);
width = surface_bytes_per_pixel(surface) * w;
for (line = h; line > 0; line--, src += bypl, dst += bypl) {
memcpy(dst, src, width);
0
---------------------------------
181 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 2368
static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,
int eticklen, const unsigned char *sess_id,
int sesslen, SSL_SESSION **psess)
int slen, mlen, renew_ticket = 0;
HMAC_CTX hctx;
EVP_CIPHER_CTX ctx;
HMAC_CTX_init(&hctx);
EVP_CIPHER_CTX_init(&ctx);
&ctx, &hctx, 0);
if (memcmp(etick, tctx->tlsext_tick_key_name, 16))
if (HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
|| EVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
etick + 16) <= 0) {
mlen = HMAC_size(&hctx);
if (eticklen <= 16 + EVP_CIPHER_CTX_iv_length(&ctx) + mlen) {
eticklen -= mlen;
if (HMAC_Update(&hctx, etick, eticklen) <= 0
if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {
p = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);
eticklen -= 16 + EVP_CIPHER_CTX_iv_length(&ctx);
sdec = OPENSSL_malloc(eticklen);
|| EVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen) <= 0) {
if (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0) {
slen += mlen;
p = sdec;
sess = d2i_SSL_SESSION(NULL, &p, slen);
memcpy(sess->session_id, sess_id, sesslen);
0
---------------------------------
182 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4122
return av_guess_format("image2", NULL, NULL);
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
const char *filename, void *logctx,
if ((ret = avio_open2(&s->pb, filename, AVIO_FLAG_READ | s->avio_flags,
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
const char *filename, void *logctx,
if (!av_filename_number_test(filename)) {
oformat = av_guess_format(format, NULL, NULL);
AVOutputFormat *oformat, const char *filename)
int ret = avformat_alloc_output_context2(&avctx, oformat, format, filename);
const char *format, const char *filename)
oformat = av_guess_format(NULL, filename, NULL);
nd = 0;
while (isdigit(*p)) {
c = *p++;
nd = nd * 10 + *p++ - '0';
snprintf(buf1, sizeof(buf1), "%0*d", nd, number);
len = strlen(buf1);
snprintf(buf1, sizeof(buf1), "%0*d", nd, number);
AVOutputFormat *av_guess_format(const char *short_name, const char *filename,
ff_guess_image2_codec(filename) != AV_CODEC_ID_NONE) {
av_filename_number_test(filename) &&
int av_filename_number_test(const char *filename)
return filename && (av_get_frame_filename(buf, sizeof(buf), filename, 1)>=0);
const char *path, int number)
p = path;
c = *p++;
nd = nd * 10 + *p++ - '0';
snprintf(buf1, sizeof(buf1), "%0*d", nd, number);
len = strlen(buf1);
snprintf(buf1, sizeof(buf1), "%0*d", nd, number);
int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
if ((ret = init_input(s, filename, &tmp)) < 0)
static int init_input(AVFormatContext *s, const char *filename, AVDictionary **options)
if (!av_filename_number_test(filename)) {
0
---------------------------------
183 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c cfunc 2429
v9fs_string_init(&stat->name);
v9fs_string_init(&stat->uid);
v9fs_string_init(&stat->gid);
v9fs_string_init(&stat->muid);
v9fs_string_init(&stat->extension);
V9fsString name;
v9fs_string_init(&name);
err = pdu_unmarshal(pdu, offset, "dds", &fid, &newdirfid, &name);
err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);
V9fsStat v9stat;
v9fs_stat_init(&v9stat);
err = pdu_unmarshal(pdu, offset, "dwS", &fid, &unused, &v9stat);
v9stat.mode, v9stat.atime, v9stat.mtime);
if (donttouch_stat(&v9stat)) {
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
int32_t newdirfid, V9fsString *name)
old_name = fidp->path.data;
end = strrchr(old_name, '/');
end++;
end = old_name;
new_name = g_malloc0(end - old_name + name->size + 1);
strncat(new_name, old_name, end - old_name);
strncat(new_name + (end - old_name), name->data, name->size);
static void v9fs_stat_init(V9fsStat *stat)
v9fs_stat_init(&v9stat);
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
int32_t newdirfid, V9fsString *name)
new_name = g_malloc0(end - old_name + name->size + 1);
strncat(new_name, old_name, end - old_name);
strncat(new_name + (end - old_name), name->data, name->size);
static int donttouch_stat(V9fsStat *stat)
if (donttouch_stat(&v9stat)) {
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
int32_t newdirfid, V9fsString *name)
new_name = g_malloc0(end - old_name + name->size + 1);
strncat(new_name, old_name, end - old_name);
strncat(new_name + (end - old_name), name->data, name->size);
0
---------------------------------
184 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4126
return av_guess_format("image2", NULL, NULL);
char buf[1024];
return filename && (av_get_frame_filename(buf, sizeof(buf), filename, 1)>=0);
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
const char *filename, void *logctx,
if ((ret = avio_open2(&s->pb, filename, AVIO_FLAG_READ | s->avio_flags,
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
const char *filename, void *logctx,
if (!av_filename_number_test(filename)) {
oformat = av_guess_format(format, NULL, NULL);
AVOutputFormat *oformat, const char *filename)
int ret = avformat_alloc_output_context2(&avctx, oformat, format, filename);
const char *format, const char *filename)
oformat = av_guess_format(NULL, filename, NULL);
char *q, buf1[20], c;
nd = 0;
while (isdigit(*p)) {
c = *p++;
nd = nd * 10 + *p++ - '0';
memcpy(q, buf1, len);
snprintf(buf1, sizeof(buf1), "%0*d", nd, number);
len = strlen(buf1);
memcpy(q, buf1, len);
int av_filename_number_test(const char *filename)
return filename && (av_get_frame_filename(buf, sizeof(buf), filename, 1)>=0);
const char *path, int number)
p = path;
c = *p++;
nd = nd * 10 + *p++ - '0';
snprintf(buf1, sizeof(buf1), "%0*d", nd, number);
len = strlen(buf1);
memcpy(q, buf1, len);
q += len;
memcpy(q, buf1, len);
*q++ = c;
memcpy(q, buf1, len);
AVOutputFormat *av_guess_format(const char *short_name, const char *filename,
ff_guess_image2_codec(filename) != AV_CODEC_ID_NONE) {
av_filename_number_test(filename) &&
int av_get_frame_filename(char *buf, int buf_size,
q = buf;
memcpy(q, buf1, len);
int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
if ((ret = init_input(s, filename, &tmp)) < 0)
static int init_input(AVFormatContext *s, const char *filename, AVDictionary **options)
if (!av_filename_number_test(filename)) {
0
---------------------------------
185 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 422
AVI_READCHUNK_ENTER;
p_chk->strf.auds.p_wf = malloc( __MAX( p_chk->common.i_chunk_size, sizeof( WAVEFORMATEX ) ) );
&& p_chk->common.i_chunk_size > sizeof( WAVEFORMATEX ) )
p_chk->common.i_chunk_size - sizeof( WAVEFORMATEX ) )
p_chk->common.i_chunk_size - sizeof( WAVEFORMATEX );
p_buff + 8 + sizeof( WAVEFORMATEX ),
if( p_chk->strf.vids.p_bih->biSize - sizeof(BITMAPINFOHEADER) > 0 )
p_buff + 8 + sizeof(BITMAPINFOHEADER),
p_chk->common.i_chunk_size -sizeof(BITMAPINFOHEADER) );
p_buff + 8 + sizeof(BITMAPINFOHEADER),
AVI_READCHUNK_EXIT( VLC_SUCCESS );
0
---------------------------------
186 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cppfunc 422
AVI_READCHUNK_ENTER;
p_chk->strf.auds.p_wf = malloc( __MAX( p_chk->common.i_chunk_size, sizeof( WAVEFORMATEX ) ) );
&& p_chk->common.i_chunk_size > sizeof( WAVEFORMATEX ) )
p_chk->common.i_chunk_size - sizeof( WAVEFORMATEX ) )
p_chk->common.i_chunk_size - sizeof( WAVEFORMATEX );
p_buff + 8 + sizeof( WAVEFORMATEX ),
if( p_chk->strf.vids.p_bih->biSize - sizeof(BITMAPINFOHEADER) > 0 )
p_buff + 8 + sizeof(BITMAPINFOHEADER),
p_chk->common.i_chunk_size -sizeof(BITMAPINFOHEADER) );
p_buff + 8 + sizeof(BITMAPINFOHEADER),
AVI_READCHUNK_EXIT( VLC_SUCCESS );
0
---------------------------------
187 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c inputfunc 303
char *argv[])
read_snmp_conf(argv[1]);
static void		read_snmp_conf(const char *address);
0
---------------------------------
188 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 222
static int Open( vlc_object_t *p_this )
char         *psz_path, *psz_uri;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
i_ret = asprintf( &psz_uri, "
free( psz_uri );
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
i_ret = asprintf( &psz_uri, "
free( psz_uri );
static void Win32AddConnection( access_t *p_access, char *psz_path,
i_ret = asprintf( &psz_uri, "
free( psz_uri );
0
---------------------------------
189 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 222
static int Open( vlc_object_t *p_this )
char         *psz_path, *psz_uri;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
i_ret = asprintf( &psz_uri, "
free( psz_uri );
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
i_ret = asprintf( &psz_uri, "
free( psz_uri );
static void Win32AddConnection( access_t *p_access, char *psz_path,
i_ret = asprintf( &psz_uri, "
free( psz_uri );
0
---------------------------------
190 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 159
const uint8_t  *p_peek;
if( stream_Peek( p_demux->s, &p_peek, 4 ) < 4 ) return VLC_EGENERIC;
if( !p_demux->b_force && memcmp( p_peek, "OggS", 4 ) )
0
---------------------------------
191 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 1752
ts_max=
ts_min= AV_NOPTS_VALUE;
e= &st->index_entries[index];
ts_min= e->timestamp;
ts_max= e->timestamp;
pos= ff_gen_search(s, stream_index, target_ts, pos_min, pos_max, pos_limit, ts_min, ts_max, flags, &ts, avif->read_timestamp);
int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret,
pos_min = s->data_offset;
ts_min = read_timestamp(s, stream_index, &pos_min, INT64_MAX);
int step= 1024;
filesize = avio_size(s->pb);
pos_max = filesize - 1;
pos_max -= step;
step += step;
ts_max = read_timestamp(s, stream_index, &pos_max, pos_max + step);
int64_t tmp_ts= read_timestamp(s, stream_index, &tmp_pos, INT64_MAX);
ts_max= tmp_ts;
ts = read_timestamp(s, stream_index, &pos, INT64_MAX);
assert(ts != AV_NOPTS_VALUE);
ts_max = ts;
ts_min = ts;
pos = av_rescale(target_ts - ts_min, pos_max - pos_min, ts_max - ts_min)
pos_min = s->data_offset;
pos_max = avio_size(s->pb) - 1;
if     (pos < pos_min) pos= pos_min;
else if(pos > pos_max) pos= pos_max;
avio_seek(s->pb, pos, SEEK_SET);
index = av_index_search_timestamp(st, timestamp, flags);
if(s->iformat->read_seek(s, stream_index, timestamp, flags) >= 0)
return seek_frame_byte(s, stream_index, timestamp, flags);
timestamp = av_rescale(timestamp, st->time_base.den, AV_TIME_BASE * (int64_t)st->time_base.num);
ret = s->iformat->read_seek(s, stream_index, timestamp, flags);
return ff_seek_frame_binary(s, stream_index, timestamp, flags);
ret = av_seek_frame(s, stream_index, ts, flags | (dir^AVSEEK_FLAG_BACKWARD));
static int seek_frame_byte(AVFormatContext *s, int stream_index, int64_t pos, int flags){
avio_seek(s->pb, pos, SEEK_SET);
ret = av_seek_frame(s, stream_index, ts, flags | (dir^AVSEEK_FLAG_BACKWARD));
int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
int ret = seek_frame_internal(s, stream_index, timestamp, flags);
int64_t timestamp, int flags)
return ff_seek_frame_binary(s, stream_index, timestamp, flags);
int ff_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags)
av_dlog(s, "read_seek: %d %s\n", stream_index, av_ts2str(target_ts));
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
wanted_timestamp, flags);
int64_t wanted_timestamp, int flags)
index= av_index_search_timestamp(st, target_ts, flags & ~AVSEEK_FLAG_BACKWARD);
assert(e->timestamp >= target_ts);
ret = av_seek_frame(s, stream_index, ts, flags | (dir^AVSEEK_FLAG_BACKWARD));
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
wanted_timestamp, flags);
int64_t wanted_timestamp, int flags)
assert(e->timestamp >= target_ts);
int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
int ret = av_seek_frame(s, stream_index, ts, flags | dir);
ret = av_seek_frame(s, stream_index, dir ? max_ts : min_ts, flags | dir);
int64_t ff_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts,
av_dlog(s, "gen_seek: %d %s\n", stream_index, av_ts2str(target_ts));
ts_min = read_timestamp(s, stream_index, &pos_min, INT64_MAX);
pos = av_rescale(target_ts - ts_min, pos_max - pos_min, ts_max - ts_min)
ret = av_seek_frame(s, stream_index, ts, flags | (dir^AVSEEK_FLAG_BACKWARD));
0
---------------------------------
192 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 1752
ts_max=
ts_min= AV_NOPTS_VALUE;
e= &st->index_entries[index];
ts_min= e->timestamp;
ts_max= e->timestamp;
pos= ff_gen_search(s, stream_index, target_ts, pos_min, pos_max, pos_limit, ts_min, ts_max, flags, &ts, avif->read_timestamp);
int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret,
pos_min = s->data_offset;
ts_min = read_timestamp(s, stream_index, &pos_min, INT64_MAX);
int step= 1024;
filesize = avio_size(s->pb);
pos_max = filesize - 1;
pos_max -= step;
step += step;
ts_max = read_timestamp(s, stream_index, &pos_max, pos_max + step);
int64_t tmp_ts= read_timestamp(s, stream_index, &tmp_pos, INT64_MAX);
ts_max= tmp_ts;
ts = read_timestamp(s, stream_index, &pos, INT64_MAX);
assert(ts != AV_NOPTS_VALUE);
ts_max = ts;
ts_min = ts;
pos = av_rescale(target_ts - ts_min, pos_max - pos_min, ts_max - ts_min)
pos_min = s->data_offset;
pos_max = avio_size(s->pb) - 1;
if     (pos < pos_min) pos= pos_min;
else if(pos > pos_max) pos= pos_max;
avio_seek(s->pb, pos, SEEK_SET);
index = av_index_search_timestamp(st, timestamp, flags);
if(s->iformat->read_seek(s, stream_index, timestamp, flags) >= 0)
return seek_frame_byte(s, stream_index, timestamp, flags);
timestamp = av_rescale(timestamp, st->time_base.den, AV_TIME_BASE * (int64_t)st->time_base.num);
ret = s->iformat->read_seek(s, stream_index, timestamp, flags);
return ff_seek_frame_binary(s, stream_index, timestamp, flags);
ret = av_seek_frame(s, stream_index, ts, flags | (dir^AVSEEK_FLAG_BACKWARD));
static int seek_frame_byte(AVFormatContext *s, int stream_index, int64_t pos, int flags){
avio_seek(s->pb, pos, SEEK_SET);
ret = av_seek_frame(s, stream_index, ts, flags | (dir^AVSEEK_FLAG_BACKWARD));
int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
int ret = seek_frame_internal(s, stream_index, timestamp, flags);
int64_t timestamp, int flags)
return ff_seek_frame_binary(s, stream_index, timestamp, flags);
int ff_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags)
av_dlog(s, "read_seek: %d %s\n", stream_index, av_ts2str(target_ts));
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
wanted_timestamp, flags);
int64_t wanted_timestamp, int flags)
index= av_index_search_timestamp(st, target_ts, flags & ~AVSEEK_FLAG_BACKWARD);
assert(e->timestamp >= target_ts);
ret = av_seek_frame(s, stream_index, ts, flags | (dir^AVSEEK_FLAG_BACKWARD));
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
wanted_timestamp, flags);
int64_t wanted_timestamp, int flags)
assert(e->timestamp >= target_ts);
int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
int ret = av_seek_frame(s, stream_index, ts, flags | dir);
ret = av_seek_frame(s, stream_index, dir ? max_ts : min_ts, flags | dir);
int64_t ff_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts,
av_dlog(s, "gen_seek: %d %s\n", stream_index, av_ts2str(target_ts));
ts_min = read_timestamp(s, stream_index, &pos_min, INT64_MAX);
pos = av_rescale(target_ts - ts_min, pos_max - pos_min, ts_max - ts_min)
ret = av_seek_frame(s, stream_index, ts, flags | (dir^AVSEEK_FLAG_BACKWARD));
0
---------------------------------
193 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 774
p_child = p_chk->common.p_first;
p_next = p_child->common.p_next;
p_child = p_next;
free( p_child );
0
---------------------------------
194 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cppfunc 774
p_child = p_chk->common.p_first;
p_next = p_child->common.p_next;
p_child = p_next;
free( p_child );
0
---------------------------------
195 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c cfunc 463
path->data = NULL;
path->size = 0;
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
fidp = get_fid(pdu, fid);
err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);
V9fsPath path;
v9fs_path_init(&path);
err = v9fs_co_name_to_path(pdu, &dfidp->path, name.data, &path);
err = v9fs_mark_fids_unreclaim(pdu, &path);
static int v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
if (!memcmp(fidp->path.data, path->data, path->size)) {
void v9fs_path_init(V9fsPath *path)
v9fs_path_init(&path);
err = v9fs_mark_fids_unreclaim(pdu, &path);
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
fidp = get_fid(pdu, fid);
err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);
0
---------------------------------
196 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1475
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->id);
0
---------------------------------
197 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1475
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->id);
0
---------------------------------
198 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 273
RawReader(png_structp png_ptr, png_bytep data, png_size_t length)
RawReadState *state = (RawReadState *)png_get_io_ptr(png_ptr);
memcpy(data, state->start + state->offset, length);
0
---------------------------------
199 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1472
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->uri);
0
---------------------------------
200 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1472
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->uri);
0
---------------------------------
201 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 1072
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
printf("%s: Bad register %02x\n", __func__, s->index);
struct vmsvga_state_s *s = opaque;
vmsvga_value_write(s, addr, data);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
printf("%s: Bad register %02x\n", __func__, s->index);
static void vmsvga_io_write(void *opaque, hwaddr addr,
vmsvga_value_write(s, addr, data);
0
---------------------------------
202 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 1305
process_rtsp_request(tvbuff_t *tvb, int offset, const guchar *data,
(len == linelen || isspace(data[len])))
g_ascii_strncasecmp(rtsp_methods[ii], data, len) == 0 &&
url = data;
while (url < lineend && !isspace(*url))
url++;
while (url < lineend && isspace(*url))
url++;
while (url < lineend && isspace(*url))
0
---------------------------------
203 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 1305
process_rtsp_request(tvbuff_t *tvb, int offset, const guchar *data,
(len == linelen || isspace(data[len])))
g_ascii_strncasecmp(rtsp_methods[ii], data, len) == 0 &&
url = data;
while (url < lineend && !isspace(*url))
url++;
while (url < lineend && isspace(*url))
url++;
while (url < lineend && isspace(*url))
0
---------------------------------
204 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 525
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
*ppsz_encoded = malloc( i_len + 1 );
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
const char *psz_zippath )
char *psz_zip = strrchr( psz_zippath, DIR_SEP_CHAR );
char *psz_pathtozip;
escapeToXml( &psz_pathtozip, psz_zippath );
char *psz_escapedName;
escapeToXml( &psz_escapedName, psz_name );
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
static int WriteXSPF( char **pp_buffer, vlc_array_t *p_filenames,
for( int i = 0; i < vlc_array_count( p_filenames ); ++i )
char *psz_name = (char*) vlc_array_item_at_index( p_filenames, i );
int i_len = strlen( psz_name );
char *psz_file = strrchr( psz_name, '/' );
escapeToXml( &psz_escapedName, psz_name );
0
---------------------------------
205 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 1302
process_rtsp_request(tvbuff_t *tvb, int offset, const guchar *data,
g_ascii_strncasecmp(rtsp_methods[ii], data, len) == 0 &&
(len == linelen || isspace(data[len])))
url = data;
while (url < lineend && !isspace(*url))
url++;
while (url < lineend && !isspace(*url))
0
---------------------------------
206 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 1302
process_rtsp_request(tvbuff_t *tvb, int offset, const guchar *data,
g_ascii_strncasecmp(rtsp_methods[ii], data, len) == 0 &&
(len == linelen || isspace(data[len])))
url = data;
while (url < lineend && !isspace(*url))
url++;
while (url < lineend && !isspace(*url))
0
---------------------------------
207 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 418
static void		debug_printf(const char *format, ...);
const char  *addrname,
const char  *uri,
const char  *id,
const char  *make_and_model)
addr, addrname, uri ? uri : "(null)", id ? id : "(null)",
make_and_model ? make_and_model : "(null)");
memcpy(&(temp->address), addr, sizeof(temp->address));
add_cache(http_addr_t *addr,
addr, addrname, uri ? uri : "(null)", id ? id : "(null)",
0
---------------------------------
208 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 154
path->data = NULL;
path->size = 0;
memcpy(lhs->data, rhs->data, rhs->size);
lhs->size = rhs->size;
if (!strncmp(s1->data, s2->data, s1->size - 1)) {
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
dst->size++;
V9fsPath dpath, path;
fidp = get_fid(pdu, fid);
v9fs_path_init(&path);
v9fs_path_copy(&dpath, &fidp->path);
v9fs_path_copy(&path, &fidp->path);
v9fs_path_init(&path);
v9fs_path_copy(&dpath, &fidp->path);
err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data, &path);
err = v9fs_co_lstat(pdu, &path, &stbuf);
v9fs_path_copy(&dpath, &path);
v9fs_path_copy(&fidp->path, &path);
v9fs_path_copy(&newfidp->path, &path);
V9fsPath path;
v9fs_path_init(&path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
void v9fs_path_copy(V9fsPath *lhs, V9fsPath *rhs)
v9fs_path_free(lhs);
lhs->data = g_malloc(rhs->size);
memcpy(lhs->data, rhs->data, rhs->size);
v9fs_path_copy(&str, dst);
v9fs_path_copy(&path, &fidp->path);
v9fs_path_copy(&newfidp->path, &path);
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
static int v9fs_path_is_ancestor(V9fsPath *s1, V9fsPath *s2)
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &newpath, strlen(oldpath.data));
static void v9fs_fix_path(V9fsPath *dst, V9fsPath *src, int len)
v9fs_path_copy(&str, dst);
void v9fs_path_init(V9fsPath *path)
v9fs_path_init(&path);
v9fs_path_copy(&newfidp->path, &path);
v9fs_path_init(&path);
v9fs_path_copy(&fidp->path, &path);
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
fidp = get_fid(pdu, fid);
v9fs_path_copy(&dpath, &fidp->path);
0
---------------------------------
209 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 979
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
printf("%s: Bad width: %i\n", __func__, value);
uint64_t data, unsigned size)
vmsvga_value_write(s, addr, data);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
printf("%s: Bad width: %i\n", __func__, value);
0
---------------------------------
210 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 603
void NetworkUtils::setAccessPoint(CommandChain* aChain,
nsCString ssid(GET_CHAR(mSsid));
nsCString key(GET_CHAR(mKey));
escapeQuote(key);
aString.ReplaceSubstring("\\", "\\\\");
}
key.get());
0
---------------------------------
211 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 2429
v9fs_string_init(&stat->name);
v9fs_string_init(&stat->uid);
v9fs_string_init(&stat->gid);
v9fs_string_init(&stat->muid);
v9fs_string_init(&stat->extension);
V9fsString name;
v9fs_string_init(&name);
err = pdu_unmarshal(pdu, offset, "dds", &fid, &newdirfid, &name);
err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);
V9fsStat v9stat;
v9fs_stat_init(&v9stat);
err = pdu_unmarshal(pdu, offset, "dwS", &fid, &unused, &v9stat);
v9stat.mode, v9stat.atime, v9stat.mtime);
if (donttouch_stat(&v9stat)) {
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
int32_t newdirfid, V9fsString *name)
old_name = fidp->path.data;
end = strrchr(old_name, '/');
end++;
end = old_name;
new_name = g_malloc0(end - old_name + name->size + 1);
strncat(new_name, old_name, end - old_name);
strncat(new_name + (end - old_name), name->data, name->size);
static void v9fs_stat_init(V9fsStat *stat)
v9fs_stat_init(&v9stat);
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
int32_t newdirfid, V9fsString *name)
new_name = g_malloc0(end - old_name + name->size + 1);
strncat(new_name, old_name, end - old_name);
strncat(new_name + (end - old_name), name->data, name->size);
static int donttouch_stat(V9fsStat *stat)
if (donttouch_stat(&v9stat)) {
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
int32_t newdirfid, V9fsString *name)
new_name = g_malloc0(end - old_name + name->size + 1);
strncat(new_name, old_name, end - old_name);
strncat(new_name + (end - old_name), name->data, name->size);
0
---------------------------------
212 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4417
int ff_url_join(char *str, int size, const char *proto,
int port, const char *fmt, ...)
str[0] = '\0';
av_strlcatf(str, size, "%s:
av_strlcatf(str, size, "%s@", authorization);
av_strlcat(str, "[", size);
av_strlcat(str, hostname, size);
av_strlcat(str, "]", size);
av_strlcat(str, hostname, size);
av_strlcat(str, hostname, size);
av_strlcatf(str, size, ":%d", port);
int len = strlen(str);
va_start(vl, fmt);
vsnprintf(str + len, size > len ? size - len : 0, fmt, vl);
0
---------------------------------
213 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4559
void ff_make_absolute_url(char *buf, int size, const char *base,
av_strlcpy(buf, base, size);
path_query = strchr(buf, '?');
sep = strrchr(buf, '/');
buf[0] = '\0';
sep = strrchr(buf, '/');
if (!strcmp(sep ? &sep[1] : buf, "..")) {
av_strlcat(buf, "/", size);
sep = strrchr(buf, '/');
if (!strcmp(sep ? &sep[1] : buf, "..")) {
buf[0] = '\0';
sep = strrchr(buf, '/');
if (!strcmp(sep ? &sep[1] : buf, "..")) {
0
---------------------------------
214 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 206
buf = (unsigned char *)OPENSSL_malloc(frag_len);
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
unsigned long frag_len = msg_hdr->frag_len;
frag = dtls1_hm_fragment_new(frag_len, 0);
unsigned char wire[DTLS1_HM_HEADER_LENGTH];
struct hm_header_st msg_hdr;
i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, wire,
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_reassemble_fragment(s, &msg_hdr, ok);
s->d1->handshake_write_seq = s->d1->next_handshake_write_seq;
s->d1->next_handshake_write_seq++;
s2n(s->d1->handshake_write_seq, p);
dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
s->d1->handshake_write_seq, 0, 0);
unsigned short seq_num,
dtls1_buffer_message(s, 1);
n2l3(data, msg_hdr->msg_len);
n2s(data, msg_hdr->seq);
n2l3(data, msg_hdr->frag_off);
n2l3(data, msg_hdr->frag_len);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr,
return dtls1_reassemble_fragment(s, msg_hdr, ok);
dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr, int *ok)
frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len,
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
static void dtls1_set_message_header_int(SSL *s, unsigned char mt,
dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
dtls1_buffer_message(s, 1);
int dtls1_buffer_message(SSL *s, int is_ccs)
frag = dtls1_hm_fragment_new(s->init_num, 0);
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
msg_hdr->type = *(data++);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_reassemble_fragment(s, &msg_hdr, ok);
0
---------------------------------
215 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 505
const char *filename, void *logctx,
if ((ret = avio_open2(&s->pb, filename, AVIO_FLAG_READ | s->avio_flags,
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
unsigned int offset, unsigned int max_probe_size)
AVProbeData pd = { filename ? filename : "", NULL, -offset };
memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
unsigned int offset, unsigned int max_probe_size)
AVProbeData pd = { filename ? filename : "", NULL, -offset };
max_probe_size = PROBE_BUF_MAX;
max_probe_size = PROBE_BUF_MAX;
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;
if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {
av_log(logctx, AV_LOG_DEBUG, "Format %s probed with size=%d and score=%d\n", (*fmt)->name, probe_size, score);
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {
buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);
memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);
int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
if ((ret = init_input(s, filename, &tmp)) < 0)
static int init_input(AVFormatContext *s, const char *filename, AVDictionary **options)
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
const char *filename, void *logctx,
AVProbeData pd = { filename ? filename : "", NULL, -offset };
memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);
0
---------------------------------
216 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4418
va_list vl;
va_start(vl, fmt);
vsnprintf(str + len, size > len ? size - len : 0, fmt, vl);
va_end(vl);
0
---------------------------------
217 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4418
va_list vl;
va_start(vl, fmt);
vsnprintf(str + len, size > len ? size - len : 0, fmt, vl);
va_end(vl);
0
---------------------------------
218 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 847
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(0, ret);
int el;
if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(0, ret);
s2n(TLSEXT_TYPE_status_request, ret);
s2n(0, ret);
size_t sol = s->s3->server_opaque_prf_input_len;
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(sol + 2, ret);
s2n(sol, ret);
memcpy(ret, s->s3->server_opaque_prf_input, sol);
ret += sol;
int el;
ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);
s2n(TLSEXT_TYPE_use_srtp, ret);
s2n(el, ret);
if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {
ret += el;
const unsigned char cryptopro_ext[36] = {
memcpy(ret, cryptopro_ext, 36);
0
---------------------------------
219 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 485
if ((device_uri = calloc(1, sizeof(device_uri_t))) == NULL)
if ((device_uri->uris = cupsArrayNew(NULL, NULL)) == NULL)
cupsArrayDelete(device_uri->uris);
free(device_uri);
0
---------------------------------
220 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 485
if ((device_uri = calloc(1, sizeof(device_uri_t))) == NULL)
if ((device_uri->uris = cupsArrayNew(NULL, NULL)) == NULL)
cupsArrayDelete(device_uri->uris);
free(device_uri);
0
---------------------------------
221 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1713
char		uri[1024],
if (!try_connect(&(device->address), device->addrname, 5353))
snprintf(uri, sizeof(uri), "socket:
static int		try_connect(http_addr_t *addr, const char *addrname,
if (!try_connect(&(device->address), device->addrname, 9100))
static int		try_connect(http_addr_t *addr, const char *addrname,
debug_printf("DEBUG: %s supports AppSocket!\n", device->addrname);
static void		debug_printf(const char *format, ...);
snprintf(uri, sizeof(uri), "socket:
update_cache(device, uri, NULL, NULL);
const char   *uri,
device->uri = strdup(uri);
snprintf(uri, sizeof(uri), "socket:
0
---------------------------------
222 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c cfunc 154
path->data = NULL;
path->size = 0;
memcpy(lhs->data, rhs->data, rhs->size);
lhs->size = rhs->size;
if (!strncmp(s1->data, s2->data, s1->size - 1)) {
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
dst->size++;
V9fsPath dpath, path;
fidp = get_fid(pdu, fid);
v9fs_path_copy(&dpath, &fidp->path);
v9fs_path_copy(&path, &fidp->path);
v9fs_path_init(&path);
v9fs_path_copy(&dpath, &fidp->path);
err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data, &path);
err = v9fs_co_lstat(pdu, &path, &stbuf);
v9fs_path_copy(&dpath, &path);
v9fs_path_copy(&fidp->path, &path);
v9fs_path_copy(&newfidp->path, &path);
V9fsPath path;
v9fs_path_init(&path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
err = v9fs_co_name_to_path(pdu, &fidp->path, name.data, &path);
v9fs_path_copy(&fidp->path, &path);
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
file_fidp = get_fid(pdu, fid);
v9fs_path_copy(&xattr_fidp->path, &file_fidp->path);
void v9fs_path_copy(V9fsPath *lhs, V9fsPath *rhs)
v9fs_path_free(lhs);
lhs->data = g_malloc(rhs->size);
memcpy(lhs->data, rhs->data, rhs->size);
v9fs_path_copy(&str, dst);
v9fs_path_copy(&path, &fidp->path);
v9fs_path_copy(&newfidp->path, &path);
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
static int v9fs_path_is_ancestor(V9fsPath *s1, V9fsPath *s2)
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &newpath, strlen(oldpath.data));
static void v9fs_fix_path(V9fsPath *dst, V9fsPath *src, int len)
v9fs_path_copy(&str, dst);
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
file_fidp = get_fid(pdu, fid);
v9fs_path_copy(&xattr_fidp->path, &file_fidp->path);
void v9fs_path_init(V9fsPath *path)
v9fs_path_init(&path);
v9fs_path_copy(&newfidp->path, &path);
v9fs_path_init(&path);
v9fs_path_copy(&fidp->path, &path);
0
---------------------------------
223 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 701
HKEY baseKey;
KEY_READ, &baseKey);
BOOL success = GetDWORDValue(baseKey, L"EnableLUA", enabled);
GetDWORDValue(HKEY key, LPCWSTR valueName, DWORD &retValue)
LONG retCode = RegQueryValueExW(key, valueName, 0, NULL,
GetDWORDValue(baseKey, L"ConsentPromptBehaviorAdmin", consent);
GetDWORDValue(baseKey, L"PromptOnSecureDesktop", secureDesktop);
RegCloseKey(baseKey);
GetDWORDValue(HKEY key, LPCWSTR valueName, DWORD &retValue)
LONG retCode = RegQueryValueExW(key, valueName, 0, NULL,
GetDWORDValue(baseKey, L"PromptOnSecureDesktop", secureDesktop);
GetDWORDValue(HKEY key, LPCWSTR valueName, DWORD &retValue)
LONG retCode = RegQueryValueExW(key, valueName, 0, NULL,
RegCloseKey(baseKey);
0
---------------------------------
224 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 354
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
0
---------------------------------
225 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 1927
static void v9fs_init_qiov_from_pdu(QEMUIOVector *qiov, V9fsPDU *pdu,
qemu_iovec_init(qiov, niov);
qemu_iovec_concat(qiov, &elem, skip, size);
xattr_len = fidp->fs.xattr.len;
write_count = xattr_len - off;
err = pdu_marshal(pdu, offset, "d", write_count);
to_copy = write_count;
memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);
off += to_copy;
memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);
write_count -= to_copy;
to_copy = write_count;
memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);
off += to_copy;
memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);
uint64_t off;
uint32_t count;
QEMUIOVector qiov_full;
err = pdu_unmarshal(pdu, offset, "dqd", &fid, &off, &count);
v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);
size_t skip, size_t size,
qemu_iovec_concat(qiov, &elem, skip, size);
trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);
err = v9fs_xattr_write(s, pdu, fidp, off, count,
uint64_t off, uint32_t count,
write_count = xattr_len - off;
write_count = count;
err = pdu_marshal(pdu, offset, "d", write_count);
to_copy = write_count;
memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);
off += to_copy;
memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);
qiov_full.iov, qiov_full.niov);
struct iovec *sg, int cnt)
to_copy = sg[i].iov_len;
memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);
off += to_copy;
memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);
0
---------------------------------
226 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 1000
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
sdbase = cg->spanDeps;
sdlimit = sdbase + cg->numSpanDeps;
growth = 0;
delta = 0;
JS_ASSERT(JT_HAS_TAG(sd->target));
sdtop = sd;
top = sd->top;
JS_ASSERT(top == sd->before);
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
sd2->offset += delta;
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
ptrdiff_t deltaFromTop = 0;
sd2->offset += deltaFromTop;
deltaFromTop += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd2->offset += deltaFromTop;
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
growth += delta;
passes, offset + growth, offset, growth);
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
JS_ASSERT(sd == sdlimit);
oldpc = base + sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
oldpc + 1 + JUMP_OFFSET_LEN,
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd->offset += delta;
span = SD_SPAN(sd, pivot);
for (sd = sdbase; sd < sdlimit; sd++) {
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
JS_ASSERT(sd == sdlimit);
oldpc = base + sd->before;
span = SD_SPAN(sd, pivot);
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
offset = sd->before + 1;
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
oldpc + 1 + JUMP_OFFSET_LEN,
OptimizeSpanDeps(JSContext *cx, JSCodeGenerator *cg)
base = CG_BASE(cg);
size = BYTECODE_SIZE(PTRDIFF(limit, base, jsbytecode));
oldpc = base + sd->before;
oldpc + 1 + JUMP_OFFSET_LEN,
0
---------------------------------
227 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 1001
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
base = CG_BASE(cg);
sdbase = cg->spanDeps;
sdlimit = sdbase + cg->numSpanDeps;
growth = 0;
delta = 0;
JS_ASSERT(JT_HAS_TAG(sd->target));
sdtop = sd;
top = sd->top;
JS_ASSERT(top == sd->before);
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
ptrdiff_t deltaFromTop = 0;
sd2->offset += deltaFromTop;
deltaFromTop += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd2->offset += deltaFromTop;
sd2->offset += delta;
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
growth += delta;
passes, offset + growth, offset, growth);
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
size = BYTECODE_SIZE(PTRDIFF(limit, base, jsbytecode));
incr = BYTECODE_SIZE(length) - size;
JS_ASSERT(sd == sdlimit);
oldpc = base + sd->before;
span = SD_SPAN(sd, pivot);
SET_JUMP_OFFSET(oldpc, span);
delta = offset - sd->before;
oldpc + 1 + JUMP_OFFSET_LEN,
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
size = BYTECODE_SIZE(delta - (1 + JUMP_OFFSET_LEN));
size);
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd->offset += delta;
span = SD_SPAN(sd, pivot);
for (sd = sdbase; sd < sdlimit; sd++) {
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
JS_ASSERT(sd == sdlimit);
span = SD_SPAN(sd, pivot);
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
offset = sd->before + 1;
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
size = BYTECODE_SIZE(delta - (1 + JUMP_OFFSET_LEN));
size);
OptimizeSpanDeps(JSContext *cx, JSCodeGenerator *cg)
base = CG_BASE(cg);
offset = CG_OFFSET(cg);
passes, offset + growth, offset, growth);
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
size = BYTECODE_SIZE(delta - (1 + JUMP_OFFSET_LEN));
size);
0
---------------------------------
228 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 609
void NetworkUtils::setAccessPoint(CommandChain* aChain,
nsCString ssid(GET_CHAR(mSsid));
nsCString key(GET_CHAR(mKey));
escapeQuote(key);
aString.ReplaceSubstring("\\", "\\\\");
}
key.get());
0
---------------------------------
229 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 364
int tls12_get_req_sig_algs(SSL *s, unsigned char *p)
size_t slen = sizeof(tls12_sigalgs);
memcpy(p, tls12_sigalgs, slen);
0
---------------------------------
230 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 154
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
free( psz_tmp );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
"  <track>\n"
" </trackList>\n"
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  <vlc:node title=\"%s\">\n", n->name ) < 0 )
if( astrcatf( pp_buffer, "   <vlc:item tid=\"%d\" />\n", i->id ) < 0 )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
free( psz_tmp );
0
---------------------------------
231 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 154
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
free( psz_tmp );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
"  <track>\n"
" </trackList>\n"
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  <vlc:node title=\"%s\">\n", n->name ) < 0 )
if( astrcatf( pp_buffer, "   <vlc:item tid=\"%d\" />\n", i->id ) < 0 )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
free( psz_tmp );
0
---------------------------------
232 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 150
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
i_num++;
*ppsz_encoded = malloc( i_len + 1 );
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
char *psz_ret = malloc( i_len + 3*i_num + 2 );
*ppsz_encoded = psz_ret;
psz_zip = convert_xml_special_chars( psz_zip ? (psz_zip+1) : psz_zippath );
" <trackList>\n", psz_zip ) == -1)
char *psz_pathtozip;
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
if( astrcatf( pp_buffer,
"  <track>\n"
if( astrcatf( pp_buffer,
" </trackList>\n"
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  <vlc:node title=\"%s\">\n", n->name ) < 0 )
nodeToXSPF( pp_buffer, n->child, false );
if( astrcatf( pp_buffer, "   <vlc:item tid=\"%d\" />\n", i->id ) < 0 )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
if( astrcatf( pp_buffer,
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
char *psz_out = realloc( *ppsz_dest, i_len );
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root );
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
static int WriteXSPF( char **pp_buffer, vlc_array_t *p_filenames,
if( asprintf( pp_buffer, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
if( astrcatf( pp_buffer,
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
0
---------------------------------
233 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 150
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
i_num++;
*ppsz_encoded = malloc( i_len + 1 );
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
char *psz_ret = malloc( i_len + 3*i_num + 2 );
*ppsz_encoded = psz_ret;
psz_zip = convert_xml_special_chars( psz_zip ? (psz_zip+1) : psz_zippath );
" <trackList>\n", psz_zip ) == -1)
char *psz_pathtozip;
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
if( astrcatf( pp_buffer,
"  <track>\n"
if( astrcatf( pp_buffer,
" </trackList>\n"
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  <vlc:node title=\"%s\">\n", n->name ) < 0 )
nodeToXSPF( pp_buffer, n->child, false );
if( astrcatf( pp_buffer, "   <vlc:item tid=\"%d\" />\n", i->id ) < 0 )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
if( astrcatf( pp_buffer,
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root );
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
static int WriteXSPF( char **pp_buffer, vlc_array_t *p_filenames,
if( asprintf( pp_buffer, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
if( astrcatf( pp_buffer,
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
0
---------------------------------
234 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 153
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
i_num++;
*ppsz_encoded = malloc( i_len + 1 );
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
char *psz_ret = malloc( i_len + 3*i_num + 2 );
*ppsz_encoded = psz_ret;
psz_zip = convert_xml_special_chars( psz_zip ? (psz_zip+1) : psz_zippath );
" <trackList>\n", psz_zip ) == -1)
char *psz_pathtozip;
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
if( astrcatf( &psz_path, "%s", psz_escapedName ) < 0 ) return -1;
if( astrcatf( pp_buffer,
"  <track>\n"
if( astrcatf( pp_buffer,
" </trackList>\n"
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
if( astrcatf( pp_buffer, "  <vlc:node title=\"%s\">\n", n->name ) < 0 )
nodeToXSPF( pp_buffer, n->child, false );
if( astrcatf( pp_buffer, "   <vlc:item tid=\"%d\" />\n", i->id ) < 0 )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
static int WriteXSPF( char **pp_buffer, vlc_array_t *p_filenames,
if( asprintf( pp_buffer, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
if( astrcatf( pp_buffer,
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root )
if( astrcatf( pp_buffer, "  </vlc:node>\n" ) < 0 )
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root );
if( astrcatf( pp_buffer, " </extension>\n</playlist>\n" ) < 0 ) return -1;
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
0
---------------------------------
235 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 2105
V9fsString extension;
v9fs_string_init(&extension);
&perm, &mode, &extension);
char ctype;
uint32_t major, minor;
if (sscanf(extension.data, "%c %u %u", &ctype, &major, &minor) != 3) {
0
---------------------------------
236 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 550
void *data, int *data_size,
unsigned char *output_samples = (unsigned char *)data;
memset(output_samples, 0, raw_block_size * silent_chunks);
0
---------------------------------
237 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1780
char		filename[1024],
if ((cups_serverroot = getenv("CUPS_SERVERROOT")) == NULL)
cups_serverroot = CUPS_SERVERROOT;
snprintf(filename, sizeof(filename), "%s/snmp.conf", cups_serverroot);
if ((fp = cupsFileOpen(filename, "r")) != NULL)
filename);
0
---------------------------------
238 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1246
char buf[400];
PR_snprintf(buf, sizeof(buf),
printf("%s\n", buf);
0
---------------------------------
239 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 734
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
int           indent)
fprintf(stderr, "DEBUG: %*sBOOLEAN %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sOID %d bytes ", indent, "",
fprintf(stderr, ".%d", oid[i]);
putc('\n', stderr);
fprintf(stderr, "DEBUG: %*sOCTET STRING %d bytes \"%s\"\n", indent, "",
0
---------------------------------
240 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1789
*value;
while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
DebugLevel = atoi(value);
add_device_uri(value);
!strcasecmp(value, "double");
!strcasecmp(value, "true") ||
!strcasecmp(value, "yes") ||
HostNameLookups = !strcasecmp(value, "on") ||
DebugLevel = atoi(value);
static device_uri_t	*add_device_uri(char *value);
DebugLevel = atoi(value);
0
---------------------------------
241 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1789
*value;
while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
add_device_uri(value);
!strcasecmp(value, "double");
!strcasecmp(value, "true") ||
!strcasecmp(value, "yes") ||
HostNameLookups = !strcasecmp(value, "on") ||
DebugLevel = atoi(value);
static device_uri_t	*add_device_uri(char *value);
DebugLevel = atoi(value);
0
---------------------------------
242 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 351
static void getIFProperties(const char* ifname, IFProperties& prop)
char key[PROPERTY_KEY_MAX];
snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.gw", ifname);
property_get(key, prop.gateway, "");
snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.dns1", ifname);
property_get(key, prop.dns1, "");
snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.dns2", ifname);
0
---------------------------------
243 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 601
void NetworkUtils::setAccessPoint(CommandChain* aChain,
nsCString ssid(GET_CHAR(mSsid));
escapeQuote(ssid);
aString.ReplaceSubstring("\\", "\\\\");
}
ssid.get(),
0
---------------------------------
244 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 359
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
void* IBsibling = Properties().Get(IBSplitSpecialSibling());
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
0
---------------------------------
245 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 607
void NetworkUtils::setAccessPoint(CommandChain* aChain,
nsCString ssid(GET_CHAR(mSsid));
escapeQuote(ssid);
aString.ReplaceSubstring("\\", "\\\\");
}
ssid.get(),
0
---------------------------------
246 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp cfunc 1254
int backsteps = 0;
const int maxBackStep = 10;
NS_ASSERTION(static_cast<PRUint64>(PAGE_STEP) * pow(2.0, maxBackStep) < PR_INT32_MAX,
backsteps = NS_MIN(backsteps + 1, maxBackStep);
backsteps = 0;
static_cast<PRInt32>(PAGE_STEP * pow(2.0, backsteps)), backsteps));
guess -= PAGE_STEP * static_cast<ogg_int64_t>(pow(2.0, backsteps));
0
---------------------------------
247 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp cppfunc 1254
int backsteps = 0;
const int maxBackStep = 10;
NS_ASSERTION(static_cast<PRUint64>(PAGE_STEP) * pow(2.0, maxBackStep) < PR_INT32_MAX,
backsteps = NS_MIN(backsteps + 1, maxBackStep);
backsteps = 0;
static_cast<PRInt32>(PAGE_STEP * pow(2.0, backsteps)), backsteps));
guess -= PAGE_STEP * static_cast<ogg_int64_t>(pow(2.0, backsteps));
0
---------------------------------
248 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 730
value_length = asn1_get_length(&buffer, bufend);
integer = asn1_get_integer(&buffer, bufend, value_length);
int length);
value_length, integer);
0
---------------------------------
249 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 351
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
0
---------------------------------
250 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4171
PRINT("%08x ", i);
PRINT(" ");
PRINT("\n");
hex_dump_internal(avcl, NULL, level, buf, size);
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
PRINT("N/A");
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
PRINT("  pts=");
PRINT("N/A");
PRINT("%0.3f", pkt->pts * av_q2d(time_base));
PRINT("\n");
PRINT("  size=%d\n", pkt->size);
av_hex_dump(f, pkt->data, pkt->size);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("stream #%d:\n", pkt->stream_index);
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
PRINT("  dts=");
av_hex_dump(f, pkt->data, pkt->size);
void av_hex_dump(FILE *f, uint8_t *buf, int size)
hex_dump_internal(NULL, f, 0, buf, size);
static void hex_dump_internal(void *avcl, FILE *f, int level, uint8_t *buf, int size)
PRINT("\n");
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
0
---------------------------------
251 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 3164
js_ReportOutOfScriptQuota(cx);
JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING,
OBJ_SET_BLOCK_DEPTH(cx, blockObj, cg->stackDepth);
ndefs = OBJ_BLOCK_COUNT(cx, blockObj);
ptrdiff_t offset = EmitCheck(cx, cg, op, 1);
UpdateDepth(cx, cg, offset);
UpdateDepth(cx, cg, offset);
if (js_LookupLocal(cx, cg->fun, atom, NULL) != JSLOCAL_NONE)
ok = OBJ_LOOKUP_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &objbox,
ok = OBJ_GET_ATTRIBUTES(cx, obj, ATOM_TO_JSID(atom), prop,
ok = OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
OBJ_DROP_PROPERTY(cx, objbox, prop);
if (js_Emit1(cx, cg, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
js_ReportCompileErrorNumber(cx, CG_TS(cg), NULL,
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
jsint depth = AdjustBlockSlot(cx, cg, OBJ_BLOCK_DEPTH(cx, blockObj));
limit = slot + OBJ_BLOCK_COUNT(cx, blockObj);
js_ReallocSlots(cx, blockObj, JSSLOT_FREE(&js_BlockClass), JS_TRUE);
count = OBJ_BLOCK_COUNT(cx, pn2->pn_objbox->object);
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
jsbitmap intmap_space[INTMAP_LENGTH];
atom = js_AtomizeDouble(cx, d);
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
intmap = intmap_space;
* sizeof(jsbitmap));
(JS_BIT(16) >> JS_BITS_PER_WORD_LOG2)
intmap_bitlen = INTMAP_LENGTH << JS_BITS_PER_WORD_LOG2;
intmap_bitlen = JS_BIT(16);
(JS_BIT(16) >> JS_BITS_PER_WORD_LOG2)
* sizeof(jsbitmap));
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
AdjustBlockSlot(JSContext *cx, JSCodeGenerator *cg, jsint slot)
jsint depth = AdjustBlockSlot(cx, cg, OBJ_BLOCK_DEPTH(cx, blockObj));
EmitEnterBlock(JSContext *cx, JSParseNode *pn, JSCodeGenerator *cg)
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
EmitSwitch(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn,
if (!js_EmitTree(cx, cg, pn->pn_left))
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
js_Emit1(JSContext *cx, JSCodeGenerator *cg, JSOp op)
ptrdiff_t offset = EmitCheck(cx, cg, op, 1);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
EmitCheck(JSContext *cx, JSCodeGenerator *cg, JSOp op, ptrdiff_t delta)
ptrdiff_t offset = EmitCheck(cx, cg, op, 1);
ptrdiff_t offset = EmitCheck(cx, cg, op, 2);
if (js_Emit1(cx, cg, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
EmitObjectOp(JSContext *cx, JSObjectBox *objbox, JSOp op,
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
EmitIndexOp(JSContext *cx, JSOp op, uintN index, JSCodeGenerator *cg)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
EmitBigIndexPrefix(JSContext *cx, JSCodeGenerator *cg, uintN index)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
UpdateDepth(JSContext *cx, JSCodeGenerator *cg, ptrdiff_t target)
UpdateDepth(cx, cg, offset);
UpdateDepth(cx, cg, offset);
js_Emit2(JSContext *cx, JSCodeGenerator *cg, JSOp op, jsbytecode op1)
ptrdiff_t offset = EmitCheck(cx, cg, op, 2);
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
LookupCompileTimeConstant(JSContext *cx, JSCodeGenerator *cg, JSAtom *atom,
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
0
---------------------------------
252 CVE-2016-2842/OpenSSL_1.0.1_CVE-2016-2842_b_print.c cfunc 252
const char *format,
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
if (isdigit((unsigned char)ch)) {
0
---------------------------------
253 CVE-2016-2842/OpenSSL_1.0.1_CVE-2016-2842_b_print.c cppfunc 252
const char *format,
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
if (isdigit((unsigned char)ch)) {
0
---------------------------------
254 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cppfunc 965
void NetworkUtils::disableNat(CommandChain* aChain,
if (!GET_FIELD(mIp).IsEmpty() && !GET_FIELD(mPrefix).IsEmpty()) {
uint32_t prefix = atoi(GET_CHAR(mPrefix));
0
---------------------------------
255 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 516
int  _AVI_ChunkRead( stream_t *s, avi_chunk_t *p_chk, avi_chunk_t *p_father )
if( AVI_ChunkReadCommon( s, p_chk ) )
static int AVI_ChunkReadCommon( stream_t *s, avi_chunk_t *p_chk )
if( ( i_peek = stream_Peek( s, &p_peek, 8 ) ) < 8 )
p_chk->common.i_chunk_pos    = stream_Tell( s );
AVI_READCHUNK_ENTER;
AVI_READ2BYTES( p_indx->i_longsperentry );
AVI_READ1BYTE ( p_indx->i_indexsubtype );
AVI_READ4BYTES( p_indx->i_id );
AVI_READ8BYTES( p_indx->i_baseoffset );
AVI_READ4BYTES( i_dummy );
i_count = __MIN( p_indx->i_entriesinuse, i_read / 8 );
p_indx->idx.std = calloc( sizeof( indx_std_entry_t ), i_count );
if( AVI_ChunkReadCommon( s, p_chk ) )
return AVI_ChunkRead_indx( s, p_chk );
static int AVI_ChunkRead_indx( stream_t *s, avi_chunk_t *p_chk )
AVI_READCHUNK_ENTER;
i_count = __MIN( p_indx->i_entriesinuse, i_read / 8 );
p_indx->idx.std = calloc( sizeof( indx_std_entry_t ), i_count );
static inline uint8_t GetB( uint8_t *ptr )
AVI_READ1BYTE ( p_indx->i_indextype );
static inline uint8_t GetB( uint8_t *ptr )
AVI_READ4BYTES( p_indx->i_entriesinuse );
i_count = __MIN( p_indx->i_entriesinuse, i_read / 8 );
p_indx->idx.std = calloc( sizeof( indx_std_entry_t ), i_count );
0
---------------------------------
256 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cppfunc 516
int  _AVI_ChunkRead( stream_t *s, avi_chunk_t *p_chk, avi_chunk_t *p_father )
if( AVI_ChunkReadCommon( s, p_chk ) )
static int AVI_ChunkReadCommon( stream_t *s, avi_chunk_t *p_chk )
if( ( i_peek = stream_Peek( s, &p_peek, 8 ) ) < 8 )
p_chk->common.i_chunk_pos    = stream_Tell( s );
AVI_READCHUNK_ENTER;
AVI_READ2BYTES( p_indx->i_longsperentry );
AVI_READ1BYTE ( p_indx->i_indexsubtype );
AVI_READ4BYTES( p_indx->i_id );
AVI_READ8BYTES( p_indx->i_baseoffset );
AVI_READ4BYTES( i_dummy );
i_count = __MIN( p_indx->i_entriesinuse, i_read / 8 );
p_indx->idx.std = calloc( sizeof( indx_std_entry_t ), i_count );
if( AVI_ChunkReadCommon( s, p_chk ) )
return AVI_ChunkRead_indx( s, p_chk );
static int AVI_ChunkRead_indx( stream_t *s, avi_chunk_t *p_chk )
AVI_READCHUNK_ENTER;
i_count = __MIN( p_indx->i_entriesinuse, i_read / 8 );
p_indx->idx.std = calloc( sizeof( indx_std_entry_t ), i_count );
static inline uint8_t GetB( uint8_t *ptr )
AVI_READ1BYTE ( p_indx->i_indextype );
static inline uint8_t GetB( uint8_t *ptr )
AVI_READ4BYTES( p_indx->i_entriesinuse );
i_count = __MIN( p_indx->i_entriesinuse, i_read / 8 );
p_indx->idx.std = calloc( sizeof( indx_std_entry_t ), i_count );
0
---------------------------------
257 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7113
static FILE *fp;
fp = fopen("/tmp/srcnotes.hist", "w");
setvbuf(fp, NULL, _IONBF, 0);
fprintf(fp, "SrcNote size histogram:\n");
fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
fputc('*', fp);
0
---------------------------------
258 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7114
static FILE *fp;
fp = fopen("/tmp/srcnotes.hist", "w");
setvbuf(fp, NULL, _IONBF, 0);
fprintf(fp, "SrcNote size histogram:\n");
fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
fputc('\n', fp);
0
---------------------------------
259 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 2179
char		addrname[32];
bytes, httpAddrString(addr, addrname, sizeof(addrname)));
asn1_debug(buffer, bytes, 0);
hex_debug(buffer, bytes);
bytes, addrname, strerror(errno));
static void		hex_debug(unsigned char *buffer, size_t len);
if (sendto(fd, buffer, bytes, 0, (void *)addr, sizeof(addr->ipv4)) < bytes)
bytes, addrname, strerror(errno));
static void		asn1_debug(unsigned char *buffer, size_t len,
if (sendto(fd, buffer, bytes, 0, (void *)addr, sizeof(addr->ipv4)) < bytes)
bytes, addrname, strerror(errno));
0
---------------------------------
260 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7116
static FILE *fp;
fp = fopen("/tmp/srcnotes.hist", "w");
setvbuf(fp, NULL, _IONBF, 0);
fprintf(fp, "SrcNote size histogram:\n");
fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
fputc('*', fp);
fputc('\n', fp);
fputc('\n', fp);
0
---------------------------------
261 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4296
const char *p, *ls, *ls2, *at, *col, *brk;
av_strlcpy(proto, url, FFMIN(proto_size, p + 1 - url));
p++;
if (*p == '/') p++;
if (*p == '/') p++;
ls = strchr(p, '/');
ls2 = strchr(p, '?');
ls = ls2;
ls = FFMIN(ls, ls2);
av_strlcpy(path, ls, path_size);
ls = &p[strlen(p)];
if ((at = strchr(p, '@')) && at < ls) {
FFMIN(authorization_size, at + 1 - p));
p = at + 1;
if (*p == '[' && (brk = strchr(p, ']')) && brk < ls) {
} else if ((col = strchr(p, ':')) && col < ls) {
FFMIN(col + 1 - p, hostname_size));
if (port_ptr) *port_ptr = atoi(col + 1);
0
---------------------------------
262 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4296
const char *p, *ls, *ls2, *at, *col, *brk;
av_strlcpy(proto, url, FFMIN(proto_size, p + 1 - url));
p++;
if (*p == '/') p++;
if (*p == '/') p++;
ls = strchr(p, '/');
ls2 = strchr(p, '?');
ls = ls2;
ls = FFMIN(ls, ls2);
av_strlcpy(path, ls, path_size);
ls = &p[strlen(p)];
if ((at = strchr(p, '@')) && at < ls) {
FFMIN(authorization_size, at + 1 - p));
p = at + 1;
if (*p == '[' && (brk = strchr(p, ']')) && brk < ls) {
} else if ((col = strchr(p, ':')) && col < ls) {
FFMIN(col + 1 - p, hostname_size));
if (port_ptr) *port_ptr = atoi(col + 1);
0
---------------------------------
263 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 616
void NetworkUtils::setAccessPoint(CommandChain* aChain,
nsCString ssid(GET_CHAR(mSsid));
nsCString key(GET_CHAR(mKey));
escapeQuote(key);
aString.ReplaceSubstring("\\", "\\\\");
}
key.get());
0
---------------------------------
264 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 567
HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
if (!Process32FirstW(snapshot, &processEntry)) {
CloseHandle(snapshot);
0
---------------------------------
265 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp API 586
aOldParent, aNewParent);
nsIFrame* aNewParent)
ReparentFrame(e.get(), aOldParent, aNewParent);
ReparentFrame(nsIFrame* aFrame, nsIFrame* aOldParent, nsIFrame* aNewParent)
aFrame->SetParent(aNewParent);
0
---------------------------------
266 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1795
static void DumpLine(const nsBlockReflowState& aState, nsLineBox* aLine,
nsRect ovis(aLine->GetVisualOverflowArea());
ovis.x, ovis.y, ovis.width, ovis.height,
0
---------------------------------
267 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1797
static void DumpLine(const nsBlockReflowState& aState, nsLineBox* aLine,
nscoord aDeltaY, int32_t aDeltaIndent) {
nsRect ovis(aLine->GetVisualOverflowArea());
nsRect oscr(aLine->GetScrollableOverflowArea());
static_cast<void*>(aLine), aState.mY,
aLine->IsDirty() ? "yes" : "no",
aDeltaY, aState.mPrevBottomMargin.get(), aLine->GetChildCount());
0
---------------------------------
268 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1796
static void DumpLine(const nsBlockReflowState& aState, nsLineBox* aLine,
nsRect ovis(aLine->GetVisualOverflowArea());
nsRect oscr(aLine->GetScrollableOverflowArea());
oscr.x, oscr.y, oscr.width, oscr.height,
0
---------------------------------
269 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6035
const nsRect& aDirtyRect, nsBlockFrame::line_iterator& aLine,
DebugOutputDrawLine(aDepth, aLine.get(), intersect);
static void DebugOutputDrawLine(int32_t aDepth, nsLineBox* aLine, bool aDrawn) {
nsRect lineArea = aLine->GetVisualOverflowArea();
static_cast<void*>(aLine),
0
---------------------------------
270 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 917
static int		asn1_size_length(int length);
valuelen = asn1_size_integer(packet->object_value.integer);
1 + asn1_size_length(valuelen) + valuelen;
asn1_set_integer(&bufptr, packet->version);
asn1_set_length(&bufptr, commlen);
int length);
memcpy(bufptr, packet->community, commlen);
bufptr += commlen;
*bufptr++ = packet->request_type;
*bufptr++ = ASN1_SEQUENCE;
asn1_set_oid(&bufptr, packet->object_name);
asn1_set_length(&bufptr, valuelen);
int length);
memcpy(bufptr, packet->object_value.string, valuelen);
static void		asn1_set_integer(unsigned char **buffer,
asn1_set_integer(&bufptr, packet->version);
memcpy(bufptr, packet->community, commlen);
asn1_set_integer(&bufptr, packet->request_id);
asn1_set_integer(&bufptr, packet->error_status);
asn1_set_integer(&bufptr, packet->error_index);
memcpy(bufptr, packet->object_value.string, valuelen);
static void		asn1_set_length(unsigned char **buffer,
asn1_set_length(&bufptr, msglen);
asn1_set_length(&bufptr, commlen);
memcpy(bufptr, packet->community, commlen);
asn1_set_length(&bufptr, reqlen);
asn1_set_length(&bufptr, listlen);
asn1_set_length(&bufptr, varlen);
asn1_set_length(&bufptr, valuelen);
memcpy(bufptr, packet->object_value.string, valuelen);
asn1_encode_snmp(unsigned char *buffer,
valuelen = 0;
valuelen = asn1_size_integer(packet->object_value.boolean);
valuelen = strlen(packet->object_value.string);
valuelen = asn1_size_oid(packet->object_value.oid);
1 + asn1_size_length(valuelen) + valuelen;
commlen = strlen(packet->community);
1 + asn1_size_length(commlen) + commlen +
bufptr = buffer;
*bufptr++ = ASN1_SEQUENCE;
asn1_set_length(&bufptr, msglen);
*bufptr++ = ASN1_OCTET_STRING;
asn1_set_length(&bufptr, commlen);
memcpy(bufptr, packet->community, commlen);
asn1_set_length(&bufptr, reqlen);
asn1_set_integer(&bufptr, packet->request_id);
asn1_set_integer(&bufptr, packet->error_status);
asn1_set_integer(&bufptr, packet->error_index);
*bufptr++ = ASN1_SEQUENCE;
asn1_set_length(&bufptr, listlen);
asn1_set_length(&bufptr, varlen);
*bufptr++ = ASN1_OCTET_STRING;
asn1_set_length(&bufptr, valuelen);
memcpy(bufptr, packet->object_value.string, valuelen);
static void		asn1_set_oid(unsigned char **buffer,
asn1_set_oid(&bufptr, packet->object_name);
memcpy(bufptr, packet->object_value.string, valuelen);
0
---------------------------------
271 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4292
const char *url)
const char *p, *ls, *ls2, *at, *col, *brk;
if ((p = strchr(url, ':'))) {
av_strlcpy(proto, url, FFMIN(proto_size, p + 1 - url));
p++;
if (*p == '/') p++;
if (*p == '/') p++;
ls = strchr(p, '/');
ls2 = strchr(p, '?');
ls = ls2;
ls = FFMIN(ls, ls2);
av_strlcpy(path, ls, path_size);
ls = &p[strlen(p)];
if ((at = strchr(p, '@')) && at < ls) {
FFMIN(authorization_size, at + 1 - p));
p = at + 1;
if (*p == '[' && (brk = strchr(p, ']')) && brk < ls) {
FFMIN(hostname_size, brk - p));
*port_ptr = atoi(brk + 2);
0
---------------------------------
272 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4292
const char *url)
const char *p, *ls, *ls2, *at, *col, *brk;
if ((p = strchr(url, ':'))) {
av_strlcpy(proto, url, FFMIN(proto_size, p + 1 - url));
p++;
if (*p == '/') p++;
if (*p == '/') p++;
ls = strchr(p, '/');
ls2 = strchr(p, '?');
ls = ls2;
ls = FFMIN(ls, ls2);
av_strlcpy(path, ls, path_size);
ls = &p[strlen(p)];
if ((at = strchr(p, '@')) && at < ls) {
FFMIN(authorization_size, at + 1 - p));
p = at + 1;
if (*p == '[' && (brk = strchr(p, ']')) && brk < ls) {
FFMIN(hostname_size, brk - p));
*port_ptr = atoi(brk + 2);
0
---------------------------------
273 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 845
V9fsStatDotl v9stat_dotl;
stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);
V9fsStatDotl *v9lstat)
memset(v9lstat, 0, sizeof(*v9lstat));
0
---------------------------------
274 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6039
const nsRect& aDirtyRect, nsBlockFrame::line_iterator& aLine,
DebugOutputDrawLine(aDepth, aLine.get(), intersect);
static void DebugOutputDrawLine(int32_t aDepth, nsLineBox* aLine, bool aDrawn) {
nsRect lineArea = aLine->GetVisualOverflowArea();
lineArea.width, lineArea.height);
0
---------------------------------
275 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6038
const nsRect& aDirtyRect, nsBlockFrame::line_iterator& aLine,
DebugOutputDrawLine(aDepth, aLine.get(), intersect);
static void DebugOutputDrawLine(int32_t aDepth, nsLineBox* aLine, bool aDrawn) {
nsRect lineArea = aLine->GetVisualOverflowArea();
lineArea.x, lineArea.y,
0
---------------------------------
276 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_maintenanceservice.cpp cfunc 162
if (!GetBackupLogPath(newPath, basePath, i)) {
BackupOldLogs(updatePath, LOGS_TO_KEEP);
GetBackupLogPath(LPWSTR path, LPCWSTR basePath, int logNumber)
L"maintenanceservice-%d.log", logNumber);
BackupOldLogs(LPCWSTR basePath, int numLogsToKeep)
for (int i = numLogsToKeep; i >= 1; i--) {
if (!GetBackupLogPath(oldPath, basePath, i -1)) {
0
---------------------------------
277 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_maintenanceservice.cpp cppfunc 162
if (!GetBackupLogPath(newPath, basePath, i)) {
BackupOldLogs(updatePath, LOGS_TO_KEEP);
BackupOldLogs(LPCWSTR basePath, int numLogsToKeep)
for (int i = numLogsToKeep; i >= 1; i--) {
if (!GetBackupLogPath(oldPath, basePath, i -1)) {
GetBackupLogPath(LPWSTR path, LPCWSTR basePath, int logNumber)
L"maintenanceservice-%d.log", logNumber);
0
---------------------------------
278 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 370
AVI_READCHUNK_ENTER;
p_chk->strf.auds.p_wf = malloc( __MAX( p_chk->common.i_chunk_size, sizeof( WAVEFORMATEX ) ) );
AVI_READ2BYTES( p_chk->strf.auds.p_wf->wFormatTag );
AVI_READ2BYTES( p_chk->strf.auds.p_wf->nChannels );
AVI_READ4BYTES( p_chk->strf.auds.p_wf->nSamplesPerSec );
AVI_READ4BYTES( p_chk->strf.auds.p_wf->nAvgBytesPerSec );
AVI_READ2BYTES( p_chk->strf.auds.p_wf->nBlockAlign );
AVI_READ2BYTES( p_chk->strf.auds.p_wf->wBitsPerSample );
&& p_chk->common.i_chunk_size > sizeof( WAVEFORMATEX ) )
AVI_READ2BYTES( p_chk->strf.auds.p_wf->cbSize );
p_chk->common.i_chunk_size - sizeof( WAVEFORMATEX ) )
p_chk->common.i_chunk_size - sizeof( WAVEFORMATEX );
p_chk->strf.auds.p_wf->cbSize =
p_chk->strf.auds.p_wf->cbSize = 0;
p_chk->strf.auds.p_wf->cbSize );
0
---------------------------------
279 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c cfunc 121
FILE            *fp,
fread(buf, 13, 1, fp);
if (gif_read_cmap(fp, ncolors, cmap, &gray))
fclose(fp);
buf[0] = getc(fp);
gif_get_block(fp, buf);
while (gif_get_block(fp, buf) != 0);
static int	gif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,
fclose(fp);
static int	gif_get_block(FILE *fp, unsigned char *buffer);
fclose(fp);
while (gif_get_block(fp, buf) != 0);
0
---------------------------------
280 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 669
buf[line_len] = '\0';
tmp = buf + STRLEN_CONST(rtsp_content_length);
tmp++;
while (*tmp && isspace(*tmp))
0
---------------------------------
281 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 669
buf[line_len] = '\0';
tmp = buf + STRLEN_CONST(rtsp_content_length);
tmp++;
while (*tmp && isspace(*tmp))
0
---------------------------------
282 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c inputfunc 125
buf[0] = getc(fp);
while (gif_get_block(fp, buf) != 0);
static int	gif_get_block(FILE *fp, unsigned char *buffer);
switch (getc(fp))
fclose(fp);
fread(buf, 9, 1, fp);
if (buf[8] & GIF_COLORMAP)
ncolors = 2 << (buf[8] & 0x07);
if (gif_read_cmap(fp, ncolors, cmap, &gray))
img->xsize = (buf[5] << 8) | buf[4];
img->ysize = (buf[7] << 8) | buf[6];
if (img->xsize == 0 || img->ysize == 0)
img->xsize, img->ysize);
fprintf(stderr, "DEBUG: Bad GIF image dimensions: %dx%d\n",
fclose(fp);
i = gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE);
int interlace);
i = gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE);
static int	gif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,
fclose(fp);
for (i = ncolors - 1; i >= 0; i --)
cupsImageWhiteToCMYK(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageWhiteToCMY(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageWhiteToBlack(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageWhiteToRGB(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBAdjust(cmap[i], 1, saturation, hue);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToCMYK(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToCMY(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToBlack(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToWhite(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageRGBToRGB(cmap[i], cmap[i], 1);
for (i = ncolors - 1; i >= 0; i --)
cupsImageLut(cmap[i], bpp, lut);
static int	gif_read_image(FILE *fp, cups_image_t *img, gif_cmap_t cmap,
fclose(fp);
0
---------------------------------
283 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 1255
stream_header_t tmp;
stream_header_t *st = &tmp;
memcpy( st->streamtype, &oggpacket.packet[1+0], 8 );
if( !strncmp( st->streamtype, "video", 5 ) &&
else if( !strncmp( st->streamtype, "audio", 5 ) &&
else if( !strncmp(st->streamtype, "text", 4) )
0
---------------------------------
284 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 665
rtsp_get_content_length(const guchar *line_begin, size_t line_len)
guchar  buf[256];
if (line_len > sizeof(buf) - 1) {
line_len = sizeof(buf) - 1;
memcpy(buf, line_begin, line_len);
0
---------------------------------
285 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 185
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
psz_domain = strdup( psz_tmp );
free( psz_tmp );
0
---------------------------------
286 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 185
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_parser = strchr( psz_tmp, '@' );
psz_parser = strchr( psz_tmp, ':' );
psz_parser = strchr( psz_tmp, ';' );
psz_domain = strdup( psz_tmp );
free( psz_tmp );
0
---------------------------------
287 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4521
void ff_make_absolute_url(char *buf, int size, const char *base,
av_strlcpy(buf, base, size);
sep = strstr(buf, ":
sep += 3;
sep = strchr(sep, '/');
0
---------------------------------
288 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 2449
nsTArray<nsCString> configFuncs;
char persistConfig[PROPERTY_VALUE_MAX];
join(configFuncs, USB_CONFIG_DELIMIT, PROPERTY_VALUE_MAX, newConfig);
if (strcmp(currentConfig, newConfig)) {
property_set(SYS_USB_CONFIG_PROPERTY, newConfig);
}
0
---------------------------------
289 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 631
static int AVI_ChunkRead_strz( stream_t *s, avi_chunk_t *p_chk )
AVI_READCHUNK_ENTER;
p_strz->p_str = malloc( i_read + 1);
memcpy( p_strz->p_str, p_read, i_read );
0
---------------------------------
290 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4486
void ff_parse_key_value(const char *str, ff_parse_key_val_cb callback_get_buf,
const char *ptr = str;
while (*ptr && (isspace(*ptr) || *ptr == ','))
ptr++;
key = ptr;
if (!(ptr = strchr(key, '=')))
ptr++;
ptr += 2;
ptr++;
ptr++;
key = ptr;
if (!(ptr = strchr(key, '=')))
ptr++;
for (; *ptr && !(isspace(*ptr) || *ptr == ','); ptr++)
0
---------------------------------
291 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4486
void ff_parse_key_value(const char *str, ff_parse_key_val_cb callback_get_buf,
const char *ptr = str;
while (*ptr && (isspace(*ptr) || *ptr == ','))
ptr++;
key = ptr;
if (!(ptr = strchr(key, '=')))
ptr++;
ptr += 2;
ptr++;
ptr++;
key = ptr;
if (!(ptr = strchr(key, '=')))
ptr++;
for (; *ptr && !(isspace(*ptr) || *ptr == ','); ptr++)
0
---------------------------------
292 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 735
nsBlockFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
InlineMinWidthData data;
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.ForceBreak(aRenderingContext);
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
kid->AddInlineMinWidth(aRenderingContext, &data);
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
kid->AddInlineMinWidth(aRenderingContext, &data);
data.prevLines, data.currentLine);
return nsBidiPresUtils::Resolve(this);
for (nsBlockFrame* curFrame = this; curFrame;
curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
line->IsBlock() ? "block" : "inline",
line->IsEmpty() ? ", empty" : "");
if (line->IsBlock()) {
line->mFirstChild, nsLayoutUtils::MIN_WIDTH);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.line = &line;
data.ForceBreak(aRenderingContext);
data.ForceBreak(aRenderingContext);
line == curFrame->begin_lines()) {
if (!curFrame->GetPrevContinuation() &&
const nsStyleCoord &indent = GetStyleText()->mTextIndent;
if (indent.ConvertsToLength())
kid->AddInlineMinWidth(aRenderingContext, &data);
data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
for (int32_t i = 0, i_end = line->GetChildCount(); i != i_end;
data.line = &line;
data.lineContainer = curFrame;
data.prevLines, data.currentLine);
kid->AddInlineMinWidth(aRenderingContext, &data);
data.prevLines, data.currentLine);
0
---------------------------------
293 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 4122
aAvailableSpaceHeight = NS_MAX(aAvailableSpaceHeight, aLine->mBounds.height);
aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y,
if (CRAZY_HEIGHT(aLine->mBounds.y)) {
lastHeight = aLine->mBounds.y;
if (abs(aLine->mBounds.y - lastHeight) > CRAZY_H/10) {
aLine->mBounds.y, aLine->mBounds.height);
0
---------------------------------
294 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1287
unsigned char *buf = NULL;
return NULL;
frag->fragment = buf;
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
return NULL;
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
frag->reassembly = bitmask;
return frag;
s->d1->handshake_write_seq = s->d1->next_handshake_write_seq;
s->d1->next_handshake_write_seq++;
s2n(s->d1->handshake_write_seq, p);
dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
s->d1->handshake_write_seq, 0, 0);
unsigned short seq_num,
unsigned char *bitmask = NULL;
frag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));
return NULL;
frag->reassembly = bitmask;
return frag;
dtls1_buffer_message(s, 1);
frag = dtls1_hm_fragment_new(s->init_num, 0);
memcpy(frag->fragment, s->init_buf->data, s->init_num);
static void dtls1_set_message_header_int(SSL *s, unsigned char mt,
dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
dtls1_buffer_message(s, 1);
int dtls1_buffer_message(SSL *s, int is_ccs)
frag = dtls1_hm_fragment_new(s->init_num, 0);
static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len,
buf = (unsigned char *)OPENSSL_malloc(frag_len);
frag->fragment = buf;
return frag;
frag = dtls1_hm_fragment_new(s->init_num, 0);
memcpy(frag->fragment, s->init_buf->data, s->init_num);
0
---------------------------------
295 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 1699
char dnschange[PROPERTY_VALUE_MAX];
property_get("net.dnschange", dnschange, "0");
char num[PROPERTY_VALUE_MAX];
snprintf(num, PROPERTY_VALUE_MAX - 1, "%d", atoi(dnschange) + 1);
0
---------------------------------
296 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cppfunc 1699
char dnschange[PROPERTY_VALUE_MAX];
property_get("net.dnschange", dnschange, "0");
snprintf(num, PROPERTY_VALUE_MAX - 1, "%d", atoi(dnschange) + 1);
0
---------------------------------
297 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4453
void ff_parse_key_value(const char *str, ff_parse_key_val_cb callback_get_buf,
const char *ptr = str;
while (*ptr && (isspace(*ptr) || *ptr == ','))
ptr++;
if (!(ptr = strchr(key, '=')))
while (*ptr && (isspace(*ptr) || *ptr == ','))
ptr++;
while (*ptr && (isspace(*ptr) || *ptr == ','))
ptr++;
ptr += 2;
ptr++;
ptr++;
for (; *ptr && !(isspace(*ptr) || *ptr == ','); ptr++)
while (*ptr && (isspace(*ptr) || *ptr == ','))
0
---------------------------------
298 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4453
void ff_parse_key_value(const char *str, ff_parse_key_val_cb callback_get_buf,
const char *ptr = str;
while (*ptr && (isspace(*ptr) || *ptr == ','))
ptr++;
if (!(ptr = strchr(key, '=')))
while (*ptr && (isspace(*ptr) || *ptr == ','))
ptr++;
while (*ptr && (isspace(*ptr) || *ptr == ','))
ptr++;
ptr += 2;
ptr++;
ptr++;
for (; *ptr && !(isspace(*ptr) || *ptr == ','); ptr++)
while (*ptr && (isspace(*ptr) || *ptr == ','))
0
---------------------------------
299 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1208
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
ellipticcurvelist_length += (*(sdata++));
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
ellipticcurvelist_length;
s->session->tlsext_ellipticcurvelist_length =
s->session->tlsext_ellipticcurvelist_length);
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length;
s->session->tlsext_ellipticcurvelist_length =
s->session->tlsext_ellipticcurvelist_length);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length;
s->session->tlsext_ellipticcurvelist_length =
s->session->tlsext_ellipticcurvelist_length);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length;
s->session->tlsext_ellipticcurvelist_length =
s->session->tlsext_ellipticcurvelist_length);
0
---------------------------------
300 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1203
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
ellipticcurvelist_length += (*(sdata++));
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
0
---------------------------------
301 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 652
frag = NULL;
al = dtls1_preprocess_fragment(s, &frag->msg_header, max);
static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr,
al = dtls1_preprocess_fragment(s, &frag->msg_header, max);
frag->msg_header.frag_len);
0
---------------------------------
302 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1400
char       *make_model,
const char *old_make_model,
int        make_model_size)
if (!strncasecmp(old_make_model, "Hewlett-Packard", 15))
else if (!strncasecmp(old_make_model, "deskjet", 7))
else if (!strncasecmp(old_make_model, "officejet", 9))
snprintf(make_model, make_model_size, "HP OfficeJet%s", old_make_model + 9);
0
---------------------------------
303 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1403
const char *old_make_model,
if (!strncasecmp(old_make_model, "Hewlett-Packard", 15))
else if (!strncasecmp(old_make_model, "deskjet", 7))
else if (!strncasecmp(old_make_model, "officejet", 9))
else if (!strncasecmp(old_make_model, "stylus_pro_", 11))
old_make_model + 11);
0
---------------------------------
304 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 414
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
fprintf(out, " preserves-3d");
0
---------------------------------
305 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 809
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(0, ret);
int el;
if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(0, ret);
s2n(TLSEXT_TYPE_status_request, ret);
s2n(0, ret);
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(sol + 2, ret);
s2n(sol, ret);
memcpy(ret, s->s3->server_opaque_prf_input, sol);
0
---------------------------------
306 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 411
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
0
---------------------------------
307 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1528
unsigned short size;
n2s(data, size);
s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_next_proto_validate(data, size)) {
if (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d,
unsigned char *data = *p;
n2s(data, length);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
fprintf(stderr,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
if (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
static char ssl_next_proto_validate(unsigned char *d, unsigned len)
ctx->next_proto_select_cb(s, &selected, &selected_len, data,
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
size,
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
0
---------------------------------
308 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1521
unsigned short size;
n2s(data, size);
s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);
if (!ssl_next_proto_validate(data, size)) {
if (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
if (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d,
unsigned char *data = *p;
n2s(data, length);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
!s->tls_session_ticket_ext_cb(s, data, size,
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
static char ssl_next_proto_validate(unsigned char *d, unsigned len)
ctx->next_proto_select_cb(s, &selected, &selected_len, data,
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
size,
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
0
---------------------------------
309 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1212
fprintf(stderr, "%i ", *(sdata++));
fprintf(stderr, "\n");
fprintf(stderr, "Received extension type %d size %d\n", type, size);
fprintf(stderr,
fprintf(stderr, "\n");
0
---------------------------------
310 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1425
sizeof(s->s3->write_sequence));
sizeof(s->s3->write_sequence));
sizeof(s->s3->write_sequence));
sizeof(s->s3->write_sequence));
0
---------------------------------
311 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1504
struct hm_header_st msg_hdr;
dtls1_get_message_header(wire, &msg_hdr);
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
0
---------------------------------
312 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 976
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
ssl_check_for_safari(s, data, limit);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
0
---------------------------------
313 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_workmonitor.cpp API 210
PROCESS_INFORMATION pi = {0};
NULL, &si, &pi);
DWORD waitRes = WaitForSingleObject(pi.hProcess, TIME_TO_WAIT_ON_UPDATER);
TerminateProcess(pi.hProcess, 1);
if (GetExitCodeProcess(pi.hProcess, &returnCode)) {
CloseHandle(pi.hProcess);
0
---------------------------------
314 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 396
int32_t numInlineLines = 0;
int32_t numBlockLines = 0;
numBlockLines++;
numInlineLines++;
static_cast<void*>(mStyleContext), numInlineLines, numBlockLines);
0
---------------------------------
315 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 201
if (!av_strncasecmp(name, names, len))
return !av_strcasecmp(name, names);
return av_guess_format("image2", NULL, NULL);
if (fmt->name && short_name && match_format(short_name, fmt->name))
oformat = av_guess_format(NULL, filename, NULL);
static int match_format(const char *name, const char *names)
namelen = strlen(name);
AVOutputFormat *av_guess_format(const char *short_name, const char *filename,
if (fmt->name && short_name && match_format(short_name, fmt->name))
AVInputFormat *av_find_input_format(const char *short_name)
if (match_format(short_name, fmt->name))
AVFormatContext *avformat_alloc_output_context(const char *format,
int ret = avformat_alloc_output_context2(&avctx, oformat, format, filename);
const char *format, const char *filename)
oformat = av_guess_format(format, NULL, NULL);
0
---------------------------------
316 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_workmonitor.cpp cppfunc 51
WCHAR updateStatusFilePath[MAX_PATH + 1] = {L'\0'};
wcsncpy(updateStatusFilePath, updateDirPath, MAX_PATH);
wcsncpy(aResultDir, argvTmp[2], MAX_PATH);
bool backgroundUpdate = IsUpdateBeingStaged(argcTmp, argvTmp);
if (!PathRemoveFileSpecW(serviceUpdaterPath)) {
if (!PathAppendSafe(serviceUpdaterPath, L"update")) {
CreateDirectoryW(serviceUpdaterPath, NULL);
if (!PathAppendSafe(serviceUpdaterPath, L"updater.exe")) {
result = DeleteFileW(serviceUpdaterPath);
serviceUpdaterPath));
if (PathGetSiblingFilePath(updaterINIPath, serviceUpdaterPath,
WCHAR secureUpdaterPath[MAX_PATH + 1] = { L'\0' };
result = GetSecureUpdaterPath(secureUpdaterPath);
oldUpdaterPath, secureUpdaterPath));
DeleteSecureUpdater(secureUpdaterPath);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv)
if (!GetInstallationDir(argc, argv, installDir)) {
GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH + 1])
if (!IsLocalFile(argv[0], isLocal) || !isLocal) {
nsAutoHandle noWriteLock(CreateFileW(argv[0], GENERIC_READ, FILE_SHARE_READ,
if (result && !VerifySameFiles(argv[0], installDirUpdater,
HMODULE updaterModule = LoadLibraryEx(argv[0], NULL,
argv[0]);
if (StartUpdateProcess(argc, argv, installDir,
LPWSTR *argv,
LPWSTR cmdLine = MakeCommandLine(argc, argv);
PRUnichar* MakeCommandLine(int argc, PRUnichar **argv);
PathGetSiblingFilePath(updaterINITemp, argv[0], L"updater.tmp")) {
BOOL PathGetSiblingFilePath(LPWSTR destinationBuffer,  LPCWSTR siblingFilePath,
if (PathGetSiblingFilePath(updaterINI, argv[0], L"updater.ini") &&
processStarted = CreateProcessW(argv[0], cmdLine,
if (IsStatusApplying(argv[1], isApplying) && isApplying) {
result = CopyFileW(oldUpdaterPath, secureUpdaterPath, FALSE);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
BOOL PathGetSiblingFilePath(LPWSTR destinationBuffer,  LPCWSTR siblingFilePath,
processStarted = CreateProcessW(argv[0], cmdLine,
if (IsStatusApplying(argv[1], isApplying) && isApplying) {
IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying)
wcsncpy(updateStatusFilePath, updateDirPath, MAX_PATH);
DeleteSecureUpdater(WCHAR serviceUpdaterPath[MAX_PATH + 1])
result = CopyFileW(oldUpdaterPath, secureUpdaterPath, FALSE);
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
GetSecureUpdaterPath(WCHAR serviceUpdaterPath[MAX_PATH + 1])
if (!GetModuleFileNameW(NULL, serviceUpdaterPath, MAX_PATH)) {
argv[3] = secureUpdaterPath;
result = ProcessSoftwareUpdateCommand(argc - 3, argv + 3);
IsUpdateBeingStaged(int argc, LPWSTR *argv)
return argc == 4 && !wcscmp(argv[3], L"-1");
bool replaceRequest = (argcTmp >= 4 && wcsstr(argvTmp[3], L"/replace"));
if (!IsLocalFile(argv[0], isLocal) || !isLocal) {
nsAutoHandle noWriteLock(CreateFileW(argv[0], GENERIC_READ, FILE_SHARE_READ,
if (result && !VerifySameFiles(argv[0], installDirUpdater,
HMODULE updaterModule = LoadLibraryEx(argv[0], NULL,
argv[0]);
if (StartUpdateProcess(argc, argv, installDir,
LPWSTR *argv,
LPWSTR cmdLine = MakeCommandLine(argc, argv);
0
---------------------------------
317 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c cfunc 470
cups_image_t *img,
bpp       = cupsImageGetDepth(img);
pixels    = calloc(bpp, img->xsize);
free(pixels);
0
---------------------------------
318 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c cppfunc 470
cups_image_t *img,
bpp       = cupsImageGetDepth(img);
pixels    = calloc(bpp, img->xsize);
free(pixels);
0
---------------------------------
319 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 774
fprintf(stderr, "DEBUG: %*sSEQUENCE %d bytes\n", indent, "",
asn1_debug(buffer, value_length, indent + 4);
fprintf(stderr, "DEBUG: %*sGet-Request-PDU %d bytes\n", indent, "",
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
int           indent)
fprintf(stderr, "DEBUG: %*sBOOLEAN %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sINTEGER %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sOCTET STRING %d bytes \"%s\"\n", indent, "",
fprintf(stderr, "DEBUG: %*sNULL VALUE %d bytes\n", indent, "",
fprintf(stderr, "DEBUG: %*sOID %d bytes ", indent, "",
fprintf(stderr, ".%d", oid[i]);
putc('\n', stderr);
fprintf(stderr, "DEBUG: %*sUNKNOWN(%x) %d bytes\n", indent, "",
fprintf(stderr, "DEBUG: %*sGet-Response-PDU %d bytes\n", indent, "",
0
---------------------------------
320 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c cfunc 804
path->data = NULL;
path->size = 0;
path->data = NULL;
path->size = 0;
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
fidp = get_fid(pdu, fid);
err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);
err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);
V9fsPath path;
v9fs_path_init(&path);
err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);
v9fs_path_free(&path);
err = v9fs_co_lstat(pdu, &path, &stbuf);
err = v9fs_co_name_to_path(pdu, &fidp->path, dent->d_name, &path);
v9fs_path_init(&path);
static int stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,
str = strrchr(name->data, '/');
void v9fs_path_init(V9fsPath *path)
v9fs_path_init(&path);
err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
fidp = get_fid(pdu, fid);
err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);
void v9fs_path_free(V9fsPath *path)
v9fs_path_free(&path);
err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);
0
---------------------------------
321 CVE-2016-0799/OpenSSL_1.0.1_CVE-2016-0799_b_print.c cfunc 234
const char *format,
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
if (isdigit((unsigned char)ch)) {
0
---------------------------------
322 CVE-2016-0799/OpenSSL_1.0.1_CVE-2016-0799_b_print.c cppfunc 234
const char *format,
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
ch = *format++;
if (isdigit((unsigned char)ch)) {
0
---------------------------------
323 CVE-2016-2842/OpenSSL_1.0.1_CVE-2016-2842_b_print.c cfunc 743
char **sbuffer,
char **buffer,
assert(*sbuffer != NULL || buffer != NULL);
memcpy(*buffer, *sbuffer, *currlen);
*sbuffer = NULL;
assert(*sbuffer != NULL);
0
---------------------------------
324 CVE-2016-2842/OpenSSL_1.0.1_CVE-2016-2842_b_print.c cppfunc 743
char **sbuffer,
char **buffer,
assert(*sbuffer != NULL || buffer != NULL);
memcpy(*buffer, *sbuffer, *currlen);
*sbuffer = NULL;
assert(*sbuffer != NULL);
0
---------------------------------
325 CVE-2016-0799/OpenSSL_1.0.1_CVE-2016-0799_b_print.c cfunc 522
const char *prefix = "";
if (base == 8) prefix = "0";
if (base == 16) prefix = "0x";
spadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix);
0
---------------------------------
326 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1115
s->session->tlsext_hostname[len] = '\0';
if (strlen(s->session->tlsext_hostname) != len) {
&& strncmp(s->session->tlsext_hostname,
&& strlen(s->session->tlsext_hostname) == len
0
---------------------------------
327 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 2078
V9fsString extension;
v9fs_string_init(&extension);
&perm, &mode, &extension);
int32_t ofid = atoi(extension.data);
0
---------------------------------
328 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cppfunc 2078
V9fsString extension;
v9fs_string_init(&extension);
&perm, &mode, &extension);
int32_t ofid = atoi(extension.data);
0
---------------------------------
329 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c inputfunc 1861
if ((bytes = recvfrom(fd, buffer, sizeof(buffer), 0, (void *)&addr,
&addrlen)) < 0)
bytes, addrname);
if (asn1_decode_snmp(buffer, bytes, &packet))
static int		asn1_decode_snmp(unsigned char *buffer, size_t len,
asn1_debug(buffer, bytes, 0);
asn1_debug(buffer, bytes, 0);
hex_debug(buffer, bytes);
static void		debug_printf(const char *format, ...);
static void		hex_debug(unsigned char *buffer, size_t len);
static void		asn1_debug(unsigned char *buffer, size_t len,
hex_debug(buffer, bytes);
0
---------------------------------
330 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1331
fprintf(stderr, "buffered messge: \ttype = %xx\n", msg_buf->type);
fprintf(stderr, "\t\t\t\t\tlen = %d\n", msg_buf->len);
fprintf(stderr, "\t\t\t\t\tseq_num = %d\n", msg_buf->seq_num);
0
---------------------------------
331 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1660
for (line_iterator line = begin_lines(), line_end = end_lines();
line->IsImpactedByFloat() ||
if (!line->IsBlock()) {
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
line->mBounds.XMost());
0
---------------------------------
332 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 2861
st = ic->streams[i];
av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
for (j = 1; j < MAX_STD_TIMEBASES; j++) {
AVRational std_fps = { get_std_framerate(j), 12*1001 };
av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
double error = fabs(av_q2d(st->avg_frame_rate) / av_q2d(std_fps) - 1);
static int get_std_framerate(int i){
if(i<60*12) return (i+1)*1001;
AVRational std_fps = { get_std_framerate(j), 12*1001 };
double error = fabs(av_q2d(st->avg_frame_rate) / av_q2d(std_fps) - 1);
0
---------------------------------
333 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cppfunc 6153
return nullptr;
FrameProperties props = Properties();
(props.Get(LineCursorProperty()));
nsLineBox* property = static_cast<nsLineBox*>
line_iterator cursor = mLines.begin(property);
nsRect cursorArea = cursor->GetVisualOverflowArea();
cursor = cursor.prev();
cursorArea = cursor->GetVisualOverflowArea();
cursor = cursor.next();
cursorArea = cursor->GetVisualOverflowArea();
if (cursor.get() != property) {
props.Set(LineCursorProperty(), cursor.get());
return cursor.get();
nullptr : GetFirstLineContaining(aDirtyRect.y);
nsLineBox* cursor = aBuilder->ShouldDescendIntoFrame(this) ?
for (line_iterator line = mLines.begin(cursor);
0
---------------------------------
334 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 178
PROCESS_INFORMATION pi = {0};
&pi);
&pi);
CloseHandle(pi.hThread);
0
---------------------------------
335 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc cfunc 250
SetState(kStateIncomplete);
_state == kStateIncomplete);
assert(_state == kStateEmpty ||
VCMFrameBuffer::SetState(VCMFrameBufferStateEnum state) {
_state = state;
SetState(kStateIncomplete);
SetState(kStateDecodable);
assert(_state == kStateEmpty ||
0
---------------------------------
336 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc cppfunc 250
SetState(kStateIncomplete);
_state == kStateIncomplete);
assert(_state == kStateEmpty ||
VCMFrameBuffer::SetState(VCMFrameBufferStateEnum state) {
_state = state;
SetState(kStateIncomplete);
SetState(kStateDecodable);
assert(_state == kStateEmpty ||
0
---------------------------------
337 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1598
const nsStyleText* styleText = GetStyleText();
IsAlignedLeft(styleText->mTextAlign,
styleText->mTextAlign);
0
---------------------------------
338 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cfunc 170
memset( p_chk, 0, sizeof( avi_chunk_t ) );
p_chk = malloc( sizeof( avi_chunk_t ) );
memset( p_chk, 0, sizeof( avi_chunk_t ) );
0
---------------------------------
339 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cppfunc 4118
aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y,
if (CRAZY_HEIGHT(aLine->mBounds.y)) {
lastHeight = aLine->mBounds.y;
if (abs(aLine->mBounds.y - lastHeight) > CRAZY_H/10) {
0
---------------------------------
340 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_maintenanceservice.cpp API 374
NULL, 0, NULL);
HANDLE thread = CreateThread(NULL, 0, StopServiceAndWaitForCommandThread,
CloseHandle(thread);
0
---------------------------------
341 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 1892
NS_ConvertUTF16toUTF8 autoIfname(aOptions.mIfname);
char key[PROPERTY_KEY_MAX];
snprintf(key, sizeof key - 1, "net.%s.gw", autoIfname.get());
0
---------------------------------
342 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 1483
char value[PROPERTY_VALUE_MAX];
property_get("ro.build.version.sdk", value, nullptr);
SDK_VERSION = atoi(value);
0
---------------------------------
343 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cppfunc 1483
char value[PROPERTY_VALUE_MAX];
property_get("ro.build.version.sdk", value, nullptr);
SDK_VERSION = atoi(value);
0
---------------------------------
344 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 1813
V9fsQID qid;
dent = g_malloc(sizeof(struct dirent));
err = v9fs_co_readdir_r(pdu, fidp, dent, &result);
size = MIN(sizeof(dent->d_ino), sizeof(qid.path));
qid.type = 0;
qid.version = 0;
&qid, dent->d_off,
memcpy(&qid.path, &dent->d_ino, size);
0
---------------------------------
345 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_serviceinstall.cpp cfunc 46
MaintenanceServiceStringTable serviceStrings;
int rv = ReadMaintenanceServiceStrings(updaterINIPath, &serviceStrings);
MaintenanceServiceStringTable *results)
strncpy(results->serviceDescription,
0
---------------------------------
346 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_serviceinstall.cpp API 572
SERVICE_STATUS status;
if (ControlService(schService, SERVICE_CONTROL_STOP, &status)) {
} while (QueryServiceStatus(schService, &status));
Sleep(status.dwWaitHint);
0
---------------------------------
347 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1478
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->make_and_model);
0
---------------------------------
348 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1478
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->make_and_model);
0
---------------------------------
349 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4715
const char *spec)
switch (*spec++) {
if (*spec++ == ':') {
int i, index = strtol(spec, NULL, 0);
0
---------------------------------
350 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4715
const char *spec)
switch (*spec++) {
if (*spec++ == ':') {
int i, index = strtol(spec, NULL, 0);
0
---------------------------------
351 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 232
static void Win32AddConnection( access_t *p_access, char *psz_path,
i_ret = asprintf( &psz_uri, "
free( psz_uri );
static int Open( vlc_object_t *p_this )
char         *psz_path, *psz_uri;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
i_ret = asprintf( &psz_uri, "
free( psz_uri );
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
i_ret = asprintf( &psz_uri, "
free( psz_uri );
0
---------------------------------
352 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 232
static void Win32AddConnection( access_t *p_access, char *psz_path,
i_ret = asprintf( &psz_uri, "
free( psz_uri );
static int Open( vlc_object_t *p_this )
char         *psz_path, *psz_uri;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
i_ret = asprintf( &psz_uri, "
free( psz_uri );
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
i_ret = asprintf( &psz_uri, "
free( psz_uri );
0
---------------------------------
353 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 176
PROCESS_INFORMATION pi = {0};
&pi);
&pi);
WaitForSingleObject(pi.hProcess, INFINITE);
0
---------------------------------
354 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_updatehelper.cpp API 177
PROCESS_INFORMATION pi = {0};
&pi);
&pi);
WaitForSingleObject(pi.hProcess, INFINITE);
CloseHandle(pi.hProcess);
0
---------------------------------
355 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 714
char *sep = strchr( folder, '/' );
*sep = '\0';
return findOrCreateParentNode( current, sep );
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
char *path = strdup( fullpath );
folder = path;
char *sep = strchr( folder, '/' );
if( !strcmp( current->name, folder ) )
0
---------------------------------
356 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 458
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
fprintf(out, " preserves-3d");
fputs("<\n", out);
line->List(out, aIndent, aFlags);
IndentBy(out, aIndent);
fputs("Overflow-lines<\n", out);
line->List(out, aIndent + 1, aFlags);
IndentBy(out, aIndent);
fputs(">\n", out);
IndentBy(out, aIndent);
fprintf(out, "%s<\n", mozilla::layout::ChildListName(lists.CurrentID()));
IndentBy(out, aIndent);
fputs(">\n", out);
0
---------------------------------
357 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 2623
if (SDK_VERSION >= 20) {
if (SDK_VERSION >= 20) {
#ifdef _DEBUG
NU_DBG("     ssid: %s", GET_CHAR(mSsid));
0
---------------------------------
358 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 451
ChildListIterator lists(this);
for (; !lists.IsDone(); lists.Next()) {
if (skip.Contains(lists.CurrentID())) {
IndentBy(out, aIndent);
kid->List(out, aIndent + 1, aFlags);
IndentBy(out, aIndent);
fputs(">\n", out);
nsFrameList::Enumerator childFrames(lists.CurrentList());
fprintf(out, "%s<\n", mozilla::layout::ChildListName(lists.CurrentID()));
0
---------------------------------
359 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c cfunc 2444
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
static int v9fs_complete_rename(V9fsPDU *pdu, V9fsFidState *fidp,
err = v9fs_co_rename(pdu, &fidp->path, &new_path);
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);
static int v9fs_path_is_ancestor(V9fsPath *s1, V9fsPath *s2)
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
0
---------------------------------
360 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1449
free_array(cups_array_t *a)
for (s = (char *)cupsArrayFirst(a); s; s = (char *)cupsArrayNext(a))
free(s);
0
---------------------------------
361 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1449
free_array(cups_array_t *a)
for (s = (char *)cupsArrayFirst(a); s; s = (char *)cupsArrayNext(a))
free(s);
0
---------------------------------
362 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 423
else  return first_iformat;
AVInputFormat *fmt1 = NULL, *fmt;
fmt = NULL;
while ((fmt1 = av_iformat_next(fmt1))) {
score = fmt1->read_probe(&lpd);
fmt = fmt1;
fmt = NULL;
return fmt;
AVInputFormat *fmt = av_probe_input_format3(pd, 1, &score);
pd->buf_size, MAX_PROBE_PACKETS - st->probe_packets, fmt->name, score);
if (!strcmp(fmt->name, fmt_id_type[i].name)) {
AVInputFormat  *av_iformat_next(AVInputFormat  *f)
if(f) return f->next;
while ((fmt1 = av_iformat_next(fmt1))) {
fmt = fmt1;
return fmt;
AVInputFormat *fmt = av_probe_input_format3(pd, 1, &score);
pd->buf_size, MAX_PROBE_PACKETS - st->probe_packets, fmt->name, score);
if (!strcmp(fmt->name, fmt_id_type[i].name)) {
0
---------------------------------
363 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 289
static void Win32AddConnection( access_t *p_access, char *psz_path,
i_ret = asprintf( &psz_uri, "
free( psz_uri );
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
i_ret = asprintf( &psz_uri, "
free( psz_uri );
static int Open( vlc_object_t *p_this )
char         *psz_path, *psz_uri;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
i_ret = asprintf( &psz_uri, "
free( psz_uri );
0
---------------------------------
364 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cppfunc 289
static void Win32AddConnection( access_t *p_access, char *psz_path,
i_ret = asprintf( &psz_uri, "
free( psz_uri );
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
i_ret = asprintf( &psz_uri, "
free( psz_uri );
static int Open( vlc_object_t *p_this )
char         *psz_path, *psz_uri;
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
i_ret = asprintf( &psz_uri, "
free( psz_uri );
0
---------------------------------
365 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 223
const size_t kH264NALHeaderLengthInBytes = 1;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
frame_buffer_ptr += Insert(nalu_ptr,
if (packets_.size() == kMaxPacketsInSession) {
ReversePacketIterator rit = packets_.rbegin();
for (; rit != packets_.rend(); ++rit)
if (rit != packets_.rend() &&
first_packet_seq_num_ = static_cast<int>(packet.seqNum);
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
packet.sizeBytes = Insert(packet_buffer,
size_t VCMSessionInfo::Insert(const uint8_t* buffer,
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
buffer,
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
nalu_ptr += length;
size_t length = BufferToUWord16(nalu_ptr);
frame_buffer_ptr += Insert(nalu_ptr,
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_))) {
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum)) {
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
packet.sizeBytes = Insert(packet_buffer,
int VCMSessionInfo::InsertPacket(const VCMPacket& packet,
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_)) {
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
packet.sizeBytes = Insert(packet_buffer,
0
---------------------------------
366 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 222
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,
packet.dataPtr = frame_buffer + offset;
const size_t kH264NALHeaderLengthInBytes = 1;
const size_t kLengthFieldLength = 2;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
nalu_ptr += kLengthFieldLength;
frame_buffer_ptr += Insert(nalu_ptr,
length,
const_cast<uint8_t*>(packet.dataPtr));
size_t length,
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_)) {
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
int VCMSessionInfo::InsertPacket(const VCMPacket& packet,
uint8_t* frame_buffer,
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum)) {
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
if (packets_.size() == kMaxPacketsInSession) {
ReversePacketIterator rit = packets_.rbegin();
for (; rit != packets_.rend(); ++rit)
if (rit != packets_.rend() &&
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
VCMPacket& packet = *packet_it;
size_t offset = 0;
offset += (*it).sizeBytes;
const uint8_t* packet_buffer = packet.dataPtr;
packet.dataPtr = frame_buffer + offset;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
uint8_t* frame_buffer_ptr = frame_buffer + offset;
nalu_ptr += length;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
const_cast<uint8_t*>(packet.dataPtr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
size_t VCMSessionInfo::Insert(const uint8_t* buffer,
buffer,
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
0
---------------------------------
367 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 220
const size_t kLengthFieldLength = 2;
nalu_ptr += kLengthFieldLength;
frame_buffer_ptr += Insert(nalu_ptr,
const unsigned char startCode[] = {0, 0, 0, 1};
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
uint8_t* frame_buffer,
if (packets_.size() == kMaxPacketsInSession) {
ReversePacketIterator rit = packets_.rbegin();
for (; rit != packets_.rend(); ++rit)
if (rit != packets_.rend() &&
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_))) {
first_packet_seq_num_ = static_cast<int>(packet.seqNum);
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum)) {
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_)) {
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
size_t offset = 0;
offset += (*it).sizeBytes;
const uint8_t* packet_buffer = packet.dataPtr;
packet.dataPtr = frame_buffer + offset;
const size_t kH264NALHeaderLengthInBytes = 1;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
uint8_t* frame_buffer_ptr = frame_buffer + offset;
nalu_ptr += length;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
const_cast<uint8_t*>(packet.dataPtr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,
packet.dataPtr = frame_buffer + offset;
const_cast<uint8_t*>(packet.dataPtr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
int VCMSessionInfo::InsertPacket(const VCMPacket& packet,
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
size_t VCMSessionInfo::Insert(const uint8_t* buffer,
buffer,
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
0
---------------------------------
368 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 194
stream_sys_t *p_sys;
s->p_sys = p_sys = calloc( 1, sizeof( *p_sys ) );
calloc( 1, sizeof( zlib_filefunc_def ) );
p_sys->fileFunctions = ( zlib_filefunc_def * )
free( p_sys );
0
---------------------------------
369 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 194
stream_sys_t *p_sys;
s->p_sys = p_sys = calloc( 1, sizeof( *p_sys ) );
calloc( 1, sizeof( zlib_filefunc_def ) );
p_sys->fileFunctions = ( zlib_filefunc_def * )
free( p_sys );
0
---------------------------------
370 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 297
static void split(char* str, const char* sep, nsTArray<nsCString>& result)
char *s = strtok(str, sep);
s = strtok(nullptr, sep);
0
---------------------------------
371 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 388
VmdVideoContext *s = avctx->priv_data;
vmd_decode(s);
static void vmd_decode(VmdVideoContext *s)
frame_x = AV_RL16(&s->buf[6]);
s->x_off = frame_x;
static void vmd_decode(VmdVideoContext *s)
vmd_decode(s);
memcpy(s->frame.data[1], s->palette, PALETTE_COUNT * 4);
0
---------------------------------
372 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 938
! memcmp( &oggpacket.packet[1], "FLAC", 4 ) &&
! memcmp( &oggpacket.packet[9], "fLaC", 4 ) )
! memcmp( oggpacket.packet, "\x80theora", 7 ) )
! memcmp( oggpacket.packet, "\x01vorbis", 7 ) )
! memcmp( oggpacket.packet, "Speex", 5 ) )
! memcmp( oggpacket.packet, "fLaC", 4 ) )
0
---------------------------------
373 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1659
if (line->IsBlock() ||
line->IsImpactedByFloat() ||
line->ResizeReflowOptimizationDisabled() ||
((isLastLine || !line->IsLineWrapped()) && !skipLastLine) ||
(!isLastLine && !line->HasBreakAfter()) ||
line->HasFloats() ||
line->MarkDirty();
if (!line->IsBlock()) {
line.get(), line->IsImpactedByFloat() ? "" : "not ");
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
static_cast<void*>((line.next() != end_lines() ? line.next().get() : nullptr)),
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
0
---------------------------------
374 CVE-2014-6431/Wireshark_1.12.0_CVE_2014_6431_wiretap_ngsniffer.c cfunc 775
struct vers_rec version;
struct tm tm;
bytes_read = file_read(&version, sizeof version, wth->fh);
if (bytes_read != sizeof version) {
start_date = pletoh16(&version.date);
tm.tm_year = ((start_date&DOS_YEAR_MASK)>>DOS_YEAR_SHIFT) + DOS_YEAR_OFFSET;
tm.tm_mon = ((start_date&DOS_MONTH_MASK)>>DOS_MONTH_SHIFT) + DOS_MONTH_OFFSET;
tm.tm_mday = ((start_date&DOS_DAY_MASK)>>DOS_DAY_SHIFT);
tm.tm_hour = 0;
tm.tm_min = 0;
tm.tm_sec = 0;
tm.tm_isdst = -1;
ngsniffer->start = mktime(&tm);
0
---------------------------------
375 CVE-2014-6431/Wireshark_1.12.0_CVE_2014_6431_wiretap_ngsniffer.c cppfunc 775
struct vers_rec version;
struct tm tm;
bytes_read = file_read(&version, sizeof version, wth->fh);
if (bytes_read != sizeof version) {
start_date = pletoh16(&version.date);
tm.tm_year = ((start_date&DOS_YEAR_MASK)>>DOS_YEAR_SHIFT) + DOS_YEAR_OFFSET;
tm.tm_mon = ((start_date&DOS_MONTH_MASK)>>DOS_MONTH_SHIFT) + DOS_MONTH_OFFSET;
tm.tm_mday = ((start_date&DOS_DAY_MASK)>>DOS_DAY_SHIFT);
tm.tm_hour = 0;
tm.tm_min = 0;
tm.tm_sec = 0;
tm.tm_isdst = -1;
ngsniffer->start = mktime(&tm);
0
---------------------------------
376 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1652
static_cast<void*>((line.next() != end_lines() ? line.next().get() : nullptr)),
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
line->IsImpactedByFloat() ||
line->ResizeReflowOptimizationDisabled() ||
((isLastLine || !line->IsLineWrapped()) && !skipLastLine) ||
(!isLastLine && !line->HasBreakAfter()) ||
line->HasFloats() ||
if (line->IsBlock() ||
if (!line->IsBlock()) {
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
0
---------------------------------
377 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1653
for (line_iterator line = begin_lines(), line_end = end_lines();
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
line->IsImpactedByFloat() ||
line->ResizeReflowOptimizationDisabled() ||
((isLastLine || !line->IsLineWrapped()) && !skipLastLine) ||
(!isLastLine && !line->HasBreakAfter()) ||
line->HasFloats() ||
if (line->IsBlock() ||
line->IsImpactedByFloat() ||
if (!line->IsBlock()) {
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
static_cast<void*>((line.next() != end_lines() ? line.next().get() : nullptr)),
0
---------------------------------
378 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 2777
st = ic->streams[i];
st->codec->time_base= st->time_base;
st->parser = av_parser_init(st->codec->codec_id);
avcodec_get_name(st->codec->codec_id));
avcodec_find_decoder(st->codec->codec_id);
st = ic->streams[i];
if (!has_codec_parameters(st, NULL))
st->info->fps_first_dts = st->info->fps_last_dts = AV_NOPTS_VALUE;
if (!has_codec_parameters(st, NULL))
st->info->fps_first_dts = st->info->fps_last_dts = AV_NOPTS_VALUE;
if (!has_codec_parameters(st, NULL))
st->info->fps_first_dts     = pkt->dts;
if (!has_codec_parameters(st, NULL))
st->info->fps_first_dts_idx = st->codec_info_nb_frames;
if (!has_codec_parameters(st, NULL))
st->info->fps_last_dts_idx = st->codec_info_nb_frames;
t = av_rescale_q(st->info->codec_info_duration, st->time_base, AV_TIME_BASE_Q);
st->info->codec_info_duration += pkt->duration;
if (!has_codec_parameters(st, NULL))
int64_t last = st->info->last_dts;
double dts= (is_relative(pkt->dts) ?  pkt->dts - RELATIVE_TS_BASE : pkt->dts) * av_q2d(st->time_base);
int64_t duration= pkt->dts - last;
for (i=0; i<FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
int framerate= get_std_framerate(i);
double sdts= dts*framerate/(1001*12);
for(j=0; j<2; j++){
int ticks= lrintf(sdts+j*0.5);
double error= sdts - ticks + j*0.5;
st->info->duration_error[j][0][i] += error;
for (i=0; i<FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
if (!has_codec_parameters(st, NULL))
st->info->duration_error[j][1][i] += error*error;
for (i=0; i<FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
if (!has_codec_parameters(st, NULL))
st->info->duration_count++;
if (!has_codec_parameters(st, NULL))
st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
if (!has_codec_parameters(st, NULL))
st->info->last_dts = pkt->dts;
if (!has_codec_parameters(st, NULL))
st = ic->streams[pkt->stream_index];
st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);
st->codec->extradata_size= i;
st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
static int has_codec_parameters(AVStream *st, const char **errmsg_ptr)
if (!has_codec_parameters(st, NULL))
if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)
static int tb_unreliable(AVCodecContext *c){
if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)
int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);
st->codec->extradata_size= i;
st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
static int is_relative(int64_t ts) {
st->info->fps_last_dts = pkt->dts;
if (!has_codec_parameters(st, NULL))
static int get_std_framerate(int i){
if(i<60*12) return (i+1)*1001;
int framerate= get_std_framerate(i);
double sdts= dts*framerate/(1001*12);
int ticks= lrintf(sdts+j*0.5);
double error= sdts - ticks + j*0.5;
st->info->duration_error[j][0][i] += error;
for (i=0; i<FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
if (!has_codec_parameters(st, NULL))
0
---------------------------------
379 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 381
uint8_t* frame_buffer,
size_t frame_buffer_length,
size_t new_length = 0;
(*it).dataPtr - frame_buffer;
fragmentation->fragmentationOffset[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
new_length += fragmentation->fragmentationLength[partition_id];
assert(new_length <= frame_buffer_length);
0
---------------------------------
380 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cppfunc 381
uint8_t* frame_buffer,
size_t frame_buffer_length,
size_t new_length = 0;
(*it).dataPtr - frame_buffer;
fragmentation->fragmentationOffset[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
new_length += fragmentation->fragmentationLength[partition_id];
assert(new_length <= frame_buffer_length);
0
---------------------------------
381 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 1342
process_rtsp_reply(tvbuff_t *tvb, int offset, const guchar *data,
const guchar *status   = data;
while (status < lineend && !isspace(*status))
status++;
while (status < lineend && !isspace(*status))
0
---------------------------------
382 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cppfunc 1342
process_rtsp_reply(tvbuff_t *tvb, int offset, const guchar *data,
const guchar *status   = data;
while (status < lineend && !isspace(*status))
status++;
while (status < lineend && !isspace(*status))
0
---------------------------------
383 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 543
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
i_num++;
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
char *psz_ret = malloc( i_len + 3*i_num + 2 );
for( psz_iter = (char*) psz_url, psz_tmp = psz_ret;
*(psz_tmp++) = '?';
snprintf( psz_tmp, 3, "%02x", ( *psz_iter & 0x000000FF ) );
*psz_tmp = *psz_iter;
snprintf( psz_tmp, 3, "%02x", ( *psz_iter & 0x000000FF ) );
psz_tmp++;
snprintf( psz_tmp, 3, "%02x", ( *psz_iter & 0x000000FF ) );
const char *psz_zippath )
char *psz_zip = strrchr( psz_zippath, DIR_SEP_CHAR );
escapeToXml( &psz_pathtozip, psz_zippath );
escapeToXml( &psz_escapedName, psz_name );
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
for( psz_iter = (char*) psz_url, psz_tmp = psz_ret;
if( isAllowedChar( *psz_iter ) )
*psz_tmp = *psz_iter;
snprintf( psz_tmp, 3, "%02x", ( *psz_iter & 0x000000FF ) );
static int WriteXSPF( char **pp_buffer, vlc_array_t *p_filenames,
for( int i = 0; i < vlc_array_count( p_filenames ); ++i )
char *psz_name = (char*) vlc_array_item_at_index( p_filenames, i );
int i_len = strlen( psz_name );
char *psz_file = strrchr( psz_name, '/' );
escapeToXml( &psz_escapedName, psz_name );
bool isAllowedChar( char c )
if( isAllowedChar( *psz_iter ) )
*psz_tmp = *psz_iter;
snprintf( psz_tmp, 3, "%02x", ( *psz_iter & 0x000000FF ) );
0
---------------------------------
384 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1480
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->addrname);
free(cache->uri);
free(cache->id);
free(cache->make_and_model);
free(cache);
0
---------------------------------
385 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1480
for (cache = (snmp_cache_t *)cupsArrayFirst(Devices);
cache = (snmp_cache_t *)cupsArrayNext(Devices))
free(cache->addrname);
free(cache->uri);
free(cache->id);
free(cache->make_and_model);
free(cache);
0
---------------------------------
386 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 3917
AVDictionaryEntry *tag=NULL;
while((tag=av_dict_get(m, "", tag, AV_DICT_IGNORE_SUFFIX))) {
if(strcmp("language", tag->key)){
av_log(ctx, AV_LOG_INFO, "%s  %-16s: ", indent, tag->key);
while((tag=av_dict_get(m, "", tag, AV_DICT_IGNORE_SUFFIX))) {
if(strcmp("language", tag->key)){
uint8_t *printed = ic->nb_streams ? av_mallocz(ic->nb_streams) : NULL;
dump_metadata(NULL, ic->metadata, "  ");
us = ic->duration % AV_TIME_BASE;
(100 * us) / AV_TIME_BASE);
us = abs(ic->start_time % AV_TIME_BASE);
AVChapter *ch = ic->chapters[i];
dump_metadata(NULL, ch->metadata, "    ");
dump_metadata(NULL, ic->programs[j]->metadata, "    ");
dump_stream_format(ic, ic->programs[j]->stream_index[k], index, is_output);
static void dump_stream_format(AVFormatContext *ic, int i, int index, int is_output)
AVStream *st = ic->streams[i];
AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL, 0);
dump_metadata(NULL, st->metadata, "    ");
dump_stream_format(ic, ic->programs[j]->stream_index[k], index, is_output);
static void dump_metadata(void *ctx, AVDictionary *m, const char *indent)
if(m && !(av_dict_count(m) == 1 && av_dict_get(m, "language", NULL, 0))){
while((tag=av_dict_get(m, "", tag, AV_DICT_IGNORE_SUFFIX))) {
if(strcmp("language", tag->key)){
0
---------------------------------
387 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 2444
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
static int v9fs_complete_rename(V9fsPDU *pdu, V9fsFidState *fidp,
err = v9fs_co_rename(pdu, &fidp->path, &new_path);
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);
static int v9fs_path_is_ancestor(V9fsPath *s1, V9fsPath *s2)
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
0
---------------------------------
388 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 1745
*pkt_buf_end = NULL;
free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
a = - 1;
m = (a + b) >> 1;
b = m;
a = m;
m= (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;
return -1;
return  m;
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
index= FFMAX(index, 0);
assert(index==0);
static void free_packet_buffer(AVPacketList **pkt_buf, AVPacketList **pkt_buf_end)
free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
static void flush_packet_queue(AVFormatContext *s)
flush_packet_queue(s);
void ff_read_frame_flush(AVFormatContext *s)
ff_read_frame_flush(s);
return ff_seek_frame_binary(s, stream_index, timestamp, flags);
int ff_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags)
st= s->streams[stream_index];
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,
b = nb_entries;
a= b-1;
m= (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
return  m;
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
index= FFMAX(index, 0);
assert(index==0);
0
---------------------------------
389 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 1745
*pkt_buf_end = NULL;
free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
a = - 1;
m = (a + b) >> 1;
b = m;
a = m;
m= (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;
return -1;
return  m;
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
index= FFMAX(index, 0);
assert(index==0);
static void free_packet_buffer(AVPacketList **pkt_buf, AVPacketList **pkt_buf_end)
free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
static void flush_packet_queue(AVFormatContext *s)
flush_packet_queue(s);
void ff_read_frame_flush(AVFormatContext *s)
ff_read_frame_flush(s);
return ff_seek_frame_binary(s, stream_index, timestamp, flags);
int ff_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags)
st= s->streams[stream_index];
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,
b = nb_entries;
a= b-1;
m= (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
return  m;
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
index= FFMAX(index, 0);
assert(index==0);
0
---------------------------------
390 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1779
linenum = 0;
while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
fprintf(stderr,
fprintf(stderr, "ERROR: Unknown directive %s on line %d of %s!\n",
fprintf(stderr, "ERROR: Missing value on line %d of %s!\n", linenum,
0
---------------------------------
391 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c cfunc 2105
V9fsString extension;
v9fs_string_init(&extension);
&perm, &mode, &extension);
char ctype;
uint32_t major, minor;
if (sscanf(extension.data, "%c %u %u", &ctype, &major, &minor) != 3) {
0
---------------------------------
392 CVE-2014-6431/Wireshark_1.12.0_CVE_2014_6431_wiretap_ngsniffer.c cfunc 2527
static int read_blob(FILE_T infile, ngsniffer_comp_stream_t *comp_stream,
comp_stream = &ngsniffer->rand;
comp_stream = &ngsniffer->seq;
if (read_blob(infile, comp_stream, err, err_info) < 0)
bytes_left = comp_stream->nbytes - comp_stream->nextout;
if (read_blob(infile, comp_stream, err, err_info) < 0)
bytes_left = comp_stream->nbytes - comp_stream->nextout;
bytes_to_copy = bytes_left;
memcpy(outbuffer, &comp_stream->buf[comp_stream->nextout],
bytes_to_copy);
copybytes -= bytes_to_copy;
bytes_to_copy = copybytes;
bytes_to_copy);
outbuffer += bytes_to_copy;
memcpy(outbuffer, &comp_stream->buf[comp_stream->nextout],
static int read_blob(FILE_T infile, ngsniffer_comp_stream_t *comp_stream,
if (read_blob(infile, comp_stream, err, err_info) < 0)
memcpy(outbuffer, &comp_stream->buf[comp_stream->nextout],
ng_file_read(void *buffer, unsigned int nbytes, wtap *wth, gboolean is_random,
unsigned int copybytes = nbytes;
unsigned char *outbuffer = (unsigned char *)buffer;
comp_stream = &ngsniffer->rand;
comp_stream->buf = (unsigned char *)g_malloc(OUTBUF_SIZE);
if (read_blob(infile, comp_stream, err, err_info) < 0)
if (read_blob(infile, comp_stream, err, err_info) < 0)
bytes_to_copy = copybytes;
memcpy(outbuffer, &comp_stream->buf[comp_stream->nextout],
bytes_to_copy);
outbuffer += bytes_to_copy;
memcpy(outbuffer, &comp_stream->buf[comp_stream->nextout],
comp_stream->nextout += bytes_to_copy;
bytes_left = comp_stream->nbytes - comp_stream->nextout;
bytes_to_copy = bytes_left;
bytes_to_copy);
outbuffer += bytes_to_copy;
memcpy(outbuffer, &comp_stream->buf[comp_stream->nextout],
0
---------------------------------
393 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 1749
*pkt_buf_end = NULL;
free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
a = - 1;
m = (a + b) >> 1;
b = m;
a = m;
m= (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;
return -1;
return  m;
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags & ~AVSEEK_FLAG_BACKWARD);
assert(index < st->nb_index_entries);
static void free_packet_buffer(AVPacketList **pkt_buf, AVPacketList **pkt_buf_end)
free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
static void flush_packet_queue(AVFormatContext *s)
flush_packet_queue(s);
void ff_read_frame_flush(AVFormatContext *s)
ff_read_frame_flush(s);
return ff_seek_frame_binary(s, stream_index, timestamp, flags);
int ff_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags)
st= s->streams[stream_index];
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
index= av_index_search_timestamp(st, target_ts, flags & ~AVSEEK_FLAG_BACKWARD);
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,
b = nb_entries;
a= b-1;
m= (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
return  m;
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags & ~AVSEEK_FLAG_BACKWARD);
assert(index < st->nb_index_entries);
0
---------------------------------
394 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 1749
*pkt_buf_end = NULL;
free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
a = - 1;
m = (a + b) >> 1;
b = m;
a = m;
m= (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;
return -1;
return  m;
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags & ~AVSEEK_FLAG_BACKWARD);
assert(index < st->nb_index_entries);
static void free_packet_buffer(AVPacketList **pkt_buf, AVPacketList **pkt_buf_end)
free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
static void flush_packet_queue(AVFormatContext *s)
flush_packet_queue(s);
void ff_read_frame_flush(AVFormatContext *s)
ff_read_frame_flush(s);
return ff_seek_frame_binary(s, stream_index, timestamp, flags);
int ff_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags)
st= s->streams[stream_index];
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags | AVSEEK_FLAG_BACKWARD);
index= av_index_search_timestamp(st, target_ts, flags & ~AVSEEK_FLAG_BACKWARD);
int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp,
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,
b = nb_entries;
a= b-1;
m= (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
return  m;
return ff_index_search_timestamp(st->index_entries, st->nb_index_entries,
index= av_index_search_timestamp(st, target_ts, flags & ~AVSEEK_FLAG_BACKWARD);
assert(index < st->nb_index_entries);
0
---------------------------------
395 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 434
ZIP_FILENAME_LEN, NULL, 0, NULL, 0 )
char *psz_fileName = calloc( ZIP_FILENAME_LEN, 1 );
free( psz_fileName );
0
---------------------------------
396 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 434
ZIP_FILENAME_LEN, NULL, 0, NULL, 0 )
char *psz_fileName = calloc( ZIP_FILENAME_LEN, 1 );
free( psz_fileName );
0
---------------------------------
397 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6889
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
0
---------------------------------
398 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6230
char buf[400];
PR_snprintf(buf, sizeof(buf),
printf("%s\n", buf);
0
---------------------------------
399 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 530
i_len++;
i_len++;
char *psz_ret = malloc( i_len + 3*i_num + 2 );
0
---------------------------------
400 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 741
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
int           indent)
fprintf(stderr, "DEBUG: %*sGet-Request-PDU %d bytes\n", indent, "",
asn1_debug(buffer, value_length, indent + 4);
fprintf(stderr, "DEBUG: %*sBOOLEAN %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sINTEGER %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sOCTET STRING %d bytes \"%s\"\n", indent, "",
fprintf(stderr, "DEBUG: %*sOID %d bytes ", indent, "",
fprintf(stderr, ".%d", oid[i]);
putc('\n', stderr);
fprintf(stderr, "DEBUG: %*sGet-Response-PDU %d bytes\n", indent, "",
fprintf(stderr, "DEBUG: %*sUNKNOWN(%x) %d bytes\n", indent, "",
fprintf(stderr, "DEBUG: %*sNULL VALUE %d bytes\n", indent, "",
0
---------------------------------
401 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1826
char		filename[1024],
if ((cups_serverroot = getenv("CUPS_SERVERROOT")) == NULL)
cups_serverroot = CUPS_SERVERROOT;
snprintf(filename, sizeof(filename), "%s/snmp.conf", cups_serverroot);
if ((fp = cupsFileOpen(filename, "r")) != NULL)
filename);
"line %d of %s!\n", linenum, filename);
line, linenum, filename);
filename);
0
---------------------------------
402 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1824
fprintf(stderr, "ERROR: Missing value on line %d of %s!\n", linenum,
fprintf(stderr,
fprintf(stderr, "ERROR: Unknown directive %s on line %d of %s!\n",
fprintf(stderr,
0
---------------------------------
403 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 570
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
s->tlsext_ellipticcurvelist_length);
ret += s->tlsext_ellipticcurvelist_length;
ticklen = s->session->tlsext_ticklen;
ticklen = s->tlsext_session_ticket->length;
s->session->tlsext_tick = OPENSSL_malloc(ticklen);
s->tlsext_session_ticket->data, ticklen);
ticklen = 0;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(ticklen, ret);
memcpy(ret, s->session->tlsext_tick, ticklen);
ret += ticklen;
if ((size_t)(limit - ret) < sizeof(tls12_sigalgs) + 6)
s2n(TLSEXT_TYPE_signature_algorithms, ret);
s2n(sizeof(tls12_sigalgs) + 2, ret);
s2n(sizeof(tls12_sigalgs), ret);
memcpy(ret, tls12_sigalgs, sizeof(tls12_sigalgs));
ret += sizeof(tls12_sigalgs);
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(col + 2, ret);
s2n(col, ret);
memcpy(ret, s->s3->client_opaque_prf_input, col);
0
---------------------------------
404 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c cfunc 876
printf("(%p, %zd)", sg[i].iov_base, sg[i].iov_len);
QEMUIOVector qiov;
qemu_iovec_init(&qiov, qiov_full.niov);
qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);
print_sg(qiov.iov, qiov.niov);
QEMUIOVector qiov;
qemu_iovec_init(&qiov, qiov_full.niov);
qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);
print_sg(qiov.iov, qiov.niov);
static void print_sg(struct iovec *sg, int cnt)
printf("sg[%d]: {", cnt);
printf("(%p, %zd)", sg[i].iov_base, sg[i].iov_len);
len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);
qemu_iovec_reset(&qiov);
print_sg(qiov.iov, qiov.niov);
len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);
qemu_iovec_reset(&qiov);
print_sg(qiov.iov, qiov.niov);
0
---------------------------------
405 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 576
buf[line_len] = '\0';
if ((tmp = strstr(buf, rtsp_sps))) {
if ((tmp = strstr(buf, rtsp_cps))) {
guint               s_data_chan, s_mon_chan;
if ((tmp = strstr(buf, rtsp_inter)) == NULL) {
tmp += strlen(rtsp_inter);
i = sscanf(tmp, "%u-%u", &s_data_chan, &s_mon_chan);
0
---------------------------------
406 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4334
int ff_hex_to_data(uint8_t *data, const char *p)
p += strspn(p, SPACE_CHARS);
c = toupper((unsigned char) *p++);
0
---------------------------------
407 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4334
int ff_hex_to_data(uint8_t *data, const char *p)
p += strspn(p, SPACE_CHARS);
c = toupper((unsigned char) *p++);
0
---------------------------------
408 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1377
header_length = DTLS1_CCS_HEADER_LENGTH;
header_length = DTLS1_HM_HEADER_LENGTH;
frag->msg_header.msg_len + header_length);
0
---------------------------------
409 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 1867
!memcmp( p_oggpacket->packet, "Annodex", 7 ) )
!memcmp( p_oggpacket->packet, "AnxData", 7 ) )
granule_rate_numerator = GetQWLE( &p_oggpacket->packet[8] );
granule_rate_denominator = GetQWLE( &p_oggpacket->packet[16] );
GetDWLE( &p_oggpacket->packet[24] );
content_type_string[0] = '\0';
uint8_t *p = memchr( &p_oggpacket->packet[42], '\r',
sscanf( (char*)(&p_oggpacket->packet[42]), "%1023s\r\n",
content_type_string );
if( !strncmp(content_type_string, "audio/x-wav", 11) )
else if( !strncmp(content_type_string, "audio/x-vorbis", 14) )
else if( !strncmp(content_type_string, "audio/x-speex", 13) )
else if( !strncmp(content_type_string, "video/x-theora", 14) )
else if( !strncmp(content_type_string, "video/x-xvid", 12) )
else if( !strncmp(content_type_string, "video/mpeg", 10) )
else if( !strncmp(content_type_string, "text/x-cmml", 11) )
0
---------------------------------
410 CVE-2013-0799/Firefox_19.0_CVE_2013_0799_toolkit_components_maintenanceservice_workmonitor.cpp API 211
PROCESS_INFORMATION pi = {0};
NULL, &si, &pi);
CloseHandle(pi.hThread);
0
---------------------------------
411 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c cfunc 871
QEMUIOVector qiov;
qemu_iovec_init(&qiov, qiov_full.niov);
print_sg(qiov.iov, qiov.niov);
QEMUIOVector qiov;
qemu_iovec_init(&qiov, qiov_full.niov);
qemu_iovec_reset(&qiov);
qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);
print_sg(qiov.iov, qiov.niov);
static void print_sg(struct iovec *sg, int cnt)
printf("sg[%d]: {", cnt);
len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);
qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);
qemu_iovec_reset(&qiov);
print_sg(qiov.iov, qiov.niov);
0
---------------------------------
412 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 918
V9fsString version;
v9fs_string_init(&version);
err = pdu_unmarshal(pdu, offset, "ds", &s->msize, &version);
trace_v9fs_version(pdu->tag, pdu->id, s->msize, version.data);
if (!strcmp(version.data, "9P2000.u")) {
} else if (!strcmp(version.data, "9P2000.L")) {
0
---------------------------------
413 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 2047
char	ifname[255];
strlcpy(ifname, address + 4, sizeof(ifname));
ifname[strlen(ifname) - 1] = '\0';
0
---------------------------------
414 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 2092
send_snmp_query(fd, &(addr->addr), SNMP_VERSION_1, community,
read_snmp_response(fd);
scan_devices(int fd)
FD_SET(fd, &input);
if (select(fd + 1, &input, NULL, NULL, &timeout) < 0)
fd, strerror(errno));
if (FD_ISSET(fd, &input))
FD_SET(fd, &input);
if (select(fd + 1, &input, NULL, NULL, &timeout) < 0)
fd, strerror(errno));
static void		read_snmp_response(int fd);
FD_SET(fd, &input);
if (select(fd + 1, &input, NULL, NULL, &timeout) < 0)
fd, strerror(errno));
static void		send_snmp_query(int fd, http_addr_t *addr, int version,
FD_SET(fd, &input);
if (select(fd + 1, &input, NULL, NULL, &timeout) < 0)
fd, strerror(errno));
0
---------------------------------
415 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 2091
DeviceTypeRequest, DeviceTypeOID);
const unsigned request_id,
const int *oid);
gettimeofday(&StartTime, NULL);
DeviceTypeRequest = StartTime.tv_sec;
DeviceDescRequest = StartTime.tv_sec + 1;
for (address = (char *)cupsArrayFirst(Addresses);
address = (char *)cupsArrayNext(Addresses))
fprintf(stderr, "ERROR: Unable to scan \"%s\"!\n", address);
for (community = (char *)cupsArrayFirst(Communities);
community = (char *)cupsArrayNext(Communities))
DeviceTypeRequest, DeviceTypeOID);
fprintf(stderr, "ERROR: %.3f select() for %d failed: %s\n", run_time(),
0
---------------------------------
416 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 463
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
fprintf(out, " preserves-3d");
fputs("<\n", out);
line->List(out, aIndent, aFlags);
IndentBy(out, aIndent);
fputs("Overflow-lines<\n", out);
line->List(out, aIndent + 1, aFlags);
IndentBy(out, aIndent);
fputs(">\n", out);
IndentBy(out, aIndent);
fprintf(out, "%s<\n", mozilla::layout::ChildListName(lists.CurrentID()));
kid->List(out, aIndent + 1, aFlags);
IndentBy(out, aIndent);
fputs(">\n", out);
IndentBy(out, aIndent);
fputs(">\n", out);
0
---------------------------------
417 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 999
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
sdbase = cg->spanDeps;
sdlimit = sdbase + cg->numSpanDeps;
offset = CG_OFFSET(cg);
growth = 0;
delta = 0;
JS_ASSERT(JT_HAS_TAG(sd->target));
sd->offset += delta;
sdtop = sd;
top = sd->top;
JS_ASSERT(top == sd->before);
span = SD_SPAN(sd, pivot);
ptrdiff_t deltaFromTop = 0;
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
sd2->offset += deltaFromTop;
deltaFromTop += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd2->offset += deltaFromTop;
sd2->offset += delta;
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
growth += delta;
passes, offset + growth, offset, growth);
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
passes, offset + growth, offset, growth);
JS_ASSERT(sd == sdlimit);
span = SD_SPAN(sd, pivot);
SET_JUMP_OFFSET(oldpc, span);
pc = base + sd->offset;
offset = sd->before + 1;
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
oldpc + 1 + JUMP_OFFSET_LEN,
memmove(pc + 1 + JUMPX_OFFSET_LEN,
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
JS_ASSERT(sd == sdlimit);
span = SD_SPAN(sd, pivot);
oldpc = base + sd->before;
pc = base + sd->offset;
memmove(pc + 1 + JUMPX_OFFSET_LEN,
oldpc + 1 + JUMP_OFFSET_LEN,
memmove(pc + 1 + JUMPX_OFFSET_LEN,
OptimizeSpanDeps(JSContext *cx, JSCodeGenerator *cg)
base = CG_BASE(cg);
size = BYTECODE_SIZE(PTRDIFF(limit, base, jsbytecode));
pc = base + sd->offset;
memmove(pc + 1 + JUMPX_OFFSET_LEN,
0
---------------------------------
418 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 2776
if(i<60*12) return (i+1)*1001;
st = ic->streams[i];
st->codec->time_base= st->time_base;
st->parser = av_parser_init(st->codec->codec_id);
avcodec_get_name(st->codec->codec_id));
avcodec_find_decoder(st->codec->codec_id);
st = ic->streams[i];
if (!has_codec_parameters(st, NULL))
st->info->fps_first_dts = st->info->fps_last_dts = AV_NOPTS_VALUE;
if (!has_codec_parameters(st, NULL))
st->info->fps_first_dts = st->info->fps_last_dts = AV_NOPTS_VALUE;
if (!has_codec_parameters(st, NULL))
st->info->fps_first_dts     = pkt->dts;
if (!has_codec_parameters(st, NULL))
st->info->fps_first_dts_idx = st->codec_info_nb_frames;
if (!has_codec_parameters(st, NULL))
st->info->fps_last_dts_idx = st->codec_info_nb_frames;
if (!has_codec_parameters(st, NULL))
t = av_rescale_q(st->info->codec_info_duration, st->time_base, AV_TIME_BASE_Q);
st->info->codec_info_duration += pkt->duration;
if (!has_codec_parameters(st, NULL))
int64_t last = st->info->last_dts;
double dts= (is_relative(pkt->dts) ?  pkt->dts - RELATIVE_TS_BASE : pkt->dts) * av_q2d(st->time_base);
int64_t duration= pkt->dts - last;
for (i=0; i<FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
int framerate= get_std_framerate(i);
double sdts= dts*framerate/(1001*12);
for(j=0; j<2; j++){
int ticks= lrintf(sdts+j*0.5);
double error= sdts - ticks + j*0.5;
st->info->duration_error[j][0][i] += error;
for (i=0; i<FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
if (!has_codec_parameters(st, NULL))
st->info->duration_error[j][1][i] += error*error;
for (i=0; i<FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
if (!has_codec_parameters(st, NULL))
st->info->duration_count++;
if (!has_codec_parameters(st, NULL))
st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
if (!has_codec_parameters(st, NULL))
st->info->last_dts = pkt->dts;
if (!has_codec_parameters(st, NULL))
st = ic->streams[pkt->stream_index];
st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);
st->codec->extradata_size= i;
st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
static int has_codec_parameters(AVStream *st, const char **errmsg_ptr)
if (!has_codec_parameters(st, NULL))
if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)
static int tb_unreliable(AVCodecContext *c){
if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)
int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);
st->codec->extradata_size= i;
st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
static int is_relative(int64_t ts) {
st->info->fps_last_dts = pkt->dts;
if (!has_codec_parameters(st, NULL))
static int get_std_framerate(int i){
if(i<60*12) return (i+1)*1001;
int framerate= get_std_framerate(i);
double sdts= dts*framerate/(1001*12);
int ticks= lrintf(sdts+j*0.5);
double error= sdts - ticks + j*0.5;
st->info->duration_error[j][0][i] += error;
for (i=0; i<FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
if (!has_codec_parameters(st, NULL))
0
---------------------------------
419 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 356
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
assert(fragmentation->fragmentationLength[partition_id] <=
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
0
---------------------------------
420 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cppfunc 356
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
assert(fragmentation->fragmentationLength[partition_id] <=
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
0
---------------------------------
421 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 224
size_t length = BufferToUWord16(nalu_ptr);
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
nalu_ptr += length;
length,
packet.sizeBytes +
(packet.insertStartCode ? kH264StartCodeLengthBytes : 0));
int steps_to_shift) {
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
packet.sizeBytes,
size_t length,
length);
0
---------------------------------
422 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 692
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
s->tlsext_ellipticcurvelist_length);
ret += s->tlsext_ellipticcurvelist_length;
ticklen = s->session->tlsext_ticklen;
ticklen = s->tlsext_session_ticket->length;
s->session->tlsext_tick = OPENSSL_malloc(ticklen);
s->tlsext_session_ticket->data, ticklen);
ticklen = 0;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(ticklen, ret);
memcpy(ret, s->session->tlsext_tick, ticklen);
ret += ticklen;
if ((size_t)(limit - ret) < sizeof(tls12_sigalgs) + 6)
s2n(TLSEXT_TYPE_signature_algorithms, ret);
s2n(sizeof(tls12_sigalgs) + 2, ret);
s2n(sizeof(tls12_sigalgs), ret);
memcpy(ret, tls12_sigalgs, sizeof(tls12_sigalgs));
ret += sizeof(tls12_sigalgs);
size_t col = s->s3->client_opaque_prf_input_len;
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(col + 2, ret);
s2n(col, ret);
memcpy(ret, s->s3->client_opaque_prf_input, col);
ret += col;
s2n(TLSEXT_TYPE_status_request, ret);
s2n(extlen + idlen + 5, ret);
*(ret++) = TLSEXT_STATUSTYPE_ocsp;
s2n(idlen, ret);
ret += 2;
itmp = i2d_OCSP_RESPID(id, &ret);
s2n(extlen, ret);
i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);
s2n(TLSEXT_TYPE_heartbeat, ret);
s2n(1, ret);
*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
*(ret++) = SSL_TLSEXT_HB_ENABLED;
s2n(TLSEXT_TYPE_next_proto_neg, ret);
s2n(0, ret);
int el;
ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);
s2n(TLSEXT_TYPE_use_srtp, ret);
s2n(el, ret);
if (ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) {
ret += el;
int hlen = ret - (unsigned char *)s->init_buf->data;
hlen -= 5;
hlen = 0x200 - hlen;
hlen -= 4;
hlen = 0;
s2n(TLSEXT_TYPE_padding, ret);
s2n(hlen, ret);
memset(ret, 0, hlen);
ret += hlen;
s2n(TLSEXT_TYPE_padding, ret);
s2n(hlen, ret);
memset(ret, 0, hlen);
0
---------------------------------
423 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 238
int index = 0;
if (!aChildIsBlock) index |= 1;
printf("record(%d): %02x %02x\n", index, record[0], record[1]);
0
---------------------------------
424 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 555
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
s->tlsext_ellipticcurvelist_length);
ret += s->tlsext_ellipticcurvelist_length;
ticklen = s->session->tlsext_ticklen;
ticklen = s->tlsext_session_ticket->length;
s->session->tlsext_tick = OPENSSL_malloc(ticklen);
s->tlsext_session_ticket->data, ticklen);
ticklen = 0;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(ticklen, ret);
memcpy(ret, s->session->tlsext_tick, ticklen);
ret += ticklen;
s2n(TLSEXT_TYPE_signature_algorithms, ret);
s2n(sizeof(tls12_sigalgs) + 2, ret);
s2n(sizeof(tls12_sigalgs), ret);
memcpy(ret, tls12_sigalgs, sizeof(tls12_sigalgs));
0
---------------------------------
425 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 429
int x0, int y0, int x1, int y1, int w, int h)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
width = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
DisplaySurface *surface = qemu_console_surface(s->vga.con);
int bypl = surface_stride(surface);
int bypp = surface_bytes_per_pixel(surface);
int width = bypp * w;
memmove(ptr[1], ptr[0], width);
0
---------------------------------
426 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4206
PRINT("stream #%d:\n", pkt->stream_index);
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
PRINT("  dts=");
PRINT("N/A");
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
PRINT("  pts=");
PRINT("N/A");
PRINT("%0.3f", pkt->pts * av_q2d(time_base));
PRINT("\n");
PRINT("  size=%d\n", pkt->size);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("  size=%d\n", pkt->size);
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
427 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4205
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("\n");
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
428 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7176
js_FinishTakingSrcNotes(JSContext *cx, JSCodeGenerator *cg, jssrcnote *notes)
JS_ASSERT(cg->current == &cg->main);
prologCount = cg->prolog.noteCount;
prologCount = cg->prolog.noteCount;
mainCount = cg->main.noteCount;
memcpy(notes, cg->prolog.notes, SRCNOTE_SIZE(prologCount));
memcpy(notes + prologCount, cg->main.notes, SRCNOTE_SIZE(mainCount));
SN_MAKE_TERMINATOR(&notes[totalCount]);
memcpy(notes + prologCount, cg->main.notes, SRCNOTE_SIZE(mainCount));
0
---------------------------------
429 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c cfunc 110
FILE            *fp,
fread(buf, 13, 1, fp);
if (gif_read_cmap(fp, ncolors, cmap, &gray))
static int	gif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,
fclose(fp);
0
---------------------------------
430 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4200
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("  pts=");
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
0
---------------------------------
431 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1350
va_list	ap;
va_start(ap, format);
vfprintf(stderr, format, ap);
va_end(ap);
0
---------------------------------
432 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cppfunc 1350
va_list	ap;
va_start(ap, format);
vfprintf(stderr, format, ap);
va_end(ap);
0
---------------------------------
433 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cppfunc 664
void NetworkUtils::clearWifiTetherParms(CommandChain* aChain,
NetworkResultOptions& aResult)
next(aChain, false, aResult);
0
---------------------------------
434 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4198
PRINT("stream #%d:\n", pkt->stream_index);
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
PRINT("  dts=");
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
435 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4196
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("N/A");
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
436 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4194
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("  dts=");
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
0
---------------------------------
437 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4192
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
438 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4191
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
0
---------------------------------
439 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4190
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("stream #%d:\n", pkt->stream_index);
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
440 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 614
void NetworkUtils::setAccessPoint(CommandChain* aChain,
nsCString ssid(GET_CHAR(mSsid));
escapeQuote(ssid);
aString.ReplaceSubstring("\\", "\\\\");
}
ssid.get(),
0
---------------------------------
441 CVE-2014-6431/Wireshark_1.12.0_CVE_2014_6431_wiretap_ngsniffer.c cfunc 587
char magic[sizeof ngsniffer_magic];
bytes_read = file_read(magic, sizeof magic, wth->fh);
if (bytes_read != sizeof magic) {
if (memcmp(magic, ngsniffer_magic, sizeof ngsniffer_magic)) {
0
---------------------------------
442 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4293
ls = strchr(p, '/');
ls2 = strchr(p, '?');
ls = ls2;
ls = FFMIN(ls, ls2);
av_strlcpy(path, ls, path_size);
ls = &p[strlen(p)];
if ((at = strchr(p, '@')) && at < ls) {
FFMIN(authorization_size, at + 1 - p));
p = at + 1;
if (*p == '[' && (brk = strchr(p, ']')) && brk < ls) {
} else if ((col = strchr(p, ':')) && col < ls) {
0
---------------------------------
443 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 343
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
0
---------------------------------
444 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 349
static void getIFProperties(const char* ifname, IFProperties& prop)
snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.gw", ifname);
property_get(key, prop.gateway, "");
snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.dns1", ifname);
0
---------------------------------
445 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 346
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
0
---------------------------------
446 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_serviceinstall.cpp cppfunc 203
LPCWSTR currentServicePath,
nsAutoArrayPtr<char> serviceConfigBuffer = new char[bytesNeeded];
reinterpret_cast<QUERY_SERVICE_CONFIGW*>(serviceConfigBuffer.get()),
*reinterpret_cast<QUERY_SERVICE_CONFIGW*>(serviceConfigBuffer.get());
QUERY_SERVICE_CONFIGW &serviceConfig =
if (!FixServicePath(schService, serviceConfig.lpBinaryPathName,
size_t currentServicePathLen = wcslen(currentServicePath);
!wcsstr(currentServicePath, L"maintenanceservice_tmp.exe") &&
currentServicePath));
WCHAR fixedPath[MAX_PATH + 1] = { L'\0' };
wcsncpy(fixedPath, currentServicePath, MAX_PATH);
0
---------------------------------
447 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 641
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
i_num++;
*ppsz_encoded = malloc( i_len + 1 );
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
char *psz_ret = malloc( i_len + 3*i_num + 2 );
*ppsz_encoded = psz_ret;
char *psz_pathtozip;
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
free( psz_pathtozip );
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
free( psz_pathtozip );
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
escapeToXml( &psz_pathtozip, psz_zippath );
free( psz_pathtozip );
0
---------------------------------
448 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 641
va_list args;
va_start( args, psz_fmt_src );
char *psz_tmp;
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
char *psz_out = realloc( *ppsz_dest, i_len );
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
size_t i_num = 0, i_len = 0;
i_len++;
i_len++;
i_num++;
*ppsz_encoded = malloc( i_len + 1 );
memcpy( *ppsz_encoded, psz_url, i_len + 1 );
char *psz_ret = malloc( i_len + 3*i_num + 2 );
*ppsz_encoded = psz_ret;
char *psz_pathtozip;
escapeToXml( &psz_pathtozip, psz_zippath );
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
char *psz_path = strdup( psz_pathtozip );
free( psz_pathtozip );
static int astrcatf( char **ppsz_dest, const char *psz_fmt_src, ... )
va_start( args, psz_fmt_src );
int i_ret = vasprintf( &psz_tmp, psz_fmt_src, args );
int i_len = strlen( *ppsz_dest ) + strlen( psz_tmp ) + 1;
strcat( psz_out, psz_tmp );
*ppsz_dest = psz_out;
if( astrcatf( &psz_pathtozip, "%s", ZIP_SEP ) < 0 ) return -1;
free( psz_pathtozip );
static int escapeToXml( char **ppsz_encoded, const char *psz_url )
escapeToXml( &psz_pathtozip, psz_zippath );
free( psz_pathtozip );
0
---------------------------------
449 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_components_maintenanceservice_serviceinstall.cpp cppfunc 364
WCHAR newServiceBinaryPath[MAX_PATH + 1];
if (!GetModuleFileNameW(NULL, newServiceBinaryPath,
if (!GetVersionNumberFromPath(newServiceBinaryPath, newA,
GetVersionNumberFromPath(LPWSTR path, DWORD &A, DWORD &B,
DWORD fileVersionInfoSize = GetFileVersionInfoSizeW(path, 0);
if (!GetFileVersionInfoW(path, 0, fileVersionInfoSize,
if (!wcscmp(newServiceBinaryPath, serviceConfig.lpBinaryPathName)) {
0
---------------------------------
450 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4109
return av_guess_format("image2", NULL, NULL);
oformat = av_guess_format(format, NULL, NULL);
AVOutputFormat *oformat, const char *filename)
int ret = avformat_alloc_output_context2(&avctx, oformat, format, filename);
const char *format, const char *filename)
oformat = av_guess_format(NULL, filename, NULL);
int av_filename_number_test(const char *filename)
return filename && (av_get_frame_filename(buf, sizeof(buf), filename, 1)>=0);
const char *path, int number)
p = path;
c = *p++;
nd = 0;
while (isdigit(*p)) {
nd = nd * 10 + *p++ - '0';
while (isdigit(*p)) {
int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
if ((ret = init_input(s, filename, &tmp)) < 0)
static int init_input(AVFormatContext *s, const char *filename, AVDictionary **options)
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
const char *filename, void *logctx,
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
if ((ret = avio_open2(&s->pb, filename, AVIO_FLAG_READ | s->avio_flags,
if (!av_filename_number_test(filename)) {
AVOutputFormat *av_guess_format(const char *short_name, const char *filename,
ff_guess_image2_codec(filename) != AV_CODEC_ID_NONE) {
av_filename_number_test(filename) &&
0
---------------------------------
451 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4109
return av_guess_format("image2", NULL, NULL);
oformat = av_guess_format(format, NULL, NULL);
AVOutputFormat *oformat, const char *filename)
int ret = avformat_alloc_output_context2(&avctx, oformat, format, filename);
const char *format, const char *filename)
oformat = av_guess_format(NULL, filename, NULL);
int av_filename_number_test(const char *filename)
return filename && (av_get_frame_filename(buf, sizeof(buf), filename, 1)>=0);
const char *path, int number)
p = path;
c = *p++;
nd = 0;
while (isdigit(*p)) {
nd = nd * 10 + *p++ - '0';
while (isdigit(*p)) {
int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
if ((ret = init_input(s, filename, &tmp)) < 0)
static int init_input(AVFormatContext *s, const char *filename, AVDictionary **options)
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
const char *filename, void *logctx,
return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, s->probesize);
if ((ret = avio_open2(&s->pb, filename, AVIO_FLAG_READ | s->avio_flags,
if (!av_filename_number_test(filename)) {
AVOutputFormat *av_guess_format(const char *short_name, const char *filename,
ff_guess_image2_codec(filename) != AV_CODEC_ID_NONE) {
av_filename_number_test(filename) &&
0
---------------------------------
452 CVE-2015-4517/Firefox_40.0b9_CVE_2015_4517_dom_system_gonk_NetworkUtils.cpp cfunc 810
char buf[BUF_SIZE];
NS_ConvertUTF16toUTF8 reason(aResult.mResultReason);
memcpy(buf, reason.get(), reason.Length() + 1);
0
---------------------------------
453 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1211
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
data += size;
n2s(data, size);
fprintf(stderr, "%i ", *(sdata++));
fprintf(stderr, "\n");
fprintf(stderr, "Received extension type %d size %d\n", type, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
ellipticcurvelist_length += (*(sdata++));
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
fprintf(stderr,
sdata = s->session->tlsext_ellipticcurvelist;
fprintf(stderr, "%i ", *(sdata++));
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
sdata = s->session->tlsext_ellipticcurvelist;
fprintf(stderr, "%i ", *(sdata++));
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
sdata = s->session->tlsext_ellipticcurvelist;
fprintf(stderr, "%i ", *(sdata++));
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
sdata = s->session->tlsext_ellipticcurvelist;
fprintf(stderr, "%i ", *(sdata++));
0
---------------------------------
454 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 202
while ((p = strchr(names, ','))) {
len = FFMAX(p - names, namelen);
if (!av_strncasecmp(name, names, len))
names = p+1;
while ((p = strchr(names, ','))) {
return !av_strcasecmp(name, names);
if (fmt->name && short_name && match_format(short_name, fmt->name))
if (match_format(short_name, fmt->name))
static int match_format(const char *name, const char *names)
while ((p = strchr(names, ','))) {
0
---------------------------------
455 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c cfunc 476
static void Win32AddConnection( access_t *p_access, char *psz_path,
strlcpy( psz_server, psz_path, sizeof( psz_server ) );
psz_parser = strchr( psz_path, '/' );
char *psz_parser2 = strchr( ++psz_parser, '/' );
static int Open( vlc_object_t *p_this )
psz_path = strchr( p_access->psz_path, '/' );
char *psz_tmp = strdup( p_access->psz_path );
psz_tmp[ psz_path - p_access->psz_path ] = 0;
psz_path = p_access->psz_path;
psz_parser = strchr( psz_tmp, '@' );
*psz_parser = 0;
psz_path = p_access->psz_path + (psz_parser - psz_tmp) + 1;
Win32AddConnection( p_access, psz_path, psz_user, psz_pwd, psz_domain);
0
---------------------------------
456 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1552
fputs("DEBUG: Hex dump of packet:\n", stderr);
fprintf(stderr, "DEBUG: %04X ", col);
fprintf(stderr, " %02X", *buffer);
putc('\n', stderr);
0
---------------------------------
457 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 1556
fputs("DEBUG: Hex dump of packet:\n", stderr);
fprintf(stderr, "DEBUG: %04X ", col);
fprintf(stderr, " %02X", *buffer);
putc('\n', stderr);
putc('\n', stderr);
0
---------------------------------
458 CVE-2016-2842/OpenSSL_1.0.1_CVE-2016-2842_b_print.c cfunc 522
const char *prefix = "";
if (base == 8) prefix = "0";
if (base == 16) prefix = "0x";
spadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix);
0
---------------------------------
459 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 698
node *n = (node*) calloc( 1, sizeof(node) );
return n;
char *sep = strchr( folder, '/' );
*sep = '\0';
node *current = root->child;
if( !strcmp( current->name, folder ) )
return findOrCreateParentNode( current, sep );
current = current->next;
return findOrCreateParentNode( current, sep );
node *ret = new_node( folder );
node *n = (node*) calloc( 1, sizeof(node) );
return n;
node *ret = new_node( folder );
root->child = ret;
return findOrCreateParentNode( current, sep );
node *ret = new_node( folder );
ret = findOrCreateParentNode( ret, sep );
return ret;
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
char *path = strdup( fullpath );
folder = path;
assert( root );
char *sep = strchr( folder, '/' );
return root;
node *ret = new_node( folder );
ret = findOrCreateParentNode( ret, sep );
inline static node* new_node( char *name )
n->name = convert_xml_special_chars( name );
return n;
node *ret = new_node( folder );
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
assert( root );
0
---------------------------------
460 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 698
node *n = (node*) calloc( 1, sizeof(node) );
return n;
char *sep = strchr( folder, '/' );
*sep = '\0';
node *current = root->child;
if( !strcmp( current->name, folder ) )
return findOrCreateParentNode( current, sep );
current = current->next;
return findOrCreateParentNode( current, sep );
node *ret = new_node( folder );
node *n = (node*) calloc( 1, sizeof(node) );
return n;
node *ret = new_node( folder );
root->child = ret;
return findOrCreateParentNode( current, sep );
node *ret = new_node( folder );
ret = findOrCreateParentNode( ret, sep );
return ret;
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
char *path = strdup( fullpath );
folder = path;
assert( root );
char *sep = strchr( folder, '/' );
return root;
node *ret = new_node( folder );
ret = findOrCreateParentNode( ret, sep );
inline static node* new_node( char *name )
n->name = convert_xml_special_chars( name );
return n;
node *ret = new_node( folder );
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
assert( root );
0
---------------------------------
461 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1047
int dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen)
sender, slen,
i = s->method->ssl3_enc->final_finish_mac(s,
s->s3->tmp.finish_md);
i = s->method->ssl3_enc->final_finish_mac(s,
memcpy(p, s->s3->tmp.finish_md, i);
OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
memcpy(s->s3->previous_client_finished, s->s3->tmp.finish_md, i);
0
---------------------------------
462 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 1448
static void Ogg_LogicalStreamDelete( demux_t *p_demux, logical_stream_t *p_stream )
es_out_Del( p_demux->out, p_stream->p_es );
ogg_stream_clear( &p_stream->os );
free( p_stream->p_headers );
es_format_Clean( &p_stream->fmt_old );
es_format_Clean( &p_stream->fmt );
oggseek_index_entries_free( p_stream->idx );
free( p_stream );
0
---------------------------------
463 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cppfunc 1448
static void Ogg_LogicalStreamDelete( demux_t *p_demux, logical_stream_t *p_stream )
es_out_Del( p_demux->out, p_stream->p_es );
ogg_stream_clear( &p_stream->os );
free( p_stream->p_headers );
es_format_Clean( &p_stream->fmt_old );
es_format_Clean( &p_stream->fmt );
oggseek_index_entries_free( p_stream->idx );
free( p_stream );
0
---------------------------------
464 CVE-2014-6427/Wireshark_1.12.0_CVE_2014_6427_epan_dissectors_packet-rtsp.c cfunc 550
buf[line_len] = '\0';
c_data_port = c_mon_port = 0;
if ((tmp = strstr(buf, rtsp_sps))) {
if ((tmp = strstr(buf, rtsp_cps))) {
tmp += strlen(rtsp_cps);
if (sscanf(tmp, "%u-%u", &c_data_port, &c_mon_port) < 1) {
0
---------------------------------
465 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 463
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
0
---------------------------------
466 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 1084
uint64_t data, unsigned size)
vmsvga_bios_write(s, addr, data);
static void vmsvga_bios_write(void *opaque, uint32_t address, uint32_t data)
printf("%s: what are we supposed to do with (%08x)?\n", __func__, data);
0
---------------------------------
467 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 481
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
int width = surface_bytes_per_pixel(surface) * w;
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
x = vmsvga_fifo_read(s);
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
uint32_t c, int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
if (x + w > surface_width(surface)) {
name, surface_width(surface), x, w);
fprintf(stderr, "%s: y was < 0 (%d)\n", name, y);
fprintf(stderr, "%s: y was > %d (%d)\n", name, SVGA_MAX_HEIGHT, y);
if (y + h > surface_height(surface)) {
name, surface_height(surface), y, h);
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
width = vmsvga_fifo_read(s);
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
uint32_t c, int x, int y, int w, int h)
DisplaySurface *surface = qemu_console_surface(s->vga.con);
int bypl = surface_stride(surface);
int width = surface_bytes_per_pixel(surface) * w;
fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;
dst = fst;
dst += bypl;
memcpy(dst, fst, width);
static inline bool vmsvga_verify_rect(DisplaySurface *surface,
fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;
dst = fst;
memcpy(dst, fst, width);
0
---------------------------------
468 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c cfunc 177
path->data = NULL;
path->size = 0;
if (!strncmp(s1->data, s2->data, s1->size - 1)) {
err = v9fs_co_open(pdu, f, f->open_flags);
err = v9fs_co_opendir(pdu, f);
for (f = s->fid_list; f; f = f->next) {
BUG_ON(f->clunked);
f->ref++;
err = v9fs_reopen_fid(pdu, f);
return NULL;
f->flags |= FID_REFERENCED;
return f;
return NULL;
err = v9fs_co_rename(pdu, &fidp->path, &new_path);
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);
V9fsPath oldpath, newpath;
v9fs_path_init(&oldpath);
v9fs_co_name_to_path(pdu, olddir, old_name->data, &oldpath);
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
v9fs_fix_path(&tfidp->path, &newpath, strlen(oldpath.data));
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);
static int v9fs_complete_rename(V9fsPDU *pdu, V9fsFidState *fidp,
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
static int v9fs_path_is_ancestor(V9fsPath *s1, V9fsPath *s2)
if (!strncmp(s1->data, s2->data, s1->size - 1)) {
if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {
void v9fs_path_init(V9fsPath *path)
v9fs_path_init(&oldpath);
if (v9fs_path_is_ancestor(&oldpath, &tfidp->path)) {
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
err = v9fs_reopen_fid(pdu, f);
return f;
fidp = get_fid(pdu, fid);
err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);
0
---------------------------------
469 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 5415
line = line_end;
TryAllLines(&line, &line_start, &line_end, &searchingOverflowList,
nsBlockFrame::TryAllLines(nsLineList::iterator* aIterator,
TryAllLines(&line, &line_start, &line_end, &searchingOverflowList,
searchingOverflowList?"overflow":"normal", line.get());
NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
bool isLastFrameOnLine = 1 == line->GetChildCount();
if (line != line_end && !line->IsBlock()) {
line->NoteFrameRemoved(aDeletedFrame);
searchingOverflowList?"overflow":"normal", line.get());
if (0 == line->GetChildCount()) {
searchingOverflowList?"overflow":"normal", line.get());
0
---------------------------------
470 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c cfunc 243
FILE            *fp,
fread(buf, 13, 1, fp);
if (gif_read_cmap(fp, ncolors, cmap, &gray))
buf[0] = getc(fp);
gif_get_block(fp, buf);
while (gif_get_block(fp, buf) != 0);
fread(buf, 9, 1, fp);
if (gif_read_cmap(fp, ncolors, cmap, &gray))
fclose(fp);
static int	gif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,
fread(buf, 9, 1, fp);
fclose(fp);
static int	gif_get_block(FILE *fp, unsigned char *buffer);
while (gif_get_block(fp, buf) != 0);
fread(buf, 9, 1, fp);
fclose(fp);
0
---------------------------------
471 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c cfunc 242
FILE            *fp,
unsigned char	buf[1024];
fread(buf, 13, 1, fp);
img->xsize = (buf[7] << 8) | buf[6];
img->ysize = (buf[9] << 8) | buf[8];
if (gif_read_cmap(fp, ncolors, cmap, &gray))
buf[0] = getc(fp);
gif_get_block(fp, buf);
while (gif_get_block(fp, buf) != 0);
fread(buf, 9, 1, fp);
img->xsize = (buf[5] << 8) | buf[4];
img->ysize = (buf[7] << 8) | buf[6];
img->xsize = (buf[5] << 8) | buf[4];
img->ysize = (buf[7] << 8) | buf[6];
img->xsize, img->ysize);
static int	gif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,
fread(buf, 9, 1, fp);
img->xsize = (buf[5] << 8) | buf[4];
img->ysize = (buf[7] << 8) | buf[6];
img->xsize, img->ysize);
static int	gif_get_block(FILE *fp, unsigned char *buffer);
while (gif_get_block(fp, buf) != 0);
fread(buf, 9, 1, fp);
img->xsize = (buf[5] << 8) | buf[4];
img->ysize = (buf[7] << 8) | buf[6];
img->xsize, img->ysize);
static int	gif_get_block(FILE *fp, unsigned char *buffer);
fread(buf, 9, 1, fp);
img->xsize = (buf[5] << 8) | buf[4];
img->xsize, img->ysize);
0
---------------------------------
472 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 313
ogg_packet  oggpacket;
while( ogg_stream_packetout( &p_stream->os, &oggpacket ) > 0 )
! memcmp( oggpacket.packet, "\x80theora", 7 ) )
! memcmp( oggpacket.packet, "\x01vorbis", 7 ) )
Ogg_DecodePacket( p_demux, p_stream, &oggpacket );
Ogg_DecodePacket( p_demux, p_stream, &oggpacket );
static void Ogg_DecodePacket ( demux_t *, logical_stream_t *, ogg_packet * );
Ogg_DecodePacket( p_demux, p_stream, &oggpacket );
! memcmp( oggpacket.packet, "\x80theora", 7 ) )
! memcmp( oggpacket.packet, "\x01vorbis", 7 ) )
if( ogg_stream_packetout( &p_stream->os, &oggpacket ) > 0 )
Ogg_UpdatePCR( p_stream, &oggpacket );
Ogg_DecodePacket( p_demux, p_stream, &oggpacket );
! memcmp( oggpacket.packet, "\x80theora", 7 ) )
! memcmp( oggpacket.packet, "\x01vorbis", 7 ) )
static void Ogg_UpdatePCR    ( logical_stream_t *, ogg_packet * );
Ogg_UpdatePCR( p_stream, &oggpacket );
Ogg_ReadVorbisHeader( p_stream, &oggpacket );
static void Ogg_ReadVorbisHeader( logical_stream_t *, ogg_packet * );
Ogg_ReadVorbisHeader( p_stream, &oggpacket );
Ogg_ReadTheoraHeader( p_stream, &oggpacket );
static void Ogg_ReadTheoraHeader( logical_stream_t *, ogg_packet * );
Ogg_ReadTheoraHeader( p_stream, &oggpacket );
! memcmp( oggpacket.packet, "\x80theora", 7 ) )
! memcmp( oggpacket.packet, "\x01vorbis", 7 ) )
0
---------------------------------
473 CVE-2011-2588/vlc_media_player_0.9.9_CVE-2011-2588_libavi.c cppfunc 627
static int AVI_ChunkRead_strz( stream_t *s, avi_chunk_t *p_chk )
AVI_READCHUNK_ENTER;
p_strz->p_str = malloc( i_read + 1);
0
---------------------------------
474 CVE-2013-1706/Firefox_22.0b6_CVE_2013_1706_toolkit_mozapps_update_common_pathhash.cpp cppfunc 134
LPCWSTR baseRegPath = L"SOFTWARE\\Mozilla\\"
wcsncpy(registryPath, baseRegPath, MAX_PATH);
registryPath + wcslen(baseRegPath));
0
---------------------------------
475 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cfunc 1758
p_stream->fmt.psz_description[15] = 0;
psz_desc = strdup(FindKateCategoryName(p_stream->fmt.psz_description));
free( p_stream->fmt.psz_description );
0
---------------------------------
476 CVE-2012-3377/vlc_media_player_2.0.0_CVE-2012-3377_ogg.c cppfunc 1758
p_stream->fmt.psz_description[15] = 0;
psz_desc = strdup(FindKateCategoryName(p_stream->fmt.psz_description));
free( p_stream->fmt.psz_description );
0
---------------------------------
477 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 521
const char *mBuf;
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
return sizeof(local_file_header) + letoh16(filename_size) +
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
descCopy.append(file->GetData(), entry->GetDataSize());
int32_t width, height, fps;
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
0
---------------------------------
478 CVE-2011-2896/cups_1.4.2_CVE-2011-2896_image-gif.c cfunc 248
FILE            *fp,
fread(buf, 13, 1, fp);
if (gif_read_cmap(fp, ncolors, cmap, &gray))
buf[0] = getc(fp);
gif_get_block(fp, buf);
while (gif_get_block(fp, buf) != 0);
fread(buf, 9, 1, fp);
if (gif_read_cmap(fp, ncolors, cmap, &gray))
i = gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE);
static int	gif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,
fread(buf, 9, 1, fp);
i = gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE);
static int	gif_read_image(FILE *fp, cups_image_t *img, gif_cmap_t cmap,
fclose(fp);
static int	gif_get_block(FILE *fp, unsigned char *buffer);
while (gif_get_block(fp, buf) != 0);
fread(buf, 9, 1, fp);
i = gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE);
static int	gif_get_block(FILE *fp, unsigned char *buffer);
fread(buf, 9, 1, fp);
i = gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE);
0
---------------------------------
479 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 782
fprintf(stderr, "DEBUG: %*sSEQUENCE %d bytes\n", indent, "",
asn1_debug(buffer, value_length, indent + 4);
fprintf(stderr, "DEBUG: %*sGet-Request-PDU %d bytes\n", indent, "",
asn1_debug(buffer, value_length, indent + 4);
asn1_debug(buffer, value_length, indent + 4);
int           indent)
fprintf(stderr, "DEBUG: %*sBOOLEAN %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sINTEGER %d bytes %d\n", indent, "",
fprintf(stderr, "DEBUG: %*sOCTET STRING %d bytes \"%s\"\n", indent, "",
fprintf(stderr, "DEBUG: %*sOID %d bytes ", indent, "",
fprintf(stderr, ".%d", oid[i]);
putc('\n', stderr);
fprintf(stderr, "DEBUG: %*sGet-Response-PDU %d bytes\n", indent, "",
fprintf(stderr, "DEBUG: %*sUNKNOWN(%x) %d bytes\n", indent, "",
0
---------------------------------
480 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 783
value_type   = asn1_get_type(&buffer, bufend);
value_length = asn1_get_length(&buffer, bufend);
value_type, value_length);
0
---------------------------------
481 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4276
const char *url)
if ((p = strchr(url, ':'))) {
av_strlcpy(proto, url, FFMIN(proto_size, p + 1 - url));
p++;
if (*p == '/') p++;
if (*p == '/') p++;
ls = strchr(p, '/');
ls2 = strchr(p, '?');
ls = &p[strlen(p)];
0
---------------------------------
482 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cppfunc 4036
us = ic->duration % AV_TIME_BASE;
(100 * us) / AV_TIME_BASE);
us = abs(ic->start_time % AV_TIME_BASE);
0
---------------------------------
483 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1038
d = (unsigned char *)s->init_buf->data;
p = &(d[DTLS1_HM_HEADER_LENGTH]);
memcpy(p, s->s3->tmp.finish_md, i);
0
---------------------------------
484 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 132
node *n = (node*) calloc( 1, sizeof(node) );
return n;
free( root->name );
free( root );
psz_zip = convert_xml_special_chars( psz_zip ? (psz_zip+1) : psz_zippath );
" <trackList>\n", psz_zip ) == -1)
node *playlist = new_node( psz_zip );
node *parent = findOrCreateParentNode( playlist, psz_name );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
free_all_node( playlist );
inline static void free_all_node( node *root )
free( root );
free_all_node( playlist );
inline static void free_all_node( node *root )
free_all_node( root->child );
inline static void free_all_node( node *root )
node *tmp = root->next;
root = tmp;
free( root );
inline static node* new_node( char *name )
n->name = convert_xml_special_chars( name );
return n;
node *playlist = new_node( psz_zip );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
free_all_node( playlist );
static node* findOrCreateParentNode( node *root, const char *fullpath );
node *parent = findOrCreateParentNode( playlist, psz_name );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
free_all_node( playlist );
0
---------------------------------
485 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 132
node *n = (node*) calloc( 1, sizeof(node) );
return n;
free( root->name );
free( root );
psz_zip = convert_xml_special_chars( psz_zip ? (psz_zip+1) : psz_zippath );
" <trackList>\n", psz_zip ) == -1)
node *playlist = new_node( psz_zip );
node *parent = findOrCreateParentNode( playlist, psz_name );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
free_all_node( playlist );
inline static void free_all_node( node *root )
free( root );
free_all_node( playlist );
inline static void free_all_node( node *root )
free_all_node( root->child );
inline static void free_all_node( node *root )
node *tmp = root->next;
root = tmp;
free( root );
inline static node* new_node( char *name )
n->name = convert_xml_special_chars( name );
return n;
node *playlist = new_node( psz_zip );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
free_all_node( playlist );
static node* findOrCreateParentNode( node *root, const char *fullpath );
node *parent = findOrCreateParentNode( playlist, psz_name );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
free_all_node( playlist );
0
---------------------------------
486 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 130
node *n = (node*) calloc( 1, sizeof(node) );
return n;
psz_zip = convert_xml_special_chars( psz_zip ? (psz_zip+1) : psz_zippath );
" <trackList>\n", psz_zip ) == -1)
node *playlist = new_node( psz_zip );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
inline static node* new_node( char *name )
n->name = convert_xml_special_chars( name );
return n;
node *playlist = new_node( psz_zip );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
free_all_node( playlist );
inline static void free_all_node( node *root )
free_all_node( root->child );
free( root->name );
0
---------------------------------
487 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 130
node *n = (node*) calloc( 1, sizeof(node) );
return n;
psz_zip = convert_xml_special_chars( psz_zip ? (psz_zip+1) : psz_zippath );
" <trackList>\n", psz_zip ) == -1)
node *playlist = new_node( psz_zip );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
inline static node* new_node( char *name )
n->name = convert_xml_special_chars( name );
return n;
node *playlist = new_node( psz_zip );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
static int nodeToXSPF( char **pp_buffer, node *n, bool b_root );
if( nodeToXSPF( pp_buffer, playlist, true ) < 0 ) return -1;
free_all_node( playlist );
inline static void free_all_node( node *root )
free_all_node( root->child );
free( root->name );
0
---------------------------------
488 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 933
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
0
---------------------------------
489 CVE-2013-0799/Firefox_19.0_CVE_2013_0799_toolkit_components_maintenanceservice_workmonitor.cpp cfunc 396
char updaterIdentity[64];
updaterIdentity, sizeof(updaterIdentity))) {
if (strcmp(updaterIdentity, UPDATER_IDENTITY_STRING)) {
0
---------------------------------
490 CVE-2016-4441/qemu_2.3.0_CVE-2016-4441_esp.c cfunc 688
static void sysbus_esp_realize(DeviceState *dev, Error **errp)
SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
SysBusESPState *sysbus = ESP(dev);
assert(sysbus->it_shift != -1);
0
---------------------------------
491 CVE-2016-4441/qemu_2.3.0_CVE-2016-4441_esp.c cppfunc 688
static void sysbus_esp_realize(DeviceState *dev, Error **errp)
SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
SysBusESPState *sysbus = ESP(dev);
assert(sysbus->it_shift != -1);
0
---------------------------------
492 CVE-2012-6618/Ffmpeg_1.0_CVE_2012_6618_libavformat_utils.c cfunc 4204
PRINT("stream #%d:\n", pkt->stream_index);
PRINT("  keyframe=%d\n", ((pkt->flags & AV_PKT_FLAG_KEY) != 0));
PRINT("  duration=%0.3f\n", pkt->duration * av_q2d(time_base));
PRINT("  dts=");
PRINT("N/A");
PRINT("%0.3f", pkt->dts * av_q2d(time_base));
PRINT("  pts=");
PRINT("%0.3f", pkt->pts * av_q2d(time_base));
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, tb);
pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
static void pkt_dump_internal(void *avcl, FILE *f, int level, AVPacket *pkt, int dump_payload, AVRational time_base)
PRINT("%0.3f", pkt->pts * av_q2d(time_base));
void av_pkt_dump2(FILE *f, AVPacket *pkt, int dump_payload, AVStream *st)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, st->time_base);
void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
pkt_dump_internal(NULL, f, 0, pkt, dump_payload, tb);
0
---------------------------------
493 CVE-2007-5849/cups_1.3.4_CVE-2007-5849_snmp.c cfunc 2056
for (address = (char *)cupsArrayFirst(Addresses);
address = (char *)cupsArrayNext(Addresses))
if (!strcmp(address, "@LOCAL"))
else if (!strncmp(address, "@IF(", 4))
strlcpy(ifname, address + 4, sizeof(ifname));
addrs = httpAddrGetList(address, AF_INET, NULL);
fprintf(stderr, "ERROR: Unable to scan \"%s\"!\n", address);
0
---------------------------------
494 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 543
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
s->tlsext_ellipticcurvelist_length);
ret += s->tlsext_ellipticcurvelist_length;
ticklen = s->tlsext_session_ticket->length;
s->session->tlsext_tick = OPENSSL_malloc(ticklen);
memcpy(s->session->tlsext_tick,
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(ticklen, ret);
memcpy(ret, s->session->tlsext_tick, ticklen);
0
---------------------------------
495 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cfunc 739
folder = path;
char *sep = strchr( folder, '/' );
*sep = '\0';
return findOrCreateParentNode( current, sep );
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
char *path = strdup( fullpath );
free( path );
0
---------------------------------
496 CVE-2010-1444/vlc_media_player_1.1.0_CVE-2010-1444_zipstream.c cppfunc 739
folder = path;
char *sep = strchr( folder, '/' );
*sep = '\0';
return findOrCreateParentNode( current, sep );
ret = findOrCreateParentNode( ret, sep );
static node* findOrCreateParentNode( node *root, const char *fullpath )
char *path = strdup( fullpath );
free( path );
0
---------------------------------
497 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 379
nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
if (f->HasOverflowAreas()) {
nsRect overflowArea = f->GetVisualOverflowRect();
overflowArea.width, overflowArea.height);
0
---------------------------------
498 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1176
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
0
---------------------------------
499 CVE-2015-3815/Wireshark_1.12.4_CVE_2015_3815_wiretap_logcat.c cfunc 195
&wth->phdr, wth->frame_buffer, err, err_info);
struct wtap_pkthdr *phdr, Buffer *buf,
phdr, buf, err, err_info)) {
struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)
guint                tmp[2];
bytes_read = file_read(&tmp, 2, fh);
payload_length = pletoh16(tmp);
buffer_assure_space(buf, packet_size);
pd = buffer_start_ptr(buf);
memcpy(pd, tmp, 2);
0
---------------------------------
500 CVE-2009-2484/vlc_media_player_0.9.9_CVE-2009-2484_smb.c API 500
HINSTANCE hdll = LoadLibrary(_T("MPR.DLL"));
(void *)GetProcAddress( hdll, _T("WNetAddConnection2A") );
FreeLibrary( hdll );
0
---------------------------------
10801 152878/color.c cppfunc 118
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
0
---------------------------------
10802 153744/types.c cppfunc 422
return c - 32;
struct hyposensitivity_pam overactivity_itchily = {0};
valentine_unprying(&overactivity_itchily);
durables_breakthrough(overactivity_itchily);
stonesoup_heap_buffer_64 = (char*) malloc(64 * sizeof(char));
memset(stonesoup_heap_buffer_64,0,64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "INITIAL-STATE");
strcpy(stonesoup_heap_buffer_64, totty_grillage);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_heap_buffer_64);
stonesoup_heap_buffer_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buffer_64[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "BEFORE-FREE");
stonesoup_printf("%s\n",stonesoup_heap_buffer_64);
void stonesoup_printf(char * format, ...) {
free(stonesoup_heap_buffer_64);
void durables_breakthrough(const struct hyposensitivity_pam breastwork_galvanometry)
totty_grillage = ((char *)((struct hyposensitivity_pam )breastwork_galvanometry) . cleanups_carneades);
strcpy(stonesoup_heap_buffer_64, totty_grillage);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_heap_buffer_64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "BEFORE-FREE");
stonesoup_printf("%s\n",stonesoup_heap_buffer_64);
int stonesoup_toupper(int c)
return c;
stonesoup_heap_buffer_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buffer_64[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "BEFORE-FREE");
stonesoup_printf("%s\n",stonesoup_heap_buffer_64);
1
---------------------------------
10803 79542/CWE134_Uncontrolled_Format_String__char_console_vfprintf_13.c inputfunc 52
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
badVaSinkB(data, data);
static void badVaSinkB(char * data, ...)
va_start(args, data);
vfprintf(stdout, data, args);
1
---------------------------------
10804 70865/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61.c cppfunc 42
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61b_badSource(data);
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10805 70407/CWE122_Heap_Based_Buffer_Overflow__CWE135_08.c cppfunc 59
data = NULL;
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10806 71387/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_44.c cppfunc 32
static void badSink(char * data)
strncat(data, source, 100);
printLine(data);
free(data);
1
---------------------------------
10807 153466/subtrans.c cppfunc 105
stonesoup_printf("%02x",stonesoup_other_buff[stonesoup_other_size - stonesoup_i - 1]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10808 153588/file_wrappers.c cppfunc 107
stonesoup_printf("%s\n",stonesoup_buffer_stack);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10809 153770/color.c inputfunc 550
bipartisanship_zopilote = getenv("NOS_SCRAIGH");
if (bipartisanship_zopilote != 0) {;
maladroitly_rifler = ((char *)bipartisanship_zopilote);
strcpy(stonesoup_data->buffer, maladroitly_rifler);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_data->buffer);
for (; stonesoup_i < stonesoup_opt_var; ++stonesoup_i) {
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "FINAL-STATE");
free(stonesoup_data);
int stonesoup_toupper(int c)
if (c >= 97 && c <= 122) {
return c;
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->after(stonesoup_data->buffer[stonesoup_i]));
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%c",stonesoup_data->after(stonesoup_data->buffer[stonesoup_i]));
1
---------------------------------
10810 148966/packet-http.c cppfunc 1512
chunked_encoding_dissector(tvbuff_t **tvb_ptr, packet_info *pinfo,
proto_tree *tree, int offset)
gint chunk_offset = 0;
tvb = *tvb_ptr;
datalen = tvb_reported_length_remaining(tvb, offset);
ti = proto_tree_add_text(tree, tvb, offset, datalen,
linelen = tvb_find_line_end(tvb, offset, -1, &chunk_offset, TRUE);
chunk_string = tvb_get_ephemeral_string(tvb, offset, linelen);
chunk_size = strtol((gchar*)chunk_string, NULL, 16);
datalen = tvb_reported_length_remaining(tvb, offset);
chunk_size = datalen;
chunk_tvb = tvb_new_subset(tvb, chunk_offset,
chunk_size, datalen);
tvb_memcpy(tvb, (guint8 *)(raw_data + raw_len),
chunk_offset, chunk_size);
chunk_ti = proto_tree_add_text(subtree, tvb,
chunk_offset - offset + chunk_size + 2,
chunk_ti = proto_tree_add_text(subtree, tvb,
chunk_offset - offset + chunk_size + 2,
"Data chunk (%u octets)", chunk_size);
proto_tree_add_text(chunk_subtree, tvb, offset,
chunk_offset - offset, "Chunk size: %u octets",
chunk_size);
data_tvb = tvb_new_subset(tvb, chunk_offset, chunk_size, chunk_size);
proto_tree_add_text(chunk_subtree, tvb, chunk_offset +
chunk_size, 2, "Chunk boundary");
offset = chunk_offset + chunk_size + 2;
datalen = tvb_reported_length_remaining(tvb, offset);
linelen = tvb_find_line_end(tvb, offset, -1, &chunk_offset, TRUE);
chunk_string = tvb_get_ephemeral_string(tvb, offset, linelen);
chunk_size = strtol((gchar*)chunk_string, NULL, 16);
1
---------------------------------
10811 70656/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_17.c cppfunc 147
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
10812 110318/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_07.c cppfunc 124
data = -1;
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
10813 110479/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_34.c cppfunc 49
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_34_unionType myUnion;
int data = myUnion.unionSecond;
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
10814 67282/CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_43.cpp cppfunc 42
data[100-1] = L'\0';
wchar_t dest[50] = L"";
wcscat(dest, data);
1
---------------------------------
10815 79537/CWE134_Uncontrolled_Format_String__char_console_vfprintf_08.c inputfunc 65
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
badVaSinkB(data, data);
static void badVaSinkB(char * data, ...)
va_start(args, data);
vfprintf(stdout, data, args);
1
---------------------------------
10816 62969/CWE121_Stack_Based_Buffer_Overflow__CWE135_32.c cppfunc 44
void * *dataPtr2 = &data;
void * data = *dataPtr2;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
1
---------------------------------
10817 62969/CWE121_Stack_Based_Buffer_Overflow__CWE135_32.c cppfunc 47
void * *dataPtr2 = &data;
void * data = *dataPtr2;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10818 70991/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_16.c cppfunc 43
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
10819 72999/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_08.c cppfunc 52
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strcat(dest, data);
printLine(data);
free(data);
1
---------------------------------
10820 153382/mux.c cppfunc 103
stonesoup_printf("%s\n", stonesoup_buff);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10821 70415/CWE122_Heap_Based_Buffer_Overflow__CWE135_16.c cppfunc 47
data = NULL;
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
memcpy(dest, data, (dataLen+1));
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10822 70445/CWE122_Heap_Based_Buffer_Overflow__CWE135_82_bad.cpp cppfunc 33
void CWE122_Heap_Based_Buffer_Overflow__CWE135_82_bad::action(void * data)
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10823 153559/avpacket.c cppfunc 465
stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,"rb");
fseek(stonesoup_tainted_file,0L,2);
stonesoup_lsize = ftell(stonesoup_tainted_file);
rewind(stonesoup_tainted_file);
*stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
*stonesoup_tainted_buff = NULL;
return c;
char *agenizing_herschelian;;
stonesoup_read_taint(&agenizing_herschelian,"BURKES_STORZ");
nonsludging_unridableness = agenizing_herschelian;
underporter_sufflaminate = stoutish_missample(nonsludging_unridableness);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before = stonesoup_toupper;
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after = stonesoup_toupper;
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->before", stonesoup_data->before, &stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->after", stonesoup_data->after, &stonesoup_data->after, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
free(stonesoup_data);
byelovo_echo stoutish_missample(byelovo_echo outbringing_azotic)
return outbringing_azotic;
underporter_sufflaminate = stoutish_missample(nonsludging_unridableness);
algal_intercessive = ((char *)underporter_sufflaminate);
stonesoup_taint_len = ((int )(strlen(algal_intercessive)));
stonesoup_data->buffer[stonesoup_buff_size] = algal_intercessive[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
free(stonesoup_data);
int stonesoup_toupper(int c)
return c - 32;
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
free(stonesoup_data);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {
stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);
stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,"rb");
fseek(stonesoup_tainted_file,0L,2);
stonesoup_lsize = ftell(stonesoup_tainted_file);
*stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));
stonesoup_read_taint(&agenizing_herschelian,"BURKES_STORZ");
nonsludging_unridableness = agenizing_herschelian;
underporter_sufflaminate = stoutish_missample(nonsludging_unridableness);
1
---------------------------------
10824 148881/emem.c cppfunc 1308
node->left=new_node;
new_node->u.is_subtree = is_subtree;
node=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
node=node->left;
new_node->parent=node;
node=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->left=NULL;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->right=NULL;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->key32=key;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->data= func(ud);
new_node->data= func(ud);
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->u.is_subtree = is_subtree;
node->left=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
node=new_node;
new_node->parent=node;
node=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
next_tree=lookup_or_insert32(se_tree, *key[0].key, create_sub_tree, se_tree, EMEM_TREE_NODE_IS_SUBTREE);
key[0].length--;
key[0].key++;
emem_tree_insert32_array(next_tree, key, data);
emem_tree_key_t key[2];
aligned[div-1] = 0x00000001;
key[0].key = aligned;
key[1].length = 0;
key[1].key = NULL;
emem_tree_insert32_array(se_tree, key, v);
emem_tree_insert32_array(emem_tree_t *se_tree, emem_tree_key_t *key, void *data)
next_tree=lookup_or_insert32(se_tree, *key[0].key, create_sub_tree, se_tree, EMEM_TREE_NODE_IS_SUBTREE);
key++;
emem_tree_insert32_array(next_tree, key, data);
emem_tree_insert32_array(emem_tree_t *se_tree, emem_tree_key_t *key, void *data)
next_tree=lookup_or_insert32(se_tree, *key[0].key, create_sub_tree, se_tree, EMEM_TREE_NODE_IS_SUBTREE);
static void* lookup_or_insert32(emem_tree_t *se_tree, guint32 key, void*(*func)(void*),void* ud, int is_subtree) {
node->left=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->key32=key;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->data= func(ud);
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
emem_tree_insert_string(emem_tree_t* se_tree, const gchar* k, void* v, guint32 flags)
guint32 len = (guint32) strlen(k);
guint32 div = (len+3)/4+1;
aligned = malloc(div * sizeof (guint32));
key[0].length = div;
emem_tree_insert32_array(se_tree, key, v);
1
---------------------------------
10825 199319/uninit_pointer.c cppfunc 410
uninit_pointer_016_gbl_doubleptr=(char**) malloc(10*sizeof(char*));
uninit_pointer_016_gbl_doubleptr[i]=(char*) malloc(10*sizeof(char));
strcpy(uninit_pointer_016_gbl_doubleptr[i],"STRING00");
char *s=(char*) malloc(10*sizeof(char));
uninit_pointer_016_func_002();
free (uninit_pointer_016_gbl_doubleptr[i]);
strcpy(s,uninit_pointer_016_gbl_doubleptr[i]);
free(s);
1
---------------------------------
10826 152934/conf_mod.c cppfunc 687
return c - 32;
stonesoup_data = (struct stonesoup_struct *) malloc (sizeof(struct stonesoup_struct));
stonesoup_data->buffer[64 - 1] = '\0';
stonesoup_data->buff_pointer = stonesoup_data->buffer;
tracepoint(stonesoup_trace, variable_buffer_info, "stonesoup_data->buffer", strlen(stonesoup_data->buffer)+1, stonesoup_data->buffer, "TRIGGER-STATE");
strncpy(stonesoup_data->buffer, stonesoup_source, sizeof(stonesoup_source));
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_data->buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
int stonesoup_toupper(int c) {
return c;
stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_data->buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->buffer);
1
---------------------------------
10827 199233/buffer_overrun_dynamic.c cppfunc 608
dynamic_buffer_overrun_s_005* ptr_s= malloc(10*sizeof(dynamic_buffer_overrun_s_005));
ptr_s[i].arr[i]='a';
free(ptr_s);
1
---------------------------------
10828 72809/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_10.c cppfunc 40
data = NULL;
data[0] = '\0';
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
10829 70413/CWE122_Heap_Based_Buffer_Overflow__CWE135_14.c cppfunc 46
data = NULL;
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10830 153746/color.c cppfunc 90
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10831 70403/CWE122_Heap_Based_Buffer_Overflow__CWE135_04.c cppfunc 52
data = NULL;
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10832 70460/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_13.c cppfunc 133
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
10833 72374/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_07.c cppfunc 45
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strncat(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
10834 67335/CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53.c cppfunc 32
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
10835 70472/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_41.c cppfunc 69
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
10836 72978/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_62.cpp cppfunc 41
data = NULL;
badSource(data);
void badSource(wchar_t * &data);
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
10837 66263/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53.c cppfunc 32
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
10838 148966/packet-sdp.c cppfunc 1936
static void dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) {
colon_offset = tvb_find_guint8(tvb, offset, -1, ':');
tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
static gint find_sdp_media_attribute_names(tvbuff_t *tvb, int offset, guint len)
(tvb_strncaseeql(tvb, offset, sdp_media_attribute_names[i].name, len) == 0))
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
offset = colon_offset + 1;
offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
attribute_value = tvb_get_ephemeral_string(tvb, offset, tvb_length_remaining(tvb, offset));
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
proto_tree_add_uint(sdp_media_attribute_tree, hf_sdp_crypto_tag, tvb, offset, tokenlen,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
if (tvb_strncaseeql(tvb, offset, "AES_CM_128_HMAC_SHA1_80", tokenlen) == 0) {
} else if (tvb_strncaseeql(tvb, offset, "AES_CM_128_HMAC_SHA1_32", tokenlen) == 0) {
} else if (tvb_strncaseeql(tvb, offset, "F8_128_HMAC_SHA1_80", tokenlen) == 0) {
offset = next_offset + 1;
param_end_offset = tvb_find_guint8(tvb, offset, -1, ';');
tvb, offset, param_end_offset-offset, "Key parameters");
next_offset = tvb_find_guint8(tvb, offset, -1, ':');
tvb, offset, param_end_offset-offset, "Key parameters");
if (tvb_strncaseeql(tvb, offset, "inline", next_offset-offset) == 0) {
next_offset = tvb_find_guint8(tvb, offset, -1, '|');
data_p = tvb_get_ephemeral_string(tvb, offset, tokenlen);
key_salt_tvb = base64_to_tvb(tvb, data_p);
proto_tree_add_text(parameter_tree, tvb, offset, tokenlen, "Key and Salt");
next_offset = tvb_find_guint8(tvb, offset, -1, '|');
tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
offset   = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ':');
proto_tree_add_item(parameter_tree, hf_sdp_crypto_mki, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
offset      = next_offset + 1;
next_offset = param_end_offset;
tokenlen    = next_offset - offset;
transport_info->mki_len = atoi((char*)tvb_get_ephemeral_string(tvb, offset, tokenlen));
tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
next_offset = tvb_find_guint8(tvb, offset, -1, ':');
proto_tree_add_item(parameter_tree, hf_sdp_crypto_mki, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
offset      = next_offset + 1;
transport_info->mki_len = atoi((char*)tvb_get_ephemeral_string(tvb, offset, tokenlen));
offset = param_end_offset;
param_end_offset = tvb_find_guint8(tvb, offset, -1, ';');
tvb, offset, param_end_offset-offset, "Key parameters");
next_offset = param_end_offset;
tokenlen    = next_offset - offset;
transport_info->mki_len = atoi((char*)tvb_get_ephemeral_string(tvb, offset, tokenlen));
proto_tree_add_text(parameter_tree, tvb, next_offset + 1, tokenlen,
param_end_offset = tvb_find_guint8(tvb, offset, -1, ';');
tvb, offset, param_end_offset-offset, "Key parameters");
next_offset = param_end_offset;
tokenlen    = next_offset - offset;
transport_info->mki_len = atoi((char*)tvb_get_ephemeral_string(tvb, offset, tokenlen));
offset = param_end_offset;
param_end_offset = tvb_find_guint8(tvb, offset, -1, ';');
param_end_offset = tvb_length(tvb);
tvb, offset, param_end_offset-offset, "Key parameters");
next_offset = tvb_find_guint8(tvb, offset, -1, ':');
if (tvb_strncaseeql(tvb, offset, "inline", next_offset-offset) == 0) {
offset      = next_offset +1;
next_offset = tvb_find_guint8(tvb, offset, -1, '|');
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, '|');
next_offset = tvb_find_guint8(tvb, offset, -1, ':');
offset      = next_offset + 1;
next_offset = param_end_offset;
tokenlen    = next_offset - offset;
transport_info->mki_len = atoi((char*)tvb_get_ephemeral_string(tvb, offset, tokenlen));
1
---------------------------------
10839 71459/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_04.c cppfunc 53
data = NULL;
data[0] = '\0';
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
10840 72966/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_33.cpp cppfunc 43
wchar_t * &dataRef = data;
wchar_t * data = dataRef;
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
10841 72285/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_14.c cppfunc 39
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
memcpy(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10842 153300/config_file.c cppfunc 83
stonesoup_printf("Error: Failed to allocate memory\n");
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10843 72722/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_21.c cppfunc 49
static wchar_t * badSource(wchar_t * data)
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data = badSource(data);
data[100-1] = L'\0';
return data;
data = badSource(data);
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
10844 72450/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_62.cpp cppfunc 40
data = (char *)malloc(100*sizeof(char));
badSource(data);
void badSource(char * &data);
strncpy(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
10845 153351/oids.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&sphenomaxillary_stereoscopy,"MOFW_BRAMLEY");
if (sphenomaxillary_stereoscopy != 0) {;
pachysandra_depolarising = ((int )(strlen(sphenomaxillary_stereoscopy)));
orthograde_unstack = ((char *)(malloc(pachysandra_depolarising + 1)));
if (orthograde_unstack == 0) {
memcpy(orthograde_unstack,sphenomaxillary_stereoscopy,pachysandra_depolarising);
if (sphenomaxillary_stereoscopy != 0)
free(((char *)sphenomaxillary_stereoscopy));
convex_nonheritor = &orthograde_unstack;
cruciately_composite = &convex_nonheritor;
glissandi_heliotype = ((char *)( *( *cruciately_composite)));
stonesoup_fp = stonesoup_switch_func(glissandi_heliotype);
if ( *( *cruciately_composite) != 0)
free(((char *)( *( *cruciately_composite))));
stonesoup_fct_ptr stonesoup_switch_func(char *param)
var_len = strlen(param) % 3;
sscanf(param,"%p",&fct_ptr_addr);
return fct_ptr_addr;
stonesoup_fp = stonesoup_switch_func(glissandi_heliotype);
tracepoint(stonesoup_trace, variable_address, "stonesoup_fp", stonesoup_fp, "TRIGGER-STATE");
stonesoup_cmp_flag = ( *stonesoup_fp)(stonesoup_rand_word,glissandi_heliotype);
if (stonesoup_cmp_flag == 0)
1
---------------------------------
10846 110338/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_43.cpp cppfunc 123
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
10847 71922/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_62.cpp cppfunc 46
void badSource(twoIntsStruct * &data);
data = NULL;
badSource(data);
badSource(data);
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
1
---------------------------------
10848 153275/column.c cppfunc 54
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10849 71212/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_81_goodG2B.cpp cppfunc 32
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_81_goodG2B::action(wchar_t * data) const
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
10850 153753/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&iin_magnesia,"UNACCEPTANT_MULTIFAROUSLY");
if (iin_magnesia != 0) {;
bluenesses_aleron = ((char *)iin_magnesia);
stonesoup_buff_size = ((int )(strlen(bluenesses_aleron)));
memcpy(stonesoup_data.buffer, bluenesses_aleron, 64);
for (; stonesoup_i < stonesoup_buff_size; ++stonesoup_i){
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data.buffer", stonesoup_data.buffer, "CROSSOVER-STATE");
if (iin_magnesia != 0)
free(((char *)iin_magnesia));
1
---------------------------------
10851 153656/color.c cppfunc 118
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10852 72372/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_05.c cppfunc 46
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strncat(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
10853 79401/CWE134_Uncontrolled_Format_String__char_console_fprintf_16.c inputfunc 40
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
size_t dataLen = strlen(data);
if (100-dataLen > 1)
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
fprintf(stdout, data);
1
---------------------------------
10854 73300/CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_43.cpp cppfunc 40
static void badSource(int64_t * &data)
data = NULL;
badSource(data);
data = (int64_t *)malloc(sizeof(data));
*data = 2147483643LL;
printLongLongLine(*data);
free(data);
1
---------------------------------
10855 70742/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_07.c cppfunc 48
data = NULL;
data = (char *)malloc(10*sizeof(char));
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
10856 153074/utils.c cppfunc 874
return c - 32;
return c;
understriding_adesmy = getenv("OPTIMISED_ORBICULARLY");
sesuvium_christmasing . creachy_presubsistent = understriding_adesmy;
cacatua_citable = ((char *)sesuvium_christmasing . creachy_presubsistent);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before = stonesoup_toupper;
memset(stonesoup_data->buffer,0,64);
stonesoup_data->after = stonesoup_toupper;
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->before", stonesoup_data->before, &stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->after", stonesoup_data->after, &stonesoup_data->after, "INITIAL-STATE");
strcpy(stonesoup_data->buffer, cacatua_citable);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_data->buffer);
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->after(stonesoup_data->buffer[stonesoup_i]));
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "FINAL-STATE");
free(stonesoup_data);
1
---------------------------------
10857 71369/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_10.c cppfunc 40
data = NULL;
data[0] = '\0';
strncat(data, source, 100);
printLine(data);
free(data);
1
---------------------------------
10858 72412/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_81_bad.cpp cppfunc 32
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_81_bad::action(char * data) const
strncat(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
10859 152948/mutex.c cppfunc 273
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc (sizeof(struct stonesoup_struct));
memset(stonesoup_data->base_path, 0, 20);
stonesoup_data->buff_pointer = stonesoup_data->base_path;
realpath(gerara_supertrain, stonesoup_data->base_path);
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
free (stonesoup_data);
void stonesoup_printf(char * format, ...) {
free (stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
1
---------------------------------
10860 152970/color.c cppfunc 629
rewind(stonesoup_tainted_file);
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
*stonesoup_tainted_buff = NULL;
char *ecclesiasticus_restibrachium;
stonesoup_read_taint(&ecclesiasticus_restibrachium,"DANIELLE_BRUSHBALL");
fisk_vinegar = ((char *)ecclesiasticus_restibrachium);
strncpy(stonesoup_buffer, fisk_vinegar, stonesoup_buffer_len);
stonesoup_buffer_ptr = malloc(65528);
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "CROSSOVER-STATE");
*stonesoup_buffer_ptr = fisk_vinegar;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
tracepoint(stonesoup_trace, variable_address, "*stonesoup_buffer_ptr", *stonesoup_buffer_ptr, "TRIGGER-STATE");
stonesoup_tainted_len = strlen( *stonesoup_buffer_ptr);
free(stonesoup_buffer_ptr);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {
stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);
stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,"rb");
fseek(stonesoup_tainted_file,0L,2);
stonesoup_lsize = ftell(stonesoup_tainted_file);
*stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));
stonesoup_read_taint(&ecclesiasticus_restibrachium,"DANIELLE_BRUSHBALL");
fisk_vinegar = ((char *)ecclesiasticus_restibrachium);
strncpy(stonesoup_buffer, fisk_vinegar, stonesoup_buffer_len);
*stonesoup_buffer_ptr = fisk_vinegar;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
free(stonesoup_buffer_ptr);
1
---------------------------------
10861 153519/cmdline.c cppfunc 1167
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof (struct stonesoup_struct));
stonesoup_data->buff_pointer = stonesoup_data->buffer;
strncpy(stonesoup_data->buffer, snatches_phonying, strlen(snatches_phonying) + 1);
stonesoup_ptr_deref = strlen( stonesoup_data->buff_pointer);
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
1
---------------------------------
10862 153683/tile.c cppfunc 79
stonesoup_printf("Error: Failed to allocate memory\n");
stonesoup_printf("%s\n",stonesoup_base_path);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10863 153355/subtrans.c cppfunc 103
stonesoup_printf("%s\n", stonesoup_data.buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10864 153137/emem.c cppfunc 195
stonesoup_printf("%02x",stonesoup_heap_buff_64[stonesoup_ss_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10865 79399/CWE134_Uncontrolled_Format_String__char_console_fprintf_14.c inputfunc 40
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
fprintf(stdout, data);
1
---------------------------------
10866 153253/color.c cppfunc 90
stonesoup_printf("%c",stonesoup_stack_buff_64[stonesoup_ss_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10867 72988/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_81_goodG2B.cpp cppfunc 33
void CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_81_goodG2B::action(wchar_t * data) const
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
10868 71404/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_81_bad.cpp cppfunc 33
void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_81_bad::action(char * data) const
strncat(data, source, 100);
printLine(data);
free(data);
1
---------------------------------
10869 73045/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_06.c cppfunc 42
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
10870 79435/CWE134_Uncontrolled_Format_String__char_console_printf_02.c inputfunc 40
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
printf(data);
1
---------------------------------
10871 153422/color.c cppfunc 90
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10872 153428/utils.c cppfunc 111
stonesoup_printf("%c",stonesoup_stack_buff_64[stonesoup_ss_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10873 72712/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_09.c cppfunc 39
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data[100-1] = L'\0';
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
10874 67607/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_67.cpp cppfunc 47
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
1
---------------------------------
10875 62954/CWE121_Stack_Based_Buffer_Overflow__CWE135_07.c cppfunc 49
data = NULL;
data = (void *)WIDE_STRING;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10876 199235/buffer_underrun_dynamic.c cppfunc 134
double *buf=(double*) calloc(5,sizeof(double));
buf[i]=1.0;
free(buf);
1
---------------------------------
10877 110317/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_06.c cppfunc 122
data = -1;
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
10878 70660/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_31.c cppfunc 144
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
10879 70762/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_43.cpp cppfunc 47
data = (char *)malloc(10*sizeof(char));
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
10880 153128/avfilter.c cppfunc 48
stonesoup_printf("%s\n", stonesoup_data.base_path);
stonesoup_printf("%s\n", stonesoup_data.buff_pointer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10881 153049/subtrans.c cppfunc 103
stonesoup_printf("%s\n", stonesoup_buff);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10882 110333/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_32.c cppfunc 123
int *dataPtr2 = &data;
int data = *dataPtr2;
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
10883 79459/CWE134_Uncontrolled_Format_String__char_console_printf_42.c inputfunc 35
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
return data;
data = badSource(data);
printf(data);
1
---------------------------------
10884 70839/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_08.c cppfunc 57
data = NULL;
data = (char *)malloc(10*sizeof(char));
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10885 72748/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_81_goodG2B.cpp cppfunc 32
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_81_goodG2B::action(wchar_t * data) const
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
10886 72769/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_18.c cppfunc 43
data[100-1] = L'\0';
SNPRINTF(dest, wcslen(data), L"%s", data);
printWLine(data);
free(data);
1
---------------------------------
10887 153329/avfilter.c cppfunc 1016
return c - 32;
stonesoup_data = (char*) malloc(8 * sizeof(char));
strncpy(stonesoup_data, worrit_thundershower, strlen(worrit_thundershower) + 1);
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i) {
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i) {
stonesoup_printf("%s\n", stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
1
---------------------------------
10888 199233/buffer_overrun_dynamic.c cppfunc 333
int *buf=(int*) calloc(5,sizeof(int));
int indexes[4] = {3, 4, 5, 6};
*(buf+indexes[index]) = 1;
free(buf);
1
---------------------------------
10889 152868/color.c cppfunc 120
stonesoup_printf("%s\n",stonesoup_base_path);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10890 72785/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_61.c cppfunc 42
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_61b_badSource(data);
SNPRINTF(dest, wcslen(data), L"%s", data);
printWLine(data);
free(data);
1
---------------------------------
10891 71477/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_32.c cppfunc 51
char * *dataPtr2 = &data;
char * data = *dataPtr2;
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
10892 67445/CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_82a.cpp cppfunc 31
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
10893 199235/buffer_underrun_dynamic.c cppfunc 98
long *buf=(long*) calloc(5,sizeof(long));
buf[i]=1;
free(buf);
1
---------------------------------
10894 152878/color.c cppfunc 604
return c - 32;
stonesoup_data = (struct stonesoup_struct *) malloc (sizeof(struct stonesoup_struct));
stonesoup_data->buffer[64 - 1] = '\0';
stonesoup_data->buff_pointer = stonesoup_data->buffer;
tracepoint(stonesoup_trace, variable_buffer_info, "stonesoup_data->buffer", strlen(stonesoup_data->buffer)+1, stonesoup_data->buffer, "TRIGGER-STATE");
strncpy(stonesoup_data->buffer, stonesoup_source, sizeof(stonesoup_source));
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_data->buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
int stonesoup_toupper(int c) {
return c;
stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_data->buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
1
---------------------------------
10895 72765/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_14.c cppfunc 44
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data[100-1] = L'\0';
SNPRINTF(dest, wcslen(data), L"%s", data);
printWLine(data);
free(data);
1
---------------------------------
10896 153331/emem.c cppfunc 176
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10897 153229/string.c cppfunc 1171
return c - 32;
char *liponis_heredium = 0;
unconcatenated_diddies(&liponis_heredium);
wonderers_silicean = preexpend_pretranslation(liponis_heredium);
stonesoup_heap_buff_64[64 - 1] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
int stonesoup_toupper(int c)
return c;
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
free(stonesoup_heap_buff_64);
char *preexpend_pretranslation(char *endangiitis_osirification)
return endangiitis_osirification;
wonderers_silicean = preexpend_pretranslation(liponis_heredium);
rort_unexorbitant = ((char *)wonderers_silicean);
stonesoup_taint_len = ((int )(strlen(rort_unexorbitant)));
stonesoup_heap_buff_64[stonesoup_buff_size] = rort_unexorbitant[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
free(stonesoup_heap_buff_64);
1
---------------------------------
10898 72326/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_07.c cppfunc 45
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10899 72801/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_02.c cppfunc 40
data = NULL;
data[0] = '\0';
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
10900 152873/portalmem.c cppfunc 128
stonesoup_printf("%c",stonesoup_data.before(stonesoup_data.buffer[stonesoup_i]));
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10901 153486/bufmgr.c cppfunc 2715
stonesoup_heap_buff_64[63] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "INITIAL-STATE");
strncpy(stonesoup_heap_buff_64, cunaxa_lyonnesse, 64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "TAINTED");
stonesoup_printf("%02x",stonesoup_heap_buff_64[stonesoup_ss_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
free( stonesoup_heap_buff_64);
void stonesoup_printf(char * format, ...) {
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
free( stonesoup_heap_buff_64);
1
---------------------------------
10902 199253/double_free.c cppfunc 149
double_free_function_008_gbl_ptr= (char*) malloc(sizeof(char));
double_free_function_008();
free (double_free_function_008_gbl_ptr);
double_free_function_008();
free(double_free_function_008_gbl_ptr);
1
---------------------------------
10903 70764/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45.c cppfunc 39
data = (char *)malloc(10*sizeof(char));
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45_badData = data;
badSink();
char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45_badData;
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
10904 71466/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_11.c cppfunc 46
data = NULL;
data[0] = '\0';
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
10905 67489/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_06.c cppfunc 52
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_06_bad();
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
good1();
good2();
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_06_good();
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_06_bad();
structCharVoid->voidSecond = (void *)SRC_STR;
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0';
free(structCharVoid);
1
---------------------------------
10906 72768/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_17.c cppfunc 45
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data[100-1] = L'\0';
SNPRINTF(dest, wcslen(data), L"%s", data);
printWLine(data);
free(data);
1
---------------------------------
10907 62957/CWE121_Stack_Based_Buffer_Overflow__CWE135_10.c cppfunc 41
data = NULL;
data = (void *)WIDE_STRING;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
1
---------------------------------
10908 62957/CWE121_Stack_Based_Buffer_Overflow__CWE135_10.c cppfunc 44
data = NULL;
data = (void *)WIDE_STRING;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10909 199233/buffer_overrun_dynamic.c cppfunc 131
double *buf=(double*) calloc(5,sizeof(double));
buf[i]=1.0;
free(buf);
1
---------------------------------
10910 153193/color.c cppfunc 118
stonesoup_printf("%02x",stonesoup_heap_buff_64[stonesoup_ss_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10911 153480/bss_file.c cppfunc 543
return c - 32;
stonesoup_data = (char*) malloc(8 * sizeof(char));
strncpy(stonesoup_data, cobstone_zostera, strlen(cobstone_zostera) + 1);
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i) {
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i) {
stonesoup_printf("%s\n", stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
1
---------------------------------
10912 153721/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&impartibilibly_theogeological,"URTICA_UNDERBEAR");
if (impartibilibly_theogeological != 0) {;
antiperthite_rodsman = ((char *)impartibilibly_theogeological);
stonesoup_fp = stonesoup_switch_func(antiperthite_rodsman);
if (impartibilibly_theogeological != 0)
free(((char *)impartibilibly_theogeological));
stonesoup_fct_ptr stonesoup_switch_func(char *param)
var_len = strlen(param) % 3;
sscanf(param,"%p",&fct_ptr_addr);
return fct_ptr_addr;
stonesoup_fp = stonesoup_switch_func(antiperthite_rodsman);
tracepoint(stonesoup_trace, variable_address, "stonesoup_fp", stonesoup_fp, "TRIGGER-STATE");
stonesoup_cmp_flag = ( *stonesoup_fp)(stonesoup_rand_word,antiperthite_rodsman);
if (stonesoup_cmp_flag == 0)
1
---------------------------------
10913 110356/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_81_goodG2B.cpp cppfunc 37
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_81_goodG2B::action(int data) const
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
10914 71004/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_45.c cppfunc 39
data = (wchar_t *)malloc(10*sizeof(wchar_t));
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_45_badData = data;
badSink();
wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_45_badData;
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
10915 72845/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_82_goodG2B.cpp cppfunc 33
void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_82_goodG2B::action(char * data)
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
10916 148966/strutil.c cppfunc 633
oid_str_to_bytes(const char *oid_str, GByteArray *bytes) {
p = oid_str;
if (!isdigit((guchar)*p) && (*p != '.')) return FALSE;
1
---------------------------------
10917 148966/packet-sdp.c cppfunc 1385
bytes_tvb = tvb_new_child_real_data(tvb, buf, i, i);
proto_tree_add_text(tree, tvb, offset, tokenlen, "Debug; Analysed string: '%s'",
next_offset = tvb_find_guint8(tvb, offset, -1, '=');
offset = next_offset;
offset++;
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
item = proto_tree_add_uint(tree, hf_sdp_fmtp_mpeg4_profile_level_id, tvb, offset, tokenlen,
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
item = proto_tree_add_uint(tree, hf_sdp_fmtp_h263_profile, tvb, offset, tokenlen,
offset++;
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
item = proto_tree_add_uint(tree, hf_sdp_fmtp_h263_level, tvb, offset, tokenlen,
atol((char*)format_specific_parameter));
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);
item = proto_tree_add_text(tree, tvb, offset, tokenlen, "Incorrectly coded, must be three bytes");
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
item = proto_tree_add_uint(tree, hf_sdp_h264_packetization_mode, tvb, offset, tokenlen,
comma_offset = tvb_find_guint8(tvb, offset, -1, ',');
data_p = tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_text(tree, tvb, offset, tokenlen, "NAL unit 1 string: %s", data_p);
data_tvb = base64_to_tvb(tvb, data_p);
show_reported_bounds_error(tvb, pinfo, tree);
data_p   = tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_text(tree, tvb, offset, tokenlen, "NAL unit 2 string: %s", data_p);
data_tvb = base64_to_tvb(tvb, data_p);
(tvb_strncaseeql(tvb, offset, sdp_media_attribute_names[i].name, len) == 0))
offset = 0;
colon_offset = tvb_find_guint8(tvb, offset, -1, ':');
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
offset = colon_offset + 1;
offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
attribute_value = tvb_get_ephemeral_string(tvb, offset, tvb_length_remaining(tvb, offset));
offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
hf_media_format, tvb, offset,
media_format = atoi((char*)tvb_get_ephemeral_string(tvb, offset, tokenlen));
payload_type = tvb_get_ephemeral_string(tvb, offset, tokenlen);
offset = next_offset + 1;
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
next_offset = tvb_find_guint8(tvb, offset, -1, ';');
offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
next_offset= tvb_length(tvb);
tokenlen = next_offset - offset;
hf_media_format_specific_parameter, tvb,
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
hf_media_format_specific_parameter, tvb,
offset = next_offset + 1;
offset, tokenlen, ENC_ASCII|ENC_NA);
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
ascii_bytes_to_tvb(tvbuff_t *tvb, packet_info *pinfo, gint len, gchar *msg)
data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
atol((char*)format_specific_parameter));
data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);
decode_sdp_fmtp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint offset, gint tokenlen, char *mime_type) {
end_offset = offset + tokenlen;
proto_tree_add_text(tree, tvb, offset, tokenlen, "Debug; Analysed string: '%s'",
next_offset = tvb_find_guint8(tvb, offset, -1, '=');
field_name = tvb_get_ephemeral_string(tvb, offset, tokenlen);
tokenlen = end_offset - offset;
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
atol((char*)format_specific_parameter));
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
hf_media_format_specific_parameter, tvb,
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
decode_sdp_fmtp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint offset, gint tokenlen, char *mime_type) {
field_name = tvb_get_ephemeral_string(tvb, offset, tokenlen);
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
atol((char*)format_specific_parameter));
static void dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) {
colon_offset = tvb_find_guint8(tvb, offset, -1, ':');
tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
static gint find_sdp_media_attribute_names(tvbuff_t *tvb, int offset, guint len)
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
next_offset = tvb_find_guint8(tvb, offset, -1, ';');
hf_media_format_specific_parameter, tvb,
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
1
---------------------------------
10918 62966/CWE121_Stack_Based_Buffer_Overflow__CWE135_21.c cppfunc 40
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
data = (void *)WIDE_STRING;
badSink(data);
static void badSink(void * data)
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10919 153440/color.c cppfunc 598
rewind(stonesoup_tainted_file);
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
*stonesoup_tainted_buff = NULL;
return c - 32;
char *commutating_persicaria;
stonesoup_read_taint(&commutating_persicaria,"REVOCATION_CONSUMPTIBLE");
danyelle_dulcetly = ((char *)commutating_persicaria);
stonesoup_heap_buff_64[64 - 1] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "INITIAL-STATE");
stonesoup_taint_len = ((int )(strlen(danyelle_dulcetly)));
stonesoup_heap_buff_64[stonesoup_buff_size] = danyelle_dulcetly[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
int stonesoup_toupper(int c)
return c;
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
free(stonesoup_heap_buff_64);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {
stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);
stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,"rb");
fseek(stonesoup_tainted_file,0L,2);
stonesoup_lsize = ftell(stonesoup_tainted_file);
*stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));
stonesoup_read_taint(&commutating_persicaria,"REVOCATION_CONSUMPTIBLE");
danyelle_dulcetly = ((char *)commutating_persicaria);
stonesoup_taint_len = ((int )(strlen(danyelle_dulcetly)));
stonesoup_heap_buff_64[stonesoup_buff_size] = danyelle_dulcetly[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
free(stonesoup_heap_buff_64);
1
---------------------------------
10920 72330/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_11.c cppfunc 39
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10921 70905/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_42.c cppfunc 46
data = (char *)malloc(10*sizeof(char));
return data;
data = badSource(data);
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10922 70755/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22.c cppfunc 44
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badSource(data);
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
10923 153023/avpacket.c cppfunc 69
stonesoup_printf("%s\n", stonesoup_data);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10924 72428/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_13.c cppfunc 39
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strncpy(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
10925 70928/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_01.c cppfunc 40
data = (char *)malloc(10*sizeof(char));
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
1
---------------------------------
10926 110483/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_44.c cppfunc 34
static void badSink(int data)
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
10927 62973/CWE121_Stack_Based_Buffer_Overflow__CWE135_42.c cppfunc 45
data = (void *)WIDE_STRING;
return data;
data = badSource(data);
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10928 62973/CWE121_Stack_Based_Buffer_Overflow__CWE135_42.c cppfunc 42
data = (void *)WIDE_STRING;
return data;
data = badSource(data);
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
1
---------------------------------
10929 110374/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_15.c cppfunc 61
data = -1;
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
10930 79388/CWE134_Uncontrolled_Format_String__char_console_fprintf_03.c inputfunc 40
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
fprintf(stdout, data);
1
---------------------------------
10931 72953/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_10.c cppfunc 40
data = NULL;
data[0] = L'\0';
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
10932 72365/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_82_bad.cpp cppfunc 32
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_82_bad::action(char * data)
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10933 72815/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_16.c cppfunc 41
data = NULL;
data[0] = '\0';
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
10934 153049/subtrans.c cppfunc 414
return c - 32;
stonesoup_buff = (char *) malloc (sizeof(char) * 20);
memset(stonesoup_buff, 0, 20);
realpath(depressing_mirthsome, stonesoup_buff);
stonesoup_opt_var = strlen( stonesoup_buff);
stonesoup_toupper(stonesoup_buff[stonesoup_oc_i]);
stonesoup_buff[stonesoup_oc_i] =
stonesoup_toupper(stonesoup_buff[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buff);
int stonesoup_toupper(int c)
return c;
stonesoup_toupper(stonesoup_buff[stonesoup_oc_i]);
stonesoup_buff[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_buff);
void stonesoup_printf(char * format, ...) {
free (stonesoup_buff);
1
---------------------------------
10935 110690/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_73.cpp cppfunc 44
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
1
---------------------------------
10936 153312/config.c cppfunc 110
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10937 72431/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_16.c cppfunc 40
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strncpy(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
10938 153557/conversation.c inputfunc 157
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&gottingen_ophthalmometer,"OSCILLATIONS_ANNUNCIATORY");
if (gottingen_ophthalmometer != 0) {;
carinal_stuber . dunkers_crosette = gottingen_ophthalmometer;
outstretching_hoppestere[ *pratfalls_chipling] = carinal_stuber;
schuit_shovelbill = outstretching_hoppestere[ *pratfalls_chipling];
TRYPANOSOMA_ILLAQUEATION(schuit_shovelbill);
void twangy_entourage(union orchidectomies_carrel dermatorrhagia_niched)
TRYPANOSOMA_ILLAQUEATION(schuit_shovelbill);
scrogie_transmitter = ((char *)dermatorrhagia_niched . dunkers_crosette);
stonesoup_fp = stonesoup_switch_func(scrogie_transmitter);
if (dermatorrhagia_niched . dunkers_crosette != 0)
free(((char *)dermatorrhagia_niched . dunkers_crosette));
stonesoup_fct_ptr stonesoup_switch_func(char *param)
var_len = strlen(param) % 3;
sscanf(param,"%p",&fct_ptr_addr);
return fct_ptr_addr;
stonesoup_fp = stonesoup_switch_func(scrogie_transmitter);
tracepoint(stonesoup_trace, variable_address, "stonesoup_fp", stonesoup_fp, "TRIGGER-STATE");
stonesoup_cmp_flag = ( *stonesoup_fp)(stonesoup_rand_word,scrogie_transmitter);
if (stonesoup_cmp_flag == 0)
1
---------------------------------
10939 153671/color.c cppfunc 118
stonesoup_printf("%s\n", stonesoup_buff);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10940 72085/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_06.c cppfunc 44
data = NULL;
data[0] = L'\0';
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
10941 148966/emem.c cppfunc 2294
va_list ap;
va_start(ap, format);
ep_strbuf_append_vprintf(strbuf, format, ap);
ep_strbuf_append_vprintf(emem_strbuf_t *strbuf, const gchar *format, va_list ap)
G_VA_COPY(ap2, ap);
full_len = g_vsnprintf(&strbuf->str[strbuf->len], (gulong) add_len, format, ap);
va_end(ap);
1
---------------------------------
10942 152903/color.c cppfunc 599
rewind(stonesoup_tainted_file);
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
*stonesoup_tainted_buff = NULL;
char *hotheadednesses_protoactinium;
stonesoup_read_taint(&hotheadednesses_protoactinium,"RUPESTRAL_UNCUMBER");
wreckage_conceding = ((char *)hotheadednesses_protoactinium);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before[63] = '\0';
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after[63] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->before", stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->after", stonesoup_data->after, "INITIAL-STATE");
stonesoup_buff_size = ((int )(strlen(wreckage_conceding)));
memcpy(stonesoup_data->buffer, wreckage_conceding, 64);
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {
stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);
stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,"rb");
fseek(stonesoup_tainted_file,0L,2);
stonesoup_lsize = ftell(stonesoup_tainted_file);
*stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));
stonesoup_read_taint(&hotheadednesses_protoactinium,"RUPESTRAL_UNCUMBER");
wreckage_conceding = ((char *)hotheadednesses_protoactinium);
stonesoup_buff_size = ((int )(strlen(wreckage_conceding)));
memcpy(stonesoup_data->buffer, wreckage_conceding, 64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_printf(char * format, ...) {
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
1
---------------------------------
10943 70945/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_18.c cppfunc 42
data = (char *)malloc(10*sizeof(char));
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
1
---------------------------------
10944 70837/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_06.c cppfunc 47
data = NULL;
data = (char *)malloc(10*sizeof(char));
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10945 67487/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_04.c cppfunc 53
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
good1();
good2();
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_04_good();
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_04_bad();
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
structCharVoid->voidSecond = (void *)SRC_STR;
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0';
free(structCharVoid);
1
---------------------------------
10946 70417/CWE122_Heap_Based_Buffer_Overflow__CWE135_18.c cppfunc 45
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10947 70526/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_52.c cppfunc 38
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
1
---------------------------------
10948 70526/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_52.c inputfunc 35
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_52b_badSink(data);
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_52b_badSink(int data);
1
---------------------------------
10949 79555/CWE134_Uncontrolled_Format_String__char_console_vfprintf_42.c cppfunc 64
va_list args;
va_start(args, data);
vfprintf(stdout, data, args);
va_end(args);
1
---------------------------------
10950 70465/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_18.c cppfunc 132
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
10951 72855/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_08.c cppfunc 54
data = NULL;
data[0] = '\0';
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
10952 153625/utf.c cppfunc 1037
return c - 32;
stonesoup_data = (struct stonesoup_struct *) malloc (sizeof(struct stonesoup_struct));
stonesoup_data->buffer[64 - 1] = '\0';
stonesoup_data->buff_pointer = stonesoup_data->buffer;
tracepoint(stonesoup_trace, variable_buffer_info, "stonesoup_data->buffer", strlen(stonesoup_data->buffer)+1, stonesoup_data->buffer, "TRIGGER-STATE");
strncpy(stonesoup_data->buffer, stonesoup_source, sizeof(stonesoup_source));
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_data->buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
int stonesoup_toupper(int c) {
return c;
stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_data->buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
1
---------------------------------
10953 153792/gimpdisplay.c inputfunc 103
ss_tc_root = getenv("SS_TC_ROOT");
if (ss_tc_root != NULL) {
size_dirpath = strlen(ss_tc_root) + strlen("testData") + 2;
dirpath = (char*) malloc (size_dirpath * sizeof(char));
if (dirpath != NULL) {
sprintf(dirpath, "%s/%s", ss_tc_root, "testData");
if (stat(dirpath, &st) == -1) {
retval = mkdir(dirpath, 0700);
if (retval == 0) {
size_filepath = strlen(dirpath) + strlen("logfile.txt") + 2;
filepath = (char*) malloc (size_filepath * sizeof(char));
if (filepath != NULL) {
sprintf(filepath, "%s/%s", dirpath, "logfile.txt");
stonesoup_printf_context = fopen(filepath, "w");
free(filepath);
free(dirpath);
if (stonesoup_printf_context == NULL) {
stonesoup_setup_printf_context();
stonesoup_read_taint(&irishwomen_simeonite,"9330",wanderoo_hybridising);
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
vfprintf(stonesoup_printf_context, format, argptr);
fflush(stonesoup_printf_context);
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
stonesoup_printf("\n");
vfprintf(stonesoup_printf_context, format, argptr);
fflush(stonesoup_printf_context);
stonesoup_printf("\n");
stonesoup_close_printf_context();
if (stonesoup_printf_context != NULL &&
stonesoup_printf_context != stderr) {
fclose(stonesoup_printf_context);
1
---------------------------------
10954 72498/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_snprintf_62.cpp cppfunc 45
data = (char *)malloc(100*sizeof(char));
badSource(data);
void badSource(char * &data);
SNPRINTF(dest, strlen(data), "%s", data);
printLine(data);
free(data);
1
---------------------------------
10955 70743/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_08.c cppfunc 56
data = NULL;
data = (char *)malloc(10*sizeof(char));
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
10956 110691/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_74.cpp cppfunc 44
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
1
---------------------------------
10957 70416/CWE122_Heap_Based_Buffer_Overflow__CWE135_17.c cppfunc 47
data = NULL;
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
memcpy(dest, data, (dataLen+1));
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10958 72364/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_81_bad.cpp cppfunc 32
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_81_bad::action(char * data) const
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10959 79486/CWE134_Uncontrolled_Format_String__char_console_snprintf_05.c inputfunc 52
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
SNPRINTF(dest, 100-1, data);
1
---------------------------------
10960 153029/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&middled_nontenableness,"VILLATE_EPICOELIAC");
if (middled_nontenableness != 0) {;
jenna_resicken = ((char *)middled_nontenableness);
stonesoup_other_buff[7] = jenna_resicken;
stonesoup_buff_size = ((int )(strlen(jenna_resicken)));
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_other_buff", stonesoup_other_buff, "INITIAL-STATE");
for (; stonesoup_buff_size >= 0; (--stonesoup_my_buff_size , --stonesoup_buff_size)) {
stonesoup_stack_buff_64[stonesoup_my_buff_size] = jenna_resicken[stonesoup_buff_size];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_stack_buff_64", stonesoup_stack_buff_64, "CROSSOVER-STATE");
stonesoup_stack_buff_64[stonesoup_oc_i] = stonesoup_toupper(stonesoup_stack_buff_64[stonesoup_oc_i]);
stonesoup_printf("%s\n",stonesoup_stack_buff_64);
stonesoup_printf("strlen size = %d\n",strlen(jenna_resicken));
stonesoup_printf("strlen size = %d\n",strlen(stonesoup_other_buff[7]));
if (middled_nontenableness != 0)
free(((char *)middled_nontenableness));
void stonesoup_printf(char * format, ...) {
stonesoup_printf("strlen size = %d\n",strlen(stonesoup_other_buff[7]));
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_stack_buff_64", stonesoup_stack_buff_64, "FINAL-STATE");
int stonesoup_toupper(int c)
return c;
stonesoup_stack_buff_64[stonesoup_oc_i] = stonesoup_toupper(stonesoup_stack_buff_64[stonesoup_oc_i]);
1
---------------------------------
10961 71479/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_34.c cppfunc 53
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_34_unionType myUnion;
char * data = myUnion.unionSecond;
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
10962 73170/CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_62.cpp cppfunc 39
data = (wchar_t *)malloc(100*sizeof(wchar_t));
badSource(data);
void badSource(wchar_t * &data);
wcscpy(dest, data);
printWLine(data);
free(data);
1
---------------------------------
10963 72203/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_44.c cppfunc 38
static void badSink(wchar_t * data)
SNPRINTF(data, 100, L"%s", source);
printWLine(data);
free(data);
1
---------------------------------
10964 67336/CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54.c cppfunc 32
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
10965 72090/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_11.c cppfunc 40
data = NULL;
data[0] = L'\0';
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
10966 70894/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_15.c cppfunc 49
data = NULL;
data = (char *)malloc(10*sizeof(char));
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10967 199233/buffer_overrun_dynamic.c cppfunc 515
int *buf1=(int*) calloc(5,sizeof(int));
int *buf2=(int*) calloc(3,sizeof(int));
for(i=0;i<5;i++)
*(buf1+i)=i;
*(buf2+*(buf1+5))=1;
free(buf2);
1
---------------------------------
10968 71181/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_14.c cppfunc 43
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
10969 70401/CWE122_Heap_Based_Buffer_Overflow__CWE135_02.c cppfunc 46
data = NULL;
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
10970 70517/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_32.c cppfunc 73
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
10971 72892/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_81_goodG2B.cpp cppfunc 33
void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_81_goodG2B::action(char * data) const
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
10972 153079/cmdline.c cppfunc 108
stonesoup_printf("%s\n", stonesoup_data.buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10973 153001/avpacket.c cppfunc 77
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10974 153599/mem_dbg.c cppfunc 921
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof (struct stonesoup_struct));
stonesoup_data->buff_pointer = stonesoup_data->buffer;
strncpy(stonesoup_data->buffer, infirmable_gerardia, strlen(infirmable_gerardia) + 1);
stonesoup_ptr_deref = strlen( stonesoup_data->buff_pointer);
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
1
---------------------------------
10975 79344/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_07.c cppfunc 61
va_list args;
va_start(args, data);
vsnprintf(dest, 100-1, data, args);
va_end(args);
1
---------------------------------
10976 152957/heapam.c inputfunc 162
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&fairway_obsessions,"CAMPO_COPROSE");
if (fairway_obsessions != 0) {;
reheighten_watchung . paroecism_thersitical = fairway_obsessions;
dks_melisma = ((char *)reheighten_watchung . paroecism_thersitical);
if (strlen(dks_melisma) < 20) {
realpath(dks_melisma, stonesoup_data.base_path);
if (reheighten_watchung . paroecism_thersitical != 0)
free(((char *)reheighten_watchung . paroecism_thersitical));
1
---------------------------------
10977 153466/subtrans.c cppfunc 442
spirepole_essig = ((char *)(impassibleness_chevret - 5)[38]);
stonesoup_buff_size = strlen(spirepole_essig) + 1;
stonesoup_other_size = 64;
stonesoup_other_buff = (char*) malloc (stonesoup_other_size * sizeof (char));
spirepole_essig[stonesoup_buff_size - stonesoup_i - 1];
stonesoup_other_buff[stonesoup_other_size - stonesoup_i - 1] =
stonesoup_printf("%02x",stonesoup_other_buff[stonesoup_other_size - stonesoup_i - 1]);
free (stonesoup_other_buff);
void stonesoup_printf(char * format, ...) {
free (stonesoup_other_buff);
1
---------------------------------
10978 153104/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&sauerkrauts_antisemitism,"DENNYSVILLE_PLEASING");
if (sauerkrauts_antisemitism != 0) {;
recorde_iconodulist = ((char *)sauerkrauts_antisemitism);
strcpy(stonesoup_data->buffer, recorde_iconodulist);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_data->buffer);
for (; stonesoup_i < stonesoup_opt_var; ++stonesoup_i) {
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "FINAL-STATE");
free(stonesoup_data);
if (sauerkrauts_antisemitism != 0)
free(((char *)sauerkrauts_antisemitism));
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->after(stonesoup_data->buffer[stonesoup_i]));
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%c",stonesoup_data->after(stonesoup_data->buffer[stonesoup_i]));
1
---------------------------------
10979 70498/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_03.c cppfunc 70
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
10980 70881/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_02.c cppfunc 43
data = NULL;
data = (char *)malloc(10*sizeof(char));
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10981 72373/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_06.c cppfunc 43
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strncat(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
10982 71184/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_17.c cppfunc 44
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
10983 72369/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_02.c cppfunc 39
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strncat(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
10984 153533/dirent_uri.c inputfunc 142
atef_kodurite = getenv("SILKMEN_OVEREMPIRICALLY");
if (atef_kodurite != 0) {;
thesmothetes_milyukov = atef_kodurite;
audiovisual_enhydris[ *( *nefandousness_belonging)] = thesmothetes_milyukov;
stomatodynia_vandyke = audiovisual_enhydris[ *( *nefandousness_belonging)];
repegged_woodfish = ((char *)stomatodynia_vandyke);
tracepoint(stonesoup_trace, variable_buffer_info, "STONESOUP_TAINT_SOURCE", strlen(repegged_woodfish)+1, repegged_woodfish, "TAINTED-SOURCE");
strncpy(stonesoup_data->buffer, repegged_woodfish, strlen(repegged_woodfish) + 1);
1
---------------------------------
10985 148966/packet-cip.c cppfunc 3308
dissect_cip_date_and_time(tree, tvb, offset, *(attr->phf));
expert_add_info_format(pinfo, item, PI_PROTOCOL, PI_WARN, "Unsupported Datatype");
att_size = dissect_cip_attribute(pinfo, att_tree, att_item, tvb, attr, offset, tvb_reported_length_remaining(tvb, offset));
proto_item_set_len(att_item, att_size+4);
att_size = dissect_cip_attribute(pinfo, att_tree, att_item, tvb, attr, offset, tvb_reported_length_remaining(tvb, offset));
dissect_cip_attribute(packet_info *pinfo, proto_tree *tree, proto_item *item, tvbuff_t *tvb,
consumed = attr->pdissect(pinfo, tree, item, tvb, offset, total_len);
return consumed;
att_size = dissect_cip_attribute(pinfo, att_tree, att_item, tvb, attr, offset, tvb_reported_length_remaining(tvb, offset));
offset += att_size;
att_size = dissect_cip_attribute(pinfo, att_tree, att_item, tvb, attr, offset, tvb_reported_length_remaining(tvb, offset));
attribute_info_t* attr, int offset, int total_len)
temp_data = tvb_get_letohs( tvb, offset);
computed_time = CIP_TIMEBASE+(temp_data*60*60*24);
date = gmtime(&computed_time);
att_size = dissect_cip_attribute(pinfo, att_tree, att_item, tvb, attr, offset, tvb_reported_length_remaining(tvb, offset));
offset += att_size;
att_size = dissect_cip_attribute(pinfo, att_tree, att_item, tvb, attr, offset, tvb_reported_length_remaining(tvb, offset));
attribute_info_t* attr, int offset, int total_len)
temp_data = tvb_get_letohs( tvb, offset);
computed_time = CIP_TIMEBASE+(temp_data*60*60*24);
date = gmtime(&computed_time);
void dissect_cip_date_and_time(proto_tree *tree, tvbuff_t *tvb, int offset, int hf_datetime)
proto_tree_add_time(tree, hf_datetime, tvb, offset, 6, &computed_time);
dissect_cip_date_and_time(tree, tvb, offset, *(attr->phf));
1
---------------------------------
10986 153783/string.c cppfunc 82
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10987 153122/gimpdialogfactory.c cppfunc 122
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
10988 70649/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_10.c cppfunc 146
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
10989 153718/hashfn.c cppfunc 222
return c - 32;
hepsiba_bretwalda = temenus_interrelation(seamrog_creedless);
kinnor_eldorado(nonamorous_ichthyopsida,hepsiba_bretwalda);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before = stonesoup_toupper;
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after = stonesoup_toupper;
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->before", stonesoup_data->before, &stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->after", stonesoup_data->after, &stonesoup_data->after, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "FINAL-STATE");
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
free(stonesoup_data);
void kinnor_eldorado(int world_kachcha,struct drago_unlikeliest magellanian_visitorial)
electrophilic_lionized = ((char *)magellanian_visitorial . stempel_outdraft);
stonesoup_taint_len = ((int )(strlen(electrophilic_lionized)));
stonesoup_data->buffer[stonesoup_buff_size] = electrophilic_lionized[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free(stonesoup_data);
1
---------------------------------
10990 72775/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_34.c cppfunc 51
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_34_unionType myUnion;
wchar_t * data = myUnion.unionSecond;
SNPRINTF(dest, wcslen(data), L"%s", data);
printWLine(data);
free(data);
1
---------------------------------
10991 148966/packet-ber.c cppfunc 5010
guint i = 1;
ber_decode_as_foreach(ber_add_syntax_name, &i);
qsort(&syntax_names[1], i - 1, sizeof(value_string), cmp_value_string);
void ber_decode_as_foreach(GHFunc func, gpointer user_data)
ber_decode_as_foreach(ber_add_syntax_name, &i);
qsort(&syntax_names[1], i - 1, sizeof(value_string), cmp_value_string);
1
---------------------------------
10992 72186/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_11.c cppfunc 46
data = NULL;
data[0] = L'\0';
SNPRINTF(data, 100, L"%s", source);
printWLine(data);
free(data);
1
---------------------------------
10993 70834/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_03.c cppfunc 43
data = NULL;
data = (char *)malloc(10*sizeof(char));
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
10994 79491/CWE134_Uncontrolled_Format_String__char_console_snprintf_10.c inputfunc 46
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
SNPRINTF(dest, 100-1, data);
1
---------------------------------
10995 73054/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_15.c cppfunc 44
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
10996 70953/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_42.c cppfunc 46
data = (char *)malloc(10*sizeof(char));
return data;
data = badSource(data);
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
1
---------------------------------
10997 72954/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_11.c cppfunc 40
data = NULL;
data[0] = L'\0';
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
10998 70737/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_02.c cppfunc 42
data = NULL;
data = (char *)malloc(10*sizeof(char));
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
10999 153638/oids.c cppfunc 1398
return c - 32;
stonesoup_data = (struct stonesoup_struct *) malloc (sizeof(struct stonesoup_struct));
stonesoup_data->buffer[64 - 1] = '\0';
stonesoup_data->buff_pointer = stonesoup_data->buffer;
tracepoint(stonesoup_trace, variable_buffer_info, "stonesoup_data->buffer", strlen(stonesoup_data->buffer)+1, stonesoup_data->buffer, "TRIGGER-STATE");
strncpy(stonesoup_data->buffer, stonesoup_source, sizeof(stonesoup_source));
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_data->buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
int stonesoup_toupper(int c) {
return c;
stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_data->buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
1
---------------------------------
11000 148804/strings.c cppfunc 103
va_list aq;
va_copy(aq, ap);
res = vsnprintf((*buf)->__AST_STR_STR + offset, (*buf)->__AST_STR_LEN - offset, fmt, aq);
va_end(aq);
1
---------------------------------
11001 79347/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_10.c cppfunc 56
va_list args;
va_start(args, data);
vsnprintf(dest, 100-1, data, args);
va_end(args);
1
---------------------------------
11002 72196/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_31.c cppfunc 46
data[0] = L'\0';
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
SNPRINTF(data, 100, L"%s", source);
printWLine(data);
free(data);
1
---------------------------------
11003 153487/error.c cppfunc 101
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11004 66613/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_82a.cpp cppfunc 31
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11005 153000/color.c cppfunc 120
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11006 148966/packet-sdp.c cppfunc 1647
static void dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) {
colon_offset = tvb_find_guint8(tvb, offset, -1, ':');
tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
static gint find_sdp_media_attribute_names(tvbuff_t *tvb, int offset, guint len)
(tvb_strncaseeql(tvb, offset, sdp_media_attribute_names[i].name, len) == 0))
offset = 0;
colon_offset = tvb_find_guint8(tvb, offset, -1, ':');
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
offset = colon_offset + 1;
offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
attribute_value = tvb_get_ephemeral_string(tvb, offset, tvb_length_remaining(tvb, offset));
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
tokenlen = next_offset - offset;
proto_tree_add_item(sdp_media_attribute_tree, hf_media_format, tvb,
offset, tokenlen, ENC_ASCII|ENC_NA);
payload_type = tvb_get_ephemeral_string(tvb, offset, tokenlen);
*key2 = atol((char*)payload_type);
1
---------------------------------
11007 153059/color.c cppfunc 118
stonesoup_printf("%s\n",stonesoup_base_path);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11008 72758/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_07.c cppfunc 50
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data[100-1] = L'\0';
SNPRINTF(dest, wcslen(data), L"%s", data);
printWLine(data);
free(data);
1
---------------------------------
11009 70744/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_09.c cppfunc 42
data = NULL;
data = (char *)malloc(10*sizeof(char));
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
11010 72419/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_04.c cppfunc 46
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strncpy(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
11011 152885/color.c cppfunc 90
stonesoup_printf("%s\n", stonesoup_data.buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11012 62952/CWE121_Stack_Based_Buffer_Overflow__CWE135_05.c cppfunc 47
data = NULL;
data = (void *)WIDE_STRING;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
1
---------------------------------
11013 62981/CWE121_Stack_Based_Buffer_Overflow__CWE135_61.c cppfunc 41
data = CWE121_Stack_Based_Buffer_Overflow__CWE135_61b_badSource(data);
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
11014 72105/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_42.c cppfunc 43
data[0] = L'\0';
return data;
data = badSource(data);
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
11015 153468/utils.c cppfunc 95
stonesoup_printf("%c",stonesoup_data.before(stonesoup_data.buffer[stonesoup_i]));
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11016 153244/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&plusiinae_skeletin,"DIETARIES_FLOCCULATING");
if (plusiinae_skeletin != 0) {;
fugitating_hydrophilite = ((char *)plusiinae_skeletin);
tracepoint(stonesoup_trace, variable_buffer_info, "STONESOUP_TAINT_SOURCE", strlen(fugitating_hydrophilite)+1, fugitating_hydrophilite, "TAINTED-SOURCE");
strncpy(stonesoup_data->buffer, fugitating_hydrophilite, strlen(fugitating_hydrophilite) + 1);
if (plusiinae_skeletin != 0)
free(((char *)plusiinae_skeletin));
1
---------------------------------
11017 153534/string.c cppfunc 1166
void tesselate_hulled(int imager_upgrading,char *scolopendridae_oregano)
underbrace_adp = ((char *)scolopendridae_oregano);
stonesoup_buffer = malloc((strlen(underbrace_adp) + 1) * sizeof(char ));
strcpy(stonesoup_buffer,underbrace_adp);
stonesoup_printf("Index of first char: %i\n",stonesoup_process_buffer(stonesoup_buffer));
free(stonesoup_buffer);
char stonesoup_process_buffer(char *buffer_param)
free(buffer_param);
free(stonesoup_buffer);
1
---------------------------------
11018 153327/e_camellia.c cppfunc 632
return c - 32;
return c;
unbuilded_bolshevist = ((char *)( *dilleniaceae_santal) . esme_abiology);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before = stonesoup_toupper;
memset(stonesoup_data->buffer,0,64);
stonesoup_data->after = stonesoup_toupper;
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->before", stonesoup_data->before, &stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->after", stonesoup_data->after, &stonesoup_data->after, "INITIAL-STATE");
strcpy(stonesoup_data->buffer, unbuilded_bolshevist);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_data->buffer);
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->after(stonesoup_data->buffer[stonesoup_i]));
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "FINAL-STATE");
free(stonesoup_data);
1
---------------------------------
11019 70481/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_61.c cppfunc 76
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
11020 153225/color.c cppfunc 118
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11021 72272/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_01.c cppfunc 36
data[100-1] = '\0';
memcpy(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11022 72434/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_21.c cppfunc 49
data = (char *)malloc(100*sizeof(char));
data = badSource(data);
static char * badSource(char * data)
data[100-1] = '\0';
return data;
data = badSource(data);
strncpy(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
11023 70979/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_04.c cppfunc 49
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11024 72759/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_08.c cppfunc 58
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data[100-1] = L'\0';
SNPRINTF(dest, wcslen(data), L"%s", data);
printWLine(data);
free(data);
1
---------------------------------
11025 71000/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_41.c cppfunc 35
data = (wchar_t *)malloc(10*sizeof(wchar_t));
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_41_badSink(data);
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_41_badSink(wchar_t * data)
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11026 71098/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_43.cpp cppfunc 48
data = (wchar_t *)malloc(10*sizeof(wchar_t));
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
1
---------------------------------
11027 72342/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_33.cpp cppfunc 42
char * &dataRef = data;
char * data = dataRef;
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11028 71456/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_01.c cppfunc 43
data[0] = '\0';
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
11029 153286/mux.c cppfunc 106
stonesoup_printf("Error: Failed to allocate memory\n");
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11030 71213/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_82_bad.cpp cppfunc 32
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_82_bad::action(wchar_t * data)
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
11031 79496/CWE134_Uncontrolled_Format_String__char_console_snprintf_15.c inputfunc 47
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
SNPRINTF(dest, 100-1, data);
1
---------------------------------
11032 72965/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_32.c cppfunc 45
wchar_t * *dataPtr2 = &data;
wchar_t * data = *dataPtr2;
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11033 70643/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_04.c cppfunc 152
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
11034 79387/CWE134_Uncontrolled_Format_String__char_console_fprintf_02.c inputfunc 40
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
fprintf(stdout, data);
1
---------------------------------
11035 62976/CWE121_Stack_Based_Buffer_Overflow__CWE135_45.c cppfunc 37
data = (void *)WIDE_STRING;
CWE121_Stack_Based_Buffer_Overflow__CWE135_45_badData = data;
badSink();
void * data = CWE121_Stack_Based_Buffer_Overflow__CWE135_45_badData;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
1
---------------------------------
11036 67431/CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53.c cppfunc 32
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11037 153647/aviobuf.c cppfunc 1250
void visitorial_garfish(int cankered_pyrrophyllin,char *fritniency_floroun)
visitorial_garfish(cankered_pyrrophyllin,fritniency_floroun);
thackerayana_semipause = ((char *)((char *)fritniency_floroun));
stonesoup_heap_buff_64[64 - 1] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "INITIAL-STATE");
stonesoup_taint_len = ((int )(strlen(thackerayana_semipause)));
stonesoup_heap_buff_64[stonesoup_buff_size] = thackerayana_semipause[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
int stonesoup_toupper(int c)
return c - 32;
return c;
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
free(stonesoup_heap_buff_64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "FINAL-STATE");
free(stonesoup_heap_buff_64);
void entrench_babyfied(char *const gauzily_sass)
visitorial_garfish(ruesomeness_huntsmen,gauzily_sass);
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
1
---------------------------------
11038 153816/error.c cppfunc 237
plainsmen_overgird = ((char *)( *( *proliferated_gonytheca))[0]);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before[63] = '\0';
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after[63] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->before", stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->after", stonesoup_data->after, "INITIAL-STATE");
stonesoup_buff_size = ((int )(strlen(plainsmen_overgird)));
memcpy(stonesoup_data->buffer, plainsmen_overgird, 64);
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_printf(char * format, ...) {
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
1
---------------------------------
11039 153447/color.c cppfunc 90
stonesoup_printf("%s\n",stonesoup_buffer_stack);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11040 153671/color.c cppfunc 593
return c - 32;
stonesoup_buff = (char *) malloc (sizeof(char) * 20);
memset(stonesoup_buff, 0, 20);
realpath(unspiritually_ergotin, stonesoup_buff);
stonesoup_opt_var = strlen( stonesoup_buff);
stonesoup_toupper(stonesoup_buff[stonesoup_oc_i]);
stonesoup_buff[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_buff);
void stonesoup_printf(char * format, ...) {
free (stonesoup_buff);
int stonesoup_toupper(int c)
return c;
stonesoup_toupper(stonesoup_buff[stonesoup_oc_i]);
stonesoup_buff[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_buff);
1
---------------------------------
11041 153122/gimpdialogfactory.c cppfunc 2499
*stonesoup_tainted_buff = NULL;
*stonesoup_tainted_buff = NULL;
int petrescence_noncommitted = 596;
char *rocketers_beeregar;
stonesoup_read_taint(&rocketers_beeregar,"6271",petrescence_noncommitted);
shootee_pseudobia . krakow_dorados = ((char *)rocketers_beeregar);
coliseum_anfractuousness(shootee_pseudobia);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before[63] = '\0';
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after[63] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->before", stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->after", stonesoup_data->after, "INITIAL-STATE");
memcpy(stonesoup_data->buffer, revenants_simon, 64);
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void coliseum_anfractuousness(const struct renaming_anguillulidae studley_hesychastic)
revenants_simon = ((char *)((struct renaming_anguillulidae )studley_hesychastic) . krakow_dorados);
stonesoup_buff_size = ((int )(strlen(revenants_simon)));
memcpy(stonesoup_data->buffer, revenants_simon, 64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_printf(char * format, ...) {
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {
if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {
*stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));
stonesoup_read_taint(&rocketers_beeregar,"6271",petrescence_noncommitted);
shootee_pseudobia . krakow_dorados = ((char *)rocketers_beeregar);
coliseum_anfractuousness(shootee_pseudobia);
1
---------------------------------
11042 72099/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_22.c cppfunc 41
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_22_badSource(data);
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
11043 70895/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_16.c cppfunc 44
data = NULL;
data = (char *)malloc(10*sizeof(char));
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11044 71191/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_34.c cppfunc 50
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_34_unionType myUnion;
wchar_t * data = myUnion.unionSecond;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
11045 70890/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_11.c cppfunc 43
data = NULL;
data = (char *)malloc(10*sizeof(char));
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11046 153254/conf_mod.c cppfunc 154
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11047 153589/bio_err.c cppfunc 602
return c - 32;
stonesoup_buffer[stonesoup_buffer_len - 1] = '\0';
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_buffer);
int stonesoup_toupper(int c)
return c;
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
1
---------------------------------
11048 153267/stream.c cppfunc 236
stonesoup_heap_buff_64[63] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "INITIAL-STATE");
strncpy(stonesoup_heap_buff_64, globetrotter_prechallenge, 64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "TAINTED");
stonesoup_printf("%02x",stonesoup_heap_buff_64[stonesoup_ss_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
free( stonesoup_heap_buff_64);
void stonesoup_printf(char * format, ...) {
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
free( stonesoup_heap_buff_64);
1
---------------------------------
11049 73061/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_32.c cppfunc 43
char * *dataPtr2 = &data;
char * data = *dataPtr2;
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
11050 148966/strutil.c cppfunc 944
escape_string(char *buf, const char *string)
for (p = string; (c = *p) != '\0'; p++) {
else if (!isprint((unsigned char)c)) {
1
---------------------------------
11051 62971/CWE121_Stack_Based_Buffer_Overflow__CWE135_34.c cppfunc 49
CWE121_Stack_Based_Buffer_Overflow__CWE135_34_unionType myUnion;
void * data = myUnion.unionSecond;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
11052 62971/CWE121_Stack_Based_Buffer_Overflow__CWE135_34.c cppfunc 46
CWE121_Stack_Based_Buffer_Overflow__CWE135_34_unionType myUnion;
void * data = myUnion.unionSecond;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
1
---------------------------------
11053 153333/utils.c cppfunc 4958
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc (sizeof(struct stonesoup_struct));
memset(stonesoup_data->base_path, 0, 20);
stonesoup_data->buff_pointer = stonesoup_data->base_path;
realpath(outcaper_depreciator, stonesoup_data->base_path);
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
free (stonesoup_data);
void stonesoup_printf(char * format, ...) {
free (stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
1
---------------------------------
11054 70940/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_13.c cppfunc 43
data = NULL;
data = (char *)malloc(10*sizeof(char));
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
1
---------------------------------
11055 70452/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_05.c cppfunc 139
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
11056 72711/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_08.c cppfunc 53
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data[100-1] = L'\0';
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
11057 71009/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_61.c cppfunc 41
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_61b_badSource(data);
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11058 66316/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_64.c cppfunc 32
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11059 110484/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_45.c cppfunc 38
data = -1;
fscanf(stdin, "%d", &data);
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_45_badData = data;
badSink();
int data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_45_badData;
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11060 153324/aviobuf.c cppfunc 81
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11061 72094/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_15.c cppfunc 46
data = NULL;
data[0] = L'\0';
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
11062 72382/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_15.c cppfunc 45
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strncat(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
11063 148966/packet-sdp.c cppfunc 1378
bytes_tvb = tvb_new_child_real_data(tvb, buf, i, i);
proto_tree_add_text(tree, tvb, offset, tokenlen, "Debug; Analysed string: '%s'",
next_offset = tvb_find_guint8(tvb, offset, -1, '=');
offset = next_offset;
offset++;
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
item = proto_tree_add_uint(tree, hf_sdp_fmtp_mpeg4_profile_level_id, tvb, offset, tokenlen,
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);
offset++;
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
item = proto_tree_add_uint(tree, hf_sdp_fmtp_h263_profile, tvb, offset, tokenlen,
atol((char*)format_specific_parameter));
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
item = proto_tree_add_uint(tree, hf_sdp_fmtp_h263_level, tvb, offset, tokenlen,
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);
item = proto_tree_add_text(tree, tvb, offset, tokenlen, "Incorrectly coded, must be three bytes");
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
item = proto_tree_add_uint(tree, hf_sdp_h264_packetization_mode, tvb, offset, tokenlen,
comma_offset = tvb_find_guint8(tvb, offset, -1, ',');
data_p = tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_text(tree, tvb, offset, tokenlen, "NAL unit 1 string: %s", data_p);
data_tvb = base64_to_tvb(tvb, data_p);
show_reported_bounds_error(tvb, pinfo, tree);
data_p   = tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_text(tree, tvb, offset, tokenlen, "NAL unit 2 string: %s", data_p);
data_tvb = base64_to_tvb(tvb, data_p);
(tvb_strncaseeql(tvb, offset, sdp_media_attribute_names[i].name, len) == 0))
offset = 0;
colon_offset = tvb_find_guint8(tvb, offset, -1, ':');
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
offset = colon_offset + 1;
offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
attribute_value = tvb_get_ephemeral_string(tvb, offset, tvb_length_remaining(tvb, offset));
offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
hf_media_format, tvb, offset,
media_format = atoi((char*)tvb_get_ephemeral_string(tvb, offset, tokenlen));
payload_type = tvb_get_ephemeral_string(tvb, offset, tokenlen);
offset = next_offset + 1;
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
next_offset = tvb_find_guint8(tvb, offset, -1, ';');
offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
next_offset= tvb_length(tvb);
tokenlen = next_offset - offset;
hf_media_format_specific_parameter, tvb,
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
hf_media_format_specific_parameter, tvb,
offset = next_offset + 1;
offset, tokenlen, ENC_ASCII|ENC_NA);
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
decode_sdp_fmtp(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, gint offset, gint tokenlen, char *mime_type) {
end_offset = offset + tokenlen;
proto_tree_add_text(tree, tvb, offset, tokenlen, "Debug; Analysed string: '%s'",
next_offset = tvb_find_guint8(tvb, offset, -1, '=');
field_name = tvb_get_ephemeral_string(tvb, offset, tokenlen);
tokenlen = end_offset - offset;
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
atol((char*)format_specific_parameter));
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
hf_media_format_specific_parameter, tvb,
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
ascii_bytes_to_tvb(tvbuff_t *tvb, packet_info *pinfo, gint len, gchar *msg)
data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);
format_specific_parameter = tvb_get_ephemeral_string(tvb, offset, tokenlen);
atol((char*)format_specific_parameter));
data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);
static void dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) {
colon_offset = tvb_find_guint8(tvb, offset, -1, ':');
tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
static gint find_sdp_media_attribute_names(tvbuff_t *tvb, int offset, guint len)
sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);
next_offset = tvb_find_guint8(tvb, offset, -1, ';');
hf_media_format_specific_parameter, tvb,
decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
1
---------------------------------
11064 153212/utils.c cppfunc 4965
return c - 32;
stonesoup_buffer[stonesoup_buffer_len - 1] = '\0';
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_buffer);
int stonesoup_toupper(int c)
return c;
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
1
---------------------------------
11065 153810/pgstat.c cppfunc 4107
char* stonesoup_tainted_buff;
int buffer_size = 1000;
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
buffer_size = buffer_size * 2;
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
free(stonesoup_tainted_buff);
stonesoup_handle_taint(stonesoup_tainted_buff);
return c - 32;
cinemactic_unpreventative = 1;
mismanageable_shogged = ((void **)(((unsigned long )stentoraphonic_irregardless) * cinemactic_unpreventative * cinemactic_unpreventative)) + 5;
caliphates_pallmall = ((char *)((char *)( *(mismanageable_shogged - 5))));
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before = stonesoup_toupper;
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after = stonesoup_toupper;
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->before", stonesoup_data->before, &stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->after", stonesoup_data->after, &stonesoup_data->after, "INITIAL-STATE");
stonesoup_taint_len = ((int )(strlen(caliphates_pallmall)));
stonesoup_data->buffer[stonesoup_buff_size] = caliphates_pallmall[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
free(stonesoup_data);
void stonesoup_handle_taint(char *preselects_sertule)
autologous_undiaphanously = ((void *)preselects_sertule);
stentoraphonic_irregardless = &autologous_undiaphanously;
mismanageable_shogged = ((void **)(((unsigned long )stentoraphonic_irregardless) * cinemactic_unpreventative * cinemactic_unpreventative)) + 5;
caliphates_pallmall = ((char *)((char *)( *(mismanageable_shogged - 5))));
stonesoup_taint_len = ((int )(strlen(caliphates_pallmall)));
stonesoup_data->buffer[stonesoup_buff_size] = caliphates_pallmall[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
free(stonesoup_data);
1
---------------------------------
11066 153212/utils.c cppfunc 4969
char* stonesoup_tainted_buff;
int buffer_size = 1000;
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
buffer_size = buffer_size * 2;
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
free(stonesoup_tainted_buff);
stonesoup_handle_taint(stonesoup_tainted_buff);
dogmata_garibaldian = 5;
nonmalignantly_noncreditor = &dogmata_garibaldian;
boqueron_sequesterment =  *(chondrichthyes_caen +  *nonmalignantly_noncreditor);
worldman_pompster = ((char *)boqueron_sequesterment);
strncpy(stonesoup_buffer, worldman_pompster, stonesoup_buffer_len);
stonesoup_buffer_ptr = malloc(65528);
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "CROSSOVER-STATE");
*stonesoup_buffer_ptr = worldman_pompster;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
tracepoint(stonesoup_trace, variable_address, "*stonesoup_buffer_ptr", *stonesoup_buffer_ptr, "TRIGGER-STATE");
stonesoup_tainted_len = strlen( *stonesoup_buffer_ptr);
free(stonesoup_buffer_ptr);
void stonesoup_handle_taint(char *paradoxurus_furl)
adephaga_concordial = paradoxurus_furl;
chondrichthyes_caen[5] = adephaga_concordial;
boqueron_sequesterment =  *(chondrichthyes_caen +  *nonmalignantly_noncreditor);
worldman_pompster = ((char *)boqueron_sequesterment);
strncpy(stonesoup_buffer, worldman_pompster, stonesoup_buffer_len);
*stonesoup_buffer_ptr = worldman_pompster;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
free(stonesoup_buffer_ptr);
1
---------------------------------
11067 153554/error.c cppfunc 100
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11068 72282/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_11.c cppfunc 39
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
memcpy(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11069 153775/color.c cppfunc 120
stonesoup_printf("%s\n",stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11070 72293/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_32.c cppfunc 44
char * *dataPtr2 = &data;
char * data = *dataPtr2;
memcpy(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11071 79574/CWE134_Uncontrolled_Format_String__char_console_vfprintf_81_goodG2B.cpp cppfunc 33
va_list args;
va_start(args, data);
vfprintf(stdout, data, args);
va_end(args);
1
---------------------------------
11072 79359/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_32.c cppfunc 56
va_list args;
va_start(args, data);
vsnprintf(dest, 100-1, data, args);
va_end(args);
1
---------------------------------
11073 72866/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_21.c cppfunc 50
data = NULL;
data = badSource(data);
static char * badSource(char * data)
data[0] = '\0';
return data;
data = badSource(data);
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
11074 66325/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_82a.cpp cppfunc 31
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11075 72875/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_44.c cppfunc 32
static void badSink(char * data)
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
11076 72805/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_06.c cppfunc 44
data = NULL;
data[0] = '\0';
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
11077 153686/color.c cppfunc 118
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11078 110517/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_14.c cppfunc 131
data = -1;
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11079 72288/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_17.c cppfunc 40
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
memcpy(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11080 72093/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_14.c cppfunc 40
data = NULL;
data[0] = L'\0';
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
11081 148966/packet-sdp.c cppfunc 1175
dissect_sdp_media(tvbuff_t *tvb, proto_item *ti,
offset = 0;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
proto_tree_add_item(sdp_media_tree, hf_media_media, tvb, offset, tokenlen,
transport_info->media_type = (char*)tvb_get_ephemeral_string(tvb, offset, tokenlen);
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
tokenlen = next_offset - offset;
next_offset = tvb_find_guint8(tvb, offset, tokenlen, '/');
transport_info->media_port[transport_info->media_count] = (char*)tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
proto_tree_add_item(sdp_media_tree, hf_media_portcount, tvb, offset,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
transport_info->media_port[transport_info->media_count] = (char*)tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
transport_info->media_proto[transport_info->media_count] = (char*)tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_item(sdp_media_tree, hf_media_proto, tvb, offset, tokenlen,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
tokenlen = tvb_length_remaining(tvb, offset);
tokenlen = next_offset - offset;
media_format = tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_string(sdp_media_tree, hf_media_format, tvb, offset,
media_format = tvb_get_ephemeral_string(tvb, offset, tokenlen);
tokenlen, val_to_str_ext(atol((char*)media_format), &rtp_payload_type_vals_ext, "%u"));
media_format = tvb_get_ephemeral_string(tvb, offset, tokenlen);
transport_info->media[transport_info->media_count].pt[idx] = atol((char*)media_format);
proto_tree_add_item(sdp_media_tree, hf_media_format, tvb, offset,
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
media_format = tvb_get_ephemeral_string(tvb, offset, tokenlen);
transport_info->media[transport_info->media_count].pt[idx] = atol((char*)media_format);
1
---------------------------------
11082 73044/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_05.c cppfunc 45
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
11083 148966/packet-sdp.c cppfunc 1173
dissect_sdp_media(tvbuff_t *tvb, proto_item *ti,
offset = 0;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
proto_tree_add_item(sdp_media_tree, hf_media_media, tvb, offset, tokenlen,
transport_info->media_type = (char*)tvb_get_ephemeral_string(tvb, offset, tokenlen);
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
tokenlen = next_offset - offset;
next_offset = tvb_find_guint8(tvb, offset, tokenlen, '/');
transport_info->media_port[transport_info->media_count] = (char*)tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
proto_tree_add_item(sdp_media_tree, hf_media_portcount, tvb, offset,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
transport_info->media_port[transport_info->media_count] = (char*)tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
transport_info->media_proto[transport_info->media_count] = (char*)tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_item(sdp_media_tree, hf_media_proto, tvb, offset, tokenlen,
offset = next_offset + 1;
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
tokenlen = tvb_length_remaining(tvb, offset);
tokenlen = next_offset - offset;
media_format = tvb_get_ephemeral_string(tvb, offset, tokenlen);
proto_tree_add_string(sdp_media_tree, hf_media_format, tvb, offset,
media_format = tvb_get_ephemeral_string(tvb, offset, tokenlen);
tokenlen, val_to_str_ext(atol((char*)media_format), &rtp_payload_type_vals_ext, "%u"));
media_format = tvb_get_ephemeral_string(tvb, offset, tokenlen);
tokenlen, val_to_str_ext(atol((char*)media_format), &rtp_payload_type_vals_ext, "%u"));
proto_tree_add_item(sdp_media_tree, hf_media_format, tvb, offset,
next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
media_format = tvb_get_ephemeral_string(tvb, offset, tokenlen);
tokenlen, val_to_str_ext(atol((char*)media_format), &rtp_payload_type_vals_ext, "%u"));
1
---------------------------------
11084 110464/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_09.c cppfunc 42
data = -1;
fscanf(stdin, "%d", &data);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11085 62956/CWE121_Stack_Based_Buffer_Overflow__CWE135_09.c cppfunc 44
data = NULL;
data = (void *)WIDE_STRING;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
11086 62956/CWE121_Stack_Based_Buffer_Overflow__CWE135_09.c cppfunc 41
data = NULL;
data = (void *)WIDE_STRING;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
1
---------------------------------
11087 153493/mem_dbg.c cppfunc 211
stonesoup_printf("%s\n",stonesoup_base_path);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11088 153238/color.c cppfunc 118
stonesoup_printf("%s\n",stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11089 110326/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_15.c cppfunc 124
data = -1;
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11090 153498/mem_dbg.c cppfunc 240
stonesoup_printf("Error: Failed to allocate memory\n");
stonesoup_printf("%s\n", stonesoup_data.base_path);
stonesoup_printf("%s\n", stonesoup_data.buff_pointer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11091 110549/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_82_bad.cpp cppfunc 37
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_82_bad::action(int data)
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11092 70935/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_08.c cppfunc 57
data = NULL;
data = (char *)malloc(10*sizeof(char));
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
1
---------------------------------
11093 153427/utils.c cppfunc 3237
return c - 32;
superprinting_solemnization = ((char *)tintinnabulous_cryptocephalous . umquhile_decarboxylation);
stonesoup_heap_buffer_64 = (char*) malloc(64 * sizeof(char));
memset(stonesoup_heap_buffer_64,0,64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "INITIAL-STATE");
strcpy(stonesoup_heap_buffer_64, superprinting_solemnization);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_heap_buffer_64);
stonesoup_heap_buffer_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buffer_64[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "BEFORE-FREE");
stonesoup_printf("%s\n",stonesoup_heap_buffer_64);
void stonesoup_printf(char * format, ...) {
free(stonesoup_heap_buffer_64);
int stonesoup_toupper(int c)
return c;
stonesoup_heap_buffer_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buffer_64[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "BEFORE-FREE");
stonesoup_printf("%s\n",stonesoup_heap_buffer_64);
1
---------------------------------
11094 153476/column.c cppfunc 1429
return c - 32;
stonesoup_buffer[64 - 1] = '\0';
tracepoint(stonesoup_trace, variable_buffer_info, "stonesoup_buffer", strlen(stonesoup_buffer)+1, stonesoup_buffer, "TRIGGER-STATE");
strncpy(stonesoup_buffer, stonesoup_source, sizeof(stonesoup_source));
stonesoup_opt_var = strlen(stonesoup_buffer);
stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_buffer);
int stonesoup_toupper(int c)
return c;
stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_buffer[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_buffer);
1
---------------------------------
11095 153598/tile-manager.c cppfunc 48
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11096 72863/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_16.c cppfunc 41
data = NULL;
data[0] = '\0';
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
11097 72716/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_13.c cppfunc 39
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data[100-1] = L'\0';
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
11098 153203/tile-manager.c cppfunc 79
stonesoup_printf("%s\n", stonesoup_data);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11099 153335/emem.c cppfunc 194
stonesoup_printf("%s\n", stonesoup_data);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11100 71476/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_31.c cppfunc 46
data[0] = '\0';
char * dataCopy = data;
char * data = dataCopy;
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
11101 153689/tile-manager.c cppfunc 78
stonesoup_printf("%c",stonesoup_data.before(stonesoup_data.buffer[stonesoup_i]));
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11102 70907/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_44.c cppfunc 36
static void badSink(char * data)
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11103 66270/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_66.c cppfunc 33
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11104 1572/into1-bad.c cppfunc 45
main(int argc, char **argv)
n = strtoul(argv[1], 0, 10);
test(n);
test(unsigned int n)
int *buf, i;
buf = malloc(n * sizeof *buf);
for(i = 0; i < n; i++)
buf[i] = i;
printf("%x ", buf[i]);
free(buf);
1
---------------------------------
11105 70756/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_31.c cppfunc 42
data = (char *)malloc(10*sizeof(char));
char * dataCopy = data;
char * data = dataCopy;
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
11106 153158/resowner.c cppfunc 166
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11107 66358/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_52.c cppfunc 38
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11108 153616/mux.c cppfunc 103
stonesoup_printf("Error: Failed to allocate memory\n");
stonesoup_printf("%02x",stonesoup_heap_buff_64[stonesoup_ss_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11109 72389/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_32.c cppfunc 44
char * *dataPtr2 = &data;
char * data = *dataPtr2;
strncat(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
11110 199283/memory_allocation_failure.c cppfunc 384
ret = MAX_VAL;
ret=5;
return ret;
memory_allocation_failure_011_gbl_u1 = (memory_allocation_failure_011_uni_001 * )malloc(memory_allocation_failure_011_func_001(0)*sizeof( memory_allocation_failure_011_uni_001 ));
1
---------------------------------
11111 72276/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_05.c cppfunc 46
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
memcpy(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11112 153082/config.c cppfunc 106
stonesoup_printf("%s\n", stonesoup_data.base_path);
stonesoup_printf("%s\n", stonesoup_data.buff_pointer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11113 152895/color.c cppfunc 571
return c - 32;
pinnulae_toldo = getenv("JUNCTION_COITUS");
hysteromorphous_poter = ((char *)pinnulae_toldo);
stonesoup_heap_buff_64[64 - 1] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "INITIAL-STATE");
stonesoup_taint_len = ((int )(strlen(hysteromorphous_poter)));
stonesoup_heap_buff_64[stonesoup_buff_size] = hysteromorphous_poter[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
int stonesoup_toupper(int c)
return c;
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
free(stonesoup_heap_buff_64);
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
1
---------------------------------
11114 79553/CWE134_Uncontrolled_Format_String__char_console_vfprintf_34.c cppfunc 40
va_list args;
va_start(args, data);
vfprintf(stdout, data, args);
va_end(args);
1
---------------------------------
11115 148881/ascend-scanner.c cppfunc 1379
(yy_last_accepting_cpos) = yy_cp;
yy_cp = (yy_last_accepting_cpos);
YY_DO_BEFORE_ACTION;
*yy_cp = (yy_hold_char);
int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
yy_next_state = yy_try_NUL_trans( yy_current_state );
if ( ascendwrap( ) )
(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
yy_cp = (yy_c_buf_p);
YY_DO_BEFORE_ACTION;
*yy_cp = (yy_hold_char);
yy_bp = yy_cp;
YY_DO_BEFORE_ACTION;
ascendlval.d = strtol(ascendtext, NULL, 10);
1
---------------------------------
11116 73040/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_01.c cppfunc 35
data[100-1] = '\0';
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
11117 62968/CWE121_Stack_Based_Buffer_Overflow__CWE135_31.c cppfunc 42
data = (void *)WIDE_STRING;
void * dataCopy = data;
void * data = dataCopy;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
11118 71372/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_13.c cppfunc 40
data = NULL;
data[0] = '\0';
strncat(data, source, 100);
printLine(data);
free(data);
1
---------------------------------
11119 153471/mux.c cppfunc 956
*stonesoup_tainted_buff = NULL;
*stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));
*stonesoup_tainted_buff = NULL;
return c - 32;
int contractable_hoptoads = 596;
char *countergauge_laggins;
stonesoup_read_taint(&countergauge_laggins,"3876",contractable_hoptoads);
blebs_outrolled = ((int )(strlen(countergauge_laggins)));
varooms_stearn = ((char *)(malloc(blebs_outrolled + 1)));
memset(varooms_stearn,0,blebs_outrolled + 1);
memcpy(varooms_stearn,countergauge_laggins,blebs_outrolled);
myodynamic_kessler = &varooms_stearn;
CARIFTA_FAKER(myodynamic_kessler);
stonesoup_heap_buff_64[64 - 1] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
void notariate_disscussive(char **trinidad_camatina)
protologist_hypertragic = ((char *)( *trinidad_camatina));
stonesoup_taint_len = ((int )(strlen(protologist_hypertragic)));
stonesoup_heap_buff_64[stonesoup_buff_size] = protologist_hypertragic[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
free(stonesoup_heap_buff_64);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {
if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {
*stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));
stonesoup_read_taint(&countergauge_laggins,"3876",contractable_hoptoads);
blebs_outrolled = ((int )(strlen(countergauge_laggins)));
memcpy(varooms_stearn,countergauge_laggins,blebs_outrolled);
myodynamic_kessler = &varooms_stearn;
CARIFTA_FAKER(myodynamic_kessler);
int stonesoup_toupper(int c)
return c;
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
free(stonesoup_heap_buff_64);
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
1
---------------------------------
11120 153233/bio_err.c cppfunc 224
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc (sizeof(struct stonesoup_struct));
memset(stonesoup_data->base_path, 0, 20);
stonesoup_data->buff_pointer = stonesoup_data->base_path;
realpath(entosclerite_urination, stonesoup_data->base_path);
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
free (stonesoup_data);
void stonesoup_printf(char * format, ...) {
free (stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
1
---------------------------------
11121 199284/memory_allocation_failure.c cppfunc 727
ret = MAX_VAL_4;
ret=5;
return ret;
memory_allocation_failure_016_gbl_ptr1 = (int *) malloc (memory_allocation_failure_016_func_001(0)*sizeof(int));
memory_allocation_failure_016_gbl_ptr2 = (int *) malloc (memory_allocation_failure_016_func_001(0)*sizeof(int));
memory_allocation_failure_016_func_002(0);
free(memory_allocation_failure_016_gbl_ptr2);
1
---------------------------------
11122 199284/memory_allocation_failure.c cppfunc 726
ret = MAX_VAL_4;
ret=5;
return ret;
memory_allocation_failure_016_gbl_ptr1 = (int *) malloc (memory_allocation_failure_016_func_001(0)*sizeof(int));
memory_allocation_failure_016_gbl_ptr2 = (int *) malloc (memory_allocation_failure_016_func_001(0)*sizeof(int));
memory_allocation_failure_016_func_002(0);
free(memory_allocation_failure_016_gbl_ptr1);
1
---------------------------------
11123 72949/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_06.c cppfunc 44
data = NULL;
data[0] = L'\0';
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11124 153499/color.c cppfunc 561
return c - 32;
stonesoup_data = (char*) malloc(8 * sizeof(char));
strncpy(stonesoup_data, pseudobrachium_sylvestral, strlen(pseudobrachium_sylvestral) + 1);
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i) {
stonesoup_printf("%s\n", stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i) {
stonesoup_printf("%s\n", stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
1
---------------------------------
11125 70540/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_81_goodG2B.cpp cppfunc 50
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
11126 72387/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_22.c cppfunc 40
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_22_badSource(data);
strncat(dest, data, strlen(data));
printLine(data);
free(data);
1
---------------------------------
11127 79554/CWE134_Uncontrolled_Format_String__char_console_vfprintf_41.c inputfunc 55
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
badSink(data);
static void badSink(char * data)
badVaSink(data, data);
static void badVaSink(char * data, ...)
va_start(args, data);
vfprintf(stdout, data, args);
1
---------------------------------
11128 110395/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_63.c cppfunc 37
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
1
---------------------------------
11129 71482/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_43.cpp cppfunc 51
data[0] = '\0';
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
11130 79403/CWE134_Uncontrolled_Format_String__char_console_fprintf_18.c inputfunc 40
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
fprintf(stdout, data);
1
---------------------------------
11131 110316/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_05.c cppfunc 125
data = -1;
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11132 71189/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_32.c cppfunc 48
wchar_t * *dataPtr2 = &data;
wchar_t * data = *dataPtr2;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
11133 199235/buffer_underrun_dynamic.c cppfunc 317
int *buf=(int*) calloc(5,sizeof(int));
free(buf);
dynamic_buffer_underrun_017_func_001(5);
void dynamic_buffer_underrun_017_func_001 (int index)
*(buf -index) = 1;
free(buf);
1
---------------------------------
11134 72634/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_43.cpp cppfunc 44
data[100-1] = L'\0';
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
printWLine(data);
free(data);
1
---------------------------------
11135 72335/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_16.c cppfunc 40
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11136 153402/color.c cppfunc 630
*stonesoup_tainted_buff = NULL;
*stonesoup_tainted_buff = NULL;
int sikimi_illawarra = 44;
char *ruches_matronna;
stonesoup_read_taint(&ruches_matronna,"4477",sikimi_illawarra);
presecular_obote = ((char *)ruches_matronna);
strncpy(stonesoup_buffer, presecular_obote, stonesoup_buffer_len);
stonesoup_buffer_ptr = malloc(65528);
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "CROSSOVER-STATE");
*stonesoup_buffer_ptr = presecular_obote;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
tracepoint(stonesoup_trace, variable_address, "*stonesoup_buffer_ptr", *stonesoup_buffer_ptr, "TRIGGER-STATE");
stonesoup_tainted_len = strlen( *stonesoup_buffer_ptr);
free(stonesoup_buffer_ptr);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {
if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {
*stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));
stonesoup_read_taint(&ruches_matronna,"4477",sikimi_illawarra);
presecular_obote = ((char *)ruches_matronna);
strncpy(stonesoup_buffer, presecular_obote, stonesoup_buffer_len);
*stonesoup_buffer_ptr = presecular_obote;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
free(stonesoup_buffer_ptr);
1
---------------------------------
11137 153280/hashfn.c cppfunc 81
stonesoup_printf("%s\n", stonesoup_data.base_path);
stonesoup_printf("%s\n", stonesoup_data.buff_pointer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11138 70887/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_08.c cppfunc 57
data = NULL;
data = (char *)malloc(10*sizeof(char));
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11139 153627/e_bf.c cppfunc 318
return c - 32;
stonesoup_buffer[stonesoup_buffer_len - 1] = '\0';
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
int stonesoup_toupper(int c)
return c;
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_buffer);
1
---------------------------------
11140 153387/subtrans.c cppfunc 103
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11141 153275/column.c cppfunc 1286
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc (sizeof(struct stonesoup_struct));
memset(stonesoup_data->base_path, 0, 20);
stonesoup_data->buff_pointer = stonesoup_data->base_path;
realpath(crayons_tamburitza, stonesoup_data->base_path);
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
free (stonesoup_data);
void stonesoup_printf(char * format, ...) {
free (stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
1
---------------------------------
11142 71366/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_07.c cppfunc 46
data = NULL;
data[0] = '\0';
strncat(data, source, 100);
printLine(data);
free(data);
1
---------------------------------
11143 67436/CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_64.c cppfunc 32
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11144 72718/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_15.c cppfunc 45
data = (wchar_t *)malloc(100*sizeof(wchar_t));
data[100-1] = L'\0';
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
11145 153763/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&colation_prosecutes,"ODESSA_POLYGONALLY");
if (colation_prosecutes != 0) {;
waxy_shechina = ((char *)colation_prosecutes);
stonesoup_taint_len = ((int )(strlen(waxy_shechina)));
for (; stonesoup_taint_len >= 0; (--stonesoup_buff_size , --stonesoup_taint_len)) {
stonesoup_data->buffer[stonesoup_buff_size] = waxy_shechina[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
free(stonesoup_data);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "FINAL-STATE");
if (colation_prosecutes != 0)
free(((char *)colation_prosecutes));
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
1
---------------------------------
11146 70977/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_02.c cppfunc 42
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11147 153244/color.c cppfunc 595
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof (struct stonesoup_struct));
stonesoup_data->buff_pointer = stonesoup_data->buffer;
strncpy(stonesoup_data->buffer, fugitating_hydrophilite, strlen(fugitating_hydrophilite) + 1);
stonesoup_ptr_deref = strlen( stonesoup_data->buff_pointer);
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
1
---------------------------------
11148 70464/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_17.c cppfunc 134
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
11149 70904/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_41.c cppfunc 36
data = (char *)malloc(10*sizeof(char));
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_41_badSink(data);
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_41_badSink(char * data)
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11150 153039/bufmgr.c inputfunc 165
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&unmythical_tyrannisingly,"UNLEARNABLENESS_AMERINDIAN");
if (unmythical_tyrannisingly != 0) {;
unsimulating_pharyngoxerosis = ((int )(strlen(unmythical_tyrannisingly)));
insectary_rightly = ((char *)(malloc(unsimulating_pharyngoxerosis + 1)));
if (insectary_rightly == 0) {
memcpy(insectary_rightly,unmythical_tyrannisingly,unsimulating_pharyngoxerosis);
if (unmythical_tyrannisingly != 0)
free(((char *)unmythical_tyrannisingly));
photophonic_retool[5] = insectary_rightly;
interstellar_elfins =  *(photophonic_retool +  *driers_neuromyelitis);
if (interstellar_elfins != 0) {
labourism_mispaint = ((char *)interstellar_elfins);
if (strlen(labourism_mispaint) < 1) {
stonesoup_set_function(labourism_mispaint, &stonesoup_my_foo);
if (interstellar_elfins != 0)
free(((char *)interstellar_elfins));
void stonesoup_set_function(char *set_param_str,struct stonesoup_data_struct *set_param_data_struct)
if (strlen(set_param_str) > 10U) {
set_param_data_struct -> str_member = set_param_str;
stonesoup_set_function(labourism_mispaint, &stonesoup_my_foo);
stonesoup_val = (stonesoup_my_foo . func_member(stonesoup_my_foo . str_member));
if (stonesoup_val == 0)
1
---------------------------------
11151 73014/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_33.cpp cppfunc 41
char * &dataRef = data;
char * data = dataRef;
strcat(dest, data);
printLine(data);
free(data);
1
---------------------------------
11152 72796/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_81_goodG2B.cpp cppfunc 37
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_81_goodG2B::action(wchar_t * data) const
SNPRINTF(dest, wcslen(data), L"%s", data);
printWLine(data);
free(data);
1
---------------------------------
11153 153241/color.c cppfunc 120
stonesoup_printf("%s\n", stonesoup_buff);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11154 71874/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_62.cpp cppfunc 46
void badSource(twoIntsStruct * &data);
data = NULL;
badSource(data);
badSource(data);
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
1
---------------------------------
11155 153414/dirent_uri.c cppfunc 2112
return c - 32;
return c;
struct promiscuousness_rillette nonembryonal_sympathizing = {0};
va_list repulverize_outyielding;
__builtin_va_start(repulverize_outyielding,intarsa_plagiarizers);
nonembryonal_sympathizing = (va_arg(repulverize_outyielding,struct promiscuousness_rillette ));
midrashim_vinegar = ((char *)nonembryonal_sympathizing . ficklety_sabellian);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before = stonesoup_toupper;
memset(stonesoup_data->buffer,0,64);
stonesoup_data->after = stonesoup_toupper;
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->before", stonesoup_data->before, &stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->after", stonesoup_data->after, &stonesoup_data->after, "INITIAL-STATE");
strcpy(stonesoup_data->buffer, midrashim_vinegar);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_data->buffer);
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->after(stonesoup_data->buffer[stonesoup_i]));
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "FINAL-STATE");
free(stonesoup_data);
1
---------------------------------
11156 73052/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_13.c cppfunc 38
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
11157 73066/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_43.cpp cppfunc 43
data[100-1] = '\0';
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
11158 110475/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_22.c cppfunc 44
data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_22_badSource(data);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11159 70405/CWE122_Heap_Based_Buffer_Overflow__CWE135_06.c cppfunc 51
data = NULL;
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
11160 70850/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_21.c cppfunc 53
data = (char *)malloc(10*sizeof(char));
return data;
data = NULL;
data = badSource(data);
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
static char * badSource(char * data)
return data;
data = badSource(data);
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11161 73017/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_42.c cppfunc 41
data[100-1] = '\0';
return data;
data = badSource(data);
strcat(dest, data);
printLine(data);
free(data);
1
---------------------------------
11162 153017/cryptlib.c cppfunc 203
stonesoup_printf("%c",stonesoup_stack_buff_64[stonesoup_ss_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11163 152970/color.c cppfunc 625
return c - 32;
stonesoup_buffer[stonesoup_buffer_len - 1] = '\0';
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
int stonesoup_toupper(int c)
return c;
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_buffer);
1
---------------------------------
11164 71458/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_03.c cppfunc 46
data = NULL;
data[0] = '\0';
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
11165 71722/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_43.cpp cppfunc 40
data = (int *)malloc(50*sizeof(int));
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
1
---------------------------------
11166 67444/CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_81a.cpp cppfunc 31
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11167 153601/color.c cppfunc 590
*stonesoup_tainted_buff = NULL;
*stonesoup_tainted_buff = NULL;
int reiced_sealant = 44;
char *reprotest_tigerfishes;
stonesoup_read_taint(&reprotest_tigerfishes,"7362",reiced_sealant);
protuberances_dragonwort = ((char *)reprotest_tigerfishes);
stonesoup_buffer = malloc((strlen(protuberances_dragonwort) + 1) * sizeof(char ));
strcpy(stonesoup_buffer,protuberances_dragonwort);
stonesoup_printf("Index of first char: %i\n",stonesoup_process_buffer(stonesoup_buffer));
free(stonesoup_buffer);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {
if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {
*stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));
stonesoup_read_taint(&reprotest_tigerfishes,"7362",reiced_sealant);
protuberances_dragonwort = ((char *)reprotest_tigerfishes);
stonesoup_buffer = malloc((strlen(protuberances_dragonwort) + 1) * sizeof(char ));
strcpy(stonesoup_buffer,protuberances_dragonwort);
free(stonesoup_buffer);
char stonesoup_process_buffer(char *buffer_param)
free(buffer_param);
free(stonesoup_buffer);
1
---------------------------------
11168 148881/ascend-scanner.c cppfunc 1527
(yy_last_accepting_cpos) = yy_cp;
yy_cp = (yy_last_accepting_cpos);
YY_DO_BEFORE_ACTION;
*yy_cp = (yy_hold_char);
int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
yy_next_state = yy_try_NUL_trans( yy_current_state );
if ( ascendwrap( ) )
(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
yy_cp = (yy_c_buf_p);
YY_DO_BEFORE_ACTION;
*yy_cp = (yy_hold_char);
yy_bp = yy_cp;
YY_DO_BEFORE_ACTION;
ascendlval.d = strtol(ascendtext, NULL, 10);
1
---------------------------------
11169 67496/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_13.c cppfunc 47
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_13_bad();
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
good2();
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_13_good();
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_13_bad();
structCharVoid->voidSecond = (void *)SRC_STR;
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0';
free(structCharVoid);
1
---------------------------------
11170 199233/buffer_overrun_dynamic.c cppfunc 463
char *buf=(char*) calloc(5,sizeof(char));
buf[i]='1';
free(buf);
1
---------------------------------
11171 153799/conf_mod.c cppfunc 154
stonesoup_printf("%s\n",stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11172 149083/scpy9-bad.c inputfunc 56
main(int argc, char **argv)
if(argc > 1) {
userstr = argv[1];
str2 = shortstr(userstr, strlen(userstr), 80);
shortstr(char *p, int n, int targ)
if(n > targ)
return shortstr(p+1, n-1, targ);
shortstr(char *p, int n, int targ)
return p;
return shortstr(p+1, n-1, targ);
str2 = shortstr(userstr, strlen(userstr), 80);
test(str2);
test(char *str)
strcpy(buf, str);
printf("result: %s\n", buf);
free(buf);
1
---------------------------------
11173 149083/scpy9-bad.c cppfunc 52
shortstr(char *p, int n, int targ)
return shortstr(p+1, n-1, targ);
return p;
return shortstr(p+1, n-1, targ);
buf = malloc(MAXSIZE);
strcpy(buf, str);
printf("result: %s\n", buf);
free(buf);
str2 = shortstr(userstr, strlen(userstr), 80);
test(str2);
test(char *str)
strcpy(buf, str);
printf("result: %s\n", buf);
free(buf);
main(int argc, char **argv)
userstr = argv[1];
str2 = shortstr(userstr, strlen(userstr), 80);
1
---------------------------------
11174 79487/CWE134_Uncontrolled_Format_String__char_console_snprintf_06.c inputfunc 51
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
SNPRINTF(dest, 100-1, data);
1
---------------------------------
11175 72824/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_41.c cppfunc 32
data[0] = '\0';
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_41_badSink(data);
void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_41_badSink(char * data)
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
11176 70501/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_06.c cppfunc 75
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
11177 153537/heapam.c inputfunc 162
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&stocktaking_schoolbook,"PARA_STORYMONGER");
if (stocktaking_schoolbook != 0) {;
organical_infantive . unquietly_sade = ((char *)stocktaking_schoolbook);
mesole_dingiest[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *slidage_numerologists)))))))))))))))))))))))))))))))))))))))))))))))))] = organical_infantive;
semitechnical_cedrol = mesole_dingiest[ *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *( *slidage_numerologists)))))))))))))))))))))))))))))))))))))))))))))))))];
stoffel_irregeneracy = ((char *)semitechnical_cedrol . unquietly_sade);
strncpy(stonesoup_buffer, stoffel_irregeneracy, stonesoup_buffer_len);
*stonesoup_buffer_ptr = stoffel_irregeneracy;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
tracepoint(stonesoup_trace, variable_address, "*stonesoup_buffer_ptr", *stonesoup_buffer_ptr, "TRIGGER-STATE");
strncpy(stonesoup_buffer, stoffel_irregeneracy, stonesoup_buffer_len);
stonesoup_tainted_len = strlen( *stonesoup_buffer_ptr);
if (stonesoup_buffer_ptr != 0) {
free(stonesoup_buffer_ptr);
if (semitechnical_cedrol . unquietly_sade != 0)
free(((char *)semitechnical_cedrol . unquietly_sade));
1
---------------------------------
11178 149075/mem3-bad.c cppfunc 53
main(int argc, char **argv)
userstr = argv[1];
p = test(userstr);
test(char *str)
p = strdup(str);
printf("result: %s\n", p);
free(p);
return p;
p = test(userstr);
free(p);
1
---------------------------------
11179 69850/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_43.cpp cppfunc 40
data = (int *)malloc(10);
memcpy(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
1
---------------------------------
11180 70404/CWE122_Heap_Based_Buffer_Overflow__CWE135_05.c cppfunc 52
data = NULL;
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
memcpy(dest, data, (dataLen+1));
free(dest);
1
---------------------------------
11181 153736/types.c cppfunc 75
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11182 152967/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&undisbursed_puris,"FRITTERING_HYBRIDISED");
if (undisbursed_puris != 0) {;
campanularian_babroot = ((char *)undisbursed_puris);
strcpy(stonesoup_heap_buffer_64, campanularian_babroot);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_heap_buffer_64);
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_opt_var", stonesoup_opt_var, &stonesoup_opt_var, "CROSSOVER-STATE");
for (; stonesoup_i < stonesoup_opt_var; ++stonesoup_i) {
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_opt_var", stonesoup_opt_var, &stonesoup_opt_var, "FINAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "BEFORE-FREE");
stonesoup_printf("%s\n",stonesoup_heap_buffer_64);
if (undisbursed_puris != 0)
free(((char *)undisbursed_puris));
void stonesoup_printf(char * format, ...) {
free(stonesoup_heap_buffer_64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "FINAL-STATE");
1
---------------------------------
11183 153023/avpacket.c cppfunc 527
return c - 32;
stonesoup_data = (char*) malloc(8 * sizeof(char));
strncpy(stonesoup_data, jumprock_backet, strlen(jumprock_backet) + 1);
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i) {
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data[stonesoup_oc_i]);
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i) {
stonesoup_printf("%s\n", stonesoup_data);
1
---------------------------------
11184 153242/e_camellia.c cppfunc 638
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof (struct stonesoup_struct));
stonesoup_data->buff_pointer = stonesoup_data->buffer;
strncpy(stonesoup_data->buffer, ship_crayfishes, strlen(ship_crayfishes) + 1);
stonesoup_ptr_deref = strlen( stonesoup_data->buff_pointer);
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
1
---------------------------------
11185 71766/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_33.cpp cppfunc 38
int * &dataRef = data;
int * data = dataRef;
memmove(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
1
---------------------------------
11186 67741/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_51.cpp cppfunc 84
struct sockaddr_in service;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
1
---------------------------------
11187 72865/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_18.c cppfunc 39
data[0] = '\0';
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
11188 71194/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_43.cpp cppfunc 48
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
11189 199253/double_free.c cppfunc 87
char* ptr= (char*) malloc(10*sizeof(char));
for(i=0;i<10;i++)
*(ptr+i)='a';
free(ptr);
free(ptr);
1
---------------------------------
11190 199253/double_free.c cppfunc 83
char* ptr= (char*) malloc(10*sizeof(char));
for(i=0;i<10;i++)
*(ptr+i)='a';
free(ptr);
1
---------------------------------
11191 79574/CWE134_Uncontrolled_Format_String__char_console_vfprintf_81_bad.cpp cppfunc 33
va_list args;
va_start(args, data);
vfprintf(stdout, data, args);
va_end(args);
1
---------------------------------
11192 153387/subtrans.c cppfunc 793
void cystectomies_aethogen(char **packton_troublers)
alexina_savagenesses(packton_troublers);
void alexina_savagenesses(char **fermis_achorn)
dysgnosia_oftest = ((char *)fermis_achorn[3]);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before[63] = '\0';
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after[63] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->before", stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->after", stonesoup_data->after, "INITIAL-STATE");
stonesoup_buff_size = ((int )(strlen(dysgnosia_oftest)));
memcpy(stonesoup_data->buffer, dysgnosia_oftest, 64);
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_printf(char * format, ...) {
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
1
---------------------------------
11193 72323/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_04.c cppfunc 46
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11194 153688/column.c cppfunc 84
stonesoup_printf("%s\n", stonesoup_buff);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11195 79371/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_61.c cppfunc 59
va_list args;
va_start(args, data);
vsnprintf(dest, 100-1, data, args);
va_end(args);
1
---------------------------------
11196 153102/cryptlib.c cppfunc 624
rewind(stonesoup_tainted_file);
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
*stonesoup_tainted_buff = NULL;
char *inductile_kaya;
stonesoup_read_taint(&inductile_kaya,"ENTHRONIZING_CONVERTER");
supercordially_punner = inductile_kaya;
fieldworker_jerkish = ((char *)supercordially_punner);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before[63] = '\0';
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after[63] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->before", stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->after", stonesoup_data->after, "INITIAL-STATE");
stonesoup_buff_size = ((int )(strlen(fieldworker_jerkish)));
memcpy(stonesoup_data->buffer, fieldworker_jerkish, 64);
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_printf(char * format, ...) {
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {
stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);
stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,"rb");
fseek(stonesoup_tainted_file,0L,2);
stonesoup_lsize = ftell(stonesoup_tainted_file);
*stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));
stonesoup_read_taint(&inductile_kaya,"ENTHRONIZING_CONVERTER");
supercordially_punner = inductile_kaya;
fieldworker_jerkish = ((char *)supercordially_punner);
stonesoup_buff_size = ((int )(strlen(fieldworker_jerkish)));
memcpy(stonesoup_data->buffer, fieldworker_jerkish, 64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
1
---------------------------------
11197 79531/CWE134_Uncontrolled_Format_String__char_console_vfprintf_02.c inputfunc 52
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
badVaSinkB(data, data);
static void badVaSinkB(char * data, ...)
va_start(args, data);
vfprintf(stdout, data, args);
1
---------------------------------
11198 70990/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_15.c cppfunc 48
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11199 110403/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_74.cpp cppfunc 44
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
1
---------------------------------
11200 71169/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_02.c cppfunc 43
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
11201 70941/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_14.c cppfunc 43
data = NULL;
data = (char *)malloc(10*sizeof(char));
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
1
---------------------------------
11202 153390/hashfn.c cppfunc 42
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11203 70884/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_05.c cppfunc 50
data = NULL;
data = (char *)malloc(10*sizeof(char));
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11204 72316/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_81_goodG2B.cpp cppfunc 32
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_81_goodG2B::action(char * data) const
memcpy(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11205 148881/ascend-scanner.c cppfunc 1483
(yy_last_accepting_cpos) = yy_cp;
yy_cp = (yy_last_accepting_cpos);
YY_DO_BEFORE_ACTION;
*yy_cp = (yy_hold_char);
int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
yy_next_state = yy_try_NUL_trans( yy_current_state );
if ( ascendwrap( ) )
(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
yy_cp = (yy_c_buf_p);
YY_DO_BEFORE_ACTION;
*yy_cp = (yy_hold_char);
yy_bp = yy_cp;
YY_DO_BEFORE_ACTION;
ascendlval.d = strtol(ascendtext, NULL, 10);
1
---------------------------------
11206 71379/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_22.c cppfunc 41
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_22_badSource(data);
strncat(data, source, 100);
printLine(data);
free(data);
1
---------------------------------
11207 152887/color.c cppfunc 118
stonesoup_printf("%02x",stonesoup_other_buff[stonesoup_other_size - stonesoup_i - 1]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11208 152906/tile.c cppfunc 338
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc (sizeof(struct stonesoup_struct));
memset(stonesoup_data->base_path, 0, 20);
stonesoup_data->buff_pointer = stonesoup_data->base_path;
realpath(merciable_ondoscope, stonesoup_data->base_path);
stonesoup_opt_var = strlen( stonesoup_data->buff_pointer);
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
free (stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_toupper(stonesoup_data->base_path[stonesoup_oc_i]);
stonesoup_data->base_path[stonesoup_oc_i] =
stonesoup_printf("%s\n", stonesoup_data->base_path);
void stonesoup_printf(char * format, ...) {
free (stonesoup_data);
1
---------------------------------
11209 110394/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_62.cpp cppfunc 44
data = -1;
badSource(data);
void badSource(int &data);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11210 71188/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_31.c cppfunc 43
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
11211 153270/dynahash.c cppfunc 267
stonesoup_printf("Error: Failed to allocate memory\n");
stonesoup_printf("%c",stonesoup_data.before(stonesoup_data.buffer[stonesoup_i]));
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11212 153246/emem.c cppfunc 166
stonesoup_printf("%s\n", stonesoup_data->base_path);
stonesoup_printf("%s\n", stonesoup_data->buff_pointer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11213 153617/emem.c cppfunc 1182
rewind(stonesoup_tainted_file);
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
*stonesoup_tainted_buff = NULL;
union undercommander_overfee tupler_omnivident;
char *cellular_studite;;
stonesoup_read_taint(&cellular_studite,"SPECTERLIKE_SEMICARBAZONE");
tupler_omnivident . unwaving_pycnogonidium = cellular_studite;
pococurantism_aceldamas = polyesters_immaturely(tupler_omnivident);
stonesoup_other_size = 64;
stonesoup_other_buff = (char*) malloc (stonesoup_other_size * sizeof (char));
stonesoup_printf("%02x",stonesoup_other_buff[stonesoup_other_size - stonesoup_i - 1]);
free (stonesoup_other_buff);
union undercommander_overfee polyesters_immaturely(union undercommander_overfee talmudize_unintentionally)
return talmudize_unintentionally;
pococurantism_aceldamas = polyesters_immaturely(tupler_omnivident);
bastard_studbook = ((char *)pococurantism_aceldamas . unwaving_pycnogonidium);
stonesoup_buff_size = strlen(bastard_studbook) + 1;
bastard_studbook[stonesoup_buff_size - stonesoup_i - 1];
stonesoup_other_buff[stonesoup_other_size - stonesoup_i - 1] =
free (stonesoup_other_buff);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {
stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);
stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,"rb");
fseek(stonesoup_tainted_file,0L,2);
stonesoup_lsize = ftell(stonesoup_tainted_file);
*stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));
stonesoup_read_taint(&cellular_studite,"SPECTERLIKE_SEMICARBAZONE");
tupler_omnivident . unwaving_pycnogonidium = cellular_studite;
pococurantism_aceldamas = polyesters_immaturely(tupler_omnivident);
void stonesoup_printf(char * format, ...) {
free (stonesoup_other_buff);
1
---------------------------------
11214 152924/column.c cppfunc 1294
rewind(stonesoup_tainted_file);
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
*stonesoup_tainted_buff = NULL;
char *pugmiller_chaetangiaceae;
stonesoup_read_taint(&pugmiller_chaetangiaceae,"SAYE_TRACHEARIA");
evitable_cantiga . zapu_wiremen = pugmiller_chaetangiaceae;
lacerta_uncharactered(evitable_cantiga);
stonesoup_other_size = 64;
stonesoup_other_buff = (char*) malloc (stonesoup_other_size * sizeof (char));
stonesoup_printf("%02x",stonesoup_other_buff[stonesoup_other_size - stonesoup_i - 1]);
free (stonesoup_other_buff);
void stonesoup_printf(char * format, ...) {
free (stonesoup_other_buff);
void lacerta_uncharactered(const union unsacrament_acetabuliferous alewife_actionizing)
tweedles_launceiot = ((char *)((union unsacrament_acetabuliferous )alewife_actionizing) . zapu_wiremen);
stonesoup_buff_size = strlen(tweedles_launceiot) + 1;
tweedles_launceiot[stonesoup_buff_size - stonesoup_i - 1];
stonesoup_other_buff[stonesoup_other_size - stonesoup_i - 1] =
free (stonesoup_other_buff);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {
stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);
stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,"rb");
fseek(stonesoup_tainted_file,0L,2);
stonesoup_lsize = ftell(stonesoup_tainted_file);
*stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));
stonesoup_read_taint(&pugmiller_chaetangiaceae,"SAYE_TRACHEARIA");
evitable_cantiga . zapu_wiremen = pugmiller_chaetangiaceae;
lacerta_uncharactered(evitable_cantiga);
1
---------------------------------
11215 153580/pmsignal.c cppfunc 118
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11216 153714/bio_err.c cppfunc 124
stonesoup_printf("%s\n", stonesoup_data);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11217 70956/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45.c cppfunc 40
data = (char *)malloc(10*sizeof(char));
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45_badData = data;
badSink();
char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45_badData;
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
1
---------------------------------
11218 72812/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_13.c cppfunc 40
data = NULL;
data[0] = '\0';
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
11219 70663/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_34.c cppfunc 151
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
11220 72732/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_45.c cppfunc 35
data[100-1] = L'\0';
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_45_badData = data;
badSink();
wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_45_badData;
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
11221 148966/netmon.c cppfunc 289
struct netmon_hdr hdr;
struct tm tm;
bytes_read = file_read(&hdr, sizeof hdr, wth->fh);
if (bytes_read != sizeof hdr) {
tm.tm_year = pletohs(&hdr.ts_year) - 1900;
tm.tm_mon = pletohs(&hdr.ts_month) - 1;
tm.tm_mday = pletohs(&hdr.ts_day);
tm.tm_hour = pletohs(&hdr.ts_hour);
tm.tm_min = pletohs(&hdr.ts_min);
tm.tm_sec = pletohs(&hdr.ts_sec);
tm.tm_isdst = -1;
netmon->start_secs = mktime(&tm);
1
---------------------------------
11222 67333/CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_51.c cppfunc 32
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11223 72083/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_04.c cppfunc 47
data = NULL;
data[0] = L'\0';
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
11224 72337/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_18.c cppfunc 38
data[100-1] = '\0';
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11225 72331/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_12.c cppfunc 45
data[100-1] = '\0';
data[50-1] = '\0';
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11226 153600/tile.c cppfunc 402
return c - 32;
sweven_nitwitted = ((char *)vidkids_tummuler . neurophil_subchapters);
stonesoup_heap_buffer_64 = (char*) malloc(64 * sizeof(char));
memset(stonesoup_heap_buffer_64,0,64);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "INITIAL-STATE");
strcpy(stonesoup_heap_buffer_64, sweven_nitwitted);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "CROSSOVER-STATE");
stonesoup_opt_var = strlen( stonesoup_heap_buffer_64);
stonesoup_heap_buffer_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buffer_64[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "BEFORE-FREE");
stonesoup_printf("%s\n",stonesoup_heap_buffer_64);
void stonesoup_printf(char * format, ...) {
free(stonesoup_heap_buffer_64);
int stonesoup_toupper(int c)
return c;
stonesoup_heap_buffer_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buffer_64[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buffer_64", stonesoup_heap_buffer_64, "BEFORE-FREE");
stonesoup_printf("%s\n",stonesoup_heap_buffer_64);
1
---------------------------------
11227 70996/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_31.c cppfunc 42
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11228 153193/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&zambezian_precis,"HIRELINGS_PIBLOCKTO");
if (zambezian_precis != 0) {;
watercolourist_seibert = ((char *)zambezian_precis);
stonesoup_buff_size = ((int )(strlen(watercolourist_seibert)));
strncpy(stonesoup_heap_buff_64, watercolourist_seibert, 64);
for (; stonesoup_ss_i < stonesoup_buff_size; ++stonesoup_ss_i){
if (zambezian_precis != 0)
free(((char *)zambezian_precis));
1
---------------------------------
11229 79450/CWE134_Uncontrolled_Format_String__char_console_printf_17.c inputfunc 41
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
size_t dataLen = strlen(data);
if (100-dataLen > 1)
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
printf(data);
1
---------------------------------
11230 72808/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_09.c cppfunc 40
data = NULL;
data[0] = '\0';
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
11231 153247/conversation.c cppfunc 1278
return c - 32;
stonesoup_buffer[stonesoup_buffer_len - 1] = '\0';
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_buffer);
int stonesoup_toupper(int c)
return c;
stonesoup_buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_buffer);
1
---------------------------------
11232 79444/CWE134_Uncontrolled_Format_String__char_console_printf_11.c inputfunc 40
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
printf(data);
1
---------------------------------
11233 73060/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_31.c cppfunc 38
data[100-1] = '\0';
char * dataCopy = data;
char * data = dataCopy;
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
11234 73356/CWE122_Heap_Based_Buffer_Overflow__sizeof_struct_62.cpp cppfunc 35
void badSource(twoIntsStruct * &data);
badSource(data);
data = NULL;
badSource(data);
printStructLine(data);
free(data);
1
---------------------------------
11235 70642/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_03.c cppfunc 146
int * buffer = (int *)malloc(10 * sizeof(int));
buffer[i] = 0;
buffer[data] = 1;
printIntLine(buffer[i]);
free(buffer);
1
---------------------------------
11236 152989/aviobuf.c cppfunc 54
stonesoup_printf("Error: Failed to allocate memory\n");
stonesoup_printf("%s\n", stonesoup_data.buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11237 153533/dirent_uri.c cppfunc 177
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof (struct stonesoup_struct));
stonesoup_data->buff_pointer = stonesoup_data->buffer;
strncpy(stonesoup_data->buffer, repegged_woodfish, strlen(repegged_woodfish) + 1);
stonesoup_ptr_deref = strlen( stonesoup_data->buff_pointer);
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
1
---------------------------------
11238 148966/strutil.c cppfunc 649
oid_str_to_bytes(const char *oid_str, GByteArray *bytes) {
p = oid_str;
if (!isdigit((guchar)*p) && (*p != '.')) return FALSE;
p++;
p = oid_str;
while (isdigit((guchar)*p)) {
p++;
while (isdigit((guchar)*p)) {
if (*p) p++;
while (isdigit((guchar)*p)) {
1
---------------------------------
11239 66309/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_51.c cppfunc 32
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1);
1
---------------------------------
11240 79462/CWE134_Uncontrolled_Format_String__char_console_printf_45.c inputfunc 49
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
CWE134_Uncontrolled_Format_String__char_console_printf_45_badData = data;
badSink();
char * data = CWE134_Uncontrolled_Format_String__char_console_printf_45_badData;
printf(data);
1
---------------------------------
11241 152913/eng_lib.c cppfunc 467
char* stonesoup_tainted_buff;
int buffer_size = 1000;
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
buffer_size = buffer_size * 2;
stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));
data_size = mg_get_var(conn, "data", stonesoup_tainted_buff, buffer_size * sizeof(char));
free(stonesoup_tainted_buff);
stonesoup_handle_taint(stonesoup_tainted_buff);
return c - 32;
duumviral_unflouted = ((int )(strlen(charmeuse_winter)));
coproducing_diseasy = ((char *)(malloc(duumviral_unflouted + 1)));
memset(coproducing_diseasy,0,duumviral_unflouted + 1);
memcpy(coproducing_diseasy,charmeuse_winter,duumviral_unflouted);
deflagrates_nondefalcation = 1;
lacteals_nucleoside = &coproducing_diseasy;
metricising_stiacciato = ((char **)(((unsigned long )lacteals_nucleoside) * deflagrates_nondefalcation * deflagrates_nondefalcation)) + 5;
ichthyosaurus_helves = ((char *)( *(metricising_stiacciato - 5)));
stonesoup_heap_buff_64[64 - 1] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "INITIAL-STATE");
stonesoup_taint_len = ((int )(strlen(ichthyosaurus_helves)));
stonesoup_heap_buff_64[stonesoup_buff_size] = ichthyosaurus_helves[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
void stonesoup_printf(char * format, ...) {
stonesoup_printf("%s\n",&(stonesoup_heap_buff_64[stonesoup_buff_size+1]));
free(stonesoup_heap_buff_64);
void stonesoup_handle_taint(char *charmeuse_winter)
duumviral_unflouted = ((int )(strlen(charmeuse_winter)));
memcpy(coproducing_diseasy,charmeuse_winter,duumviral_unflouted);
lacteals_nucleoside = &coproducing_diseasy;
metricising_stiacciato = ((char **)(((unsigned long )lacteals_nucleoside) * deflagrates_nondefalcation * deflagrates_nondefalcation)) + 5;
ichthyosaurus_helves = ((char *)( *(metricising_stiacciato - 5)));
stonesoup_taint_len = ((int )(strlen(ichthyosaurus_helves)));
stonesoup_heap_buff_64[stonesoup_buff_size] = ichthyosaurus_helves[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_heap_buff_64", stonesoup_heap_buff_64, "CROSSOVER-STATE");
free(stonesoup_heap_buff_64);
int stonesoup_toupper(int c)
return c;
stonesoup_heap_buff_64[stonesoup_i] = stonesoup_toupper(stonesoup_heap_buff_64[stonesoup_i]);
free(stonesoup_heap_buff_64);
1
---------------------------------
11242 72091/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_12.c cppfunc 46
data[0] = L'\0';
data[0] = L'\0';
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
11243 110315/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_04.c cppfunc 125
data = -1;
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11244 71373/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_14.c cppfunc 40
data = NULL;
data[0] = '\0';
strncat(data, source, 100);
printLine(data);
free(data);
1
---------------------------------
11245 72721/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_18.c cppfunc 38
data[100-1] = L'\0';
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
11246 153724/ffmpeg.c cppfunc 180
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11247 153729/color.c cppfunc 120
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11248 152886/main_statusbar.c cppfunc 648
seatmates_shackled = ((char *)( *(coparent_visalia - 5)) . coelenterata_archenemies);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before[63] = '\0';
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after[63] = '\0';
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->before", stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->after", stonesoup_data->after, "INITIAL-STATE");
stonesoup_buff_size = ((int )(strlen(seatmates_shackled)));
memcpy(stonesoup_data->buffer, seatmates_shackled, 64);
stonesoup_printf("%x",stonesoup_data->buffer[stonesoup_i]);
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
void stonesoup_printf(char * format, ...) {
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
1
---------------------------------
11249 153510/tile.c cppfunc 428
return c - 32;
tendencies_sheder = ((char *)( *( *( *( *( *( *( *( *( *( *winnowers_aceta)))))))))) . pseudomaniac_lilibelle);
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof(struct stonesoup_struct));
stonesoup_data->before = stonesoup_toupper;
stonesoup_data->buffer[63] = '\0';
stonesoup_data->after = stonesoup_toupper;
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->before", stonesoup_data->before, &stonesoup_data->before, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "INITIAL-STATE");
tracepoint(stonesoup_trace, variable_signed_integral, "stonesoup_data->after", stonesoup_data->after, &stonesoup_data->after, "INITIAL-STATE");
stonesoup_taint_len = ((int )(strlen(tendencies_sheder)));
stonesoup_data->buffer[stonesoup_buff_size] = tendencies_sheder[stonesoup_taint_len];
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
stonesoup_printf("%c",stonesoup_data->before(stonesoup_data->buffer[stonesoup_i]));
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_i]);
free(stonesoup_data);
1
---------------------------------
11250 72959/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_16.c cppfunc 41
data = NULL;
data[0] = L'\0';
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11251 72339/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_22.c cppfunc 40
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_22_badSource(data);
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11252 79439/CWE134_Uncontrolled_Format_String__char_console_printf_06.c inputfunc 45
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
printf(data);
1
---------------------------------
11253 79558/CWE134_Uncontrolled_Format_String__char_console_vfprintf_45.c cppfunc 38
va_list args;
va_start(args, data);
vfprintf(stdout, data, args);
va_end(args);
1
---------------------------------
11254 72345/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_42.c cppfunc 42
data[100-1] = '\0';
return data;
data = badSource(data);
memmove(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11255 153583/stream.c cppfunc 267
return c - 32;
stonesoup_data = (struct stonesoup_struct*) malloc(sizeof (struct stonesoup_struct));
stonesoup_data->buff_pointer = stonesoup_data->buffer;
strncpy(stonesoup_data->buffer, ambon_enthusiasm, strlen(ambon_enthusiasm) + 1);
stonesoup_ptr_deref = strlen( stonesoup_data->buff_pointer);
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
free(stonesoup_data);
int stonesoup_toupper(int c)
return c;
stonesoup_data->buffer[stonesoup_oc_i] = stonesoup_toupper(stonesoup_data->buffer[stonesoup_oc_i]);
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
free(stonesoup_data);
1
---------------------------------
11256 72087/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_08.c cppfunc 54
data = NULL;
data[0] = L'\0';
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
11257 199235/buffer_underrun_dynamic.c cppfunc 582
ptr1[11]='\0';
ptr1[i]='a';
memcpy(ptr2,ptr1,12);
free(ptr1);
1
---------------------------------
11258 153102/cryptlib.c inputfunc 218
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&inductile_kaya,"ENTHRONIZING_CONVERTER");
if (inductile_kaya != 0) {;
supercordially_punner = inductile_kaya;
fieldworker_jerkish = ((char *)supercordially_punner);
stonesoup_buff_size = ((int )(strlen(fieldworker_jerkish)));
memcpy(stonesoup_data->buffer, fieldworker_jerkish, 64);
for (; stonesoup_i < stonesoup_buff_size; ++stonesoup_i){
tracepoint(stonesoup_trace, variable_buffer, "stonesoup_data->buffer", stonesoup_data->buffer, "CROSSOVER-STATE");
free( stonesoup_data);
if (supercordially_punner != 0)
free(((char *)supercordially_punner));
1
---------------------------------
11259 62954/CWE121_Stack_Based_Buffer_Overflow__CWE135_07.c cppfunc 46
data = NULL;
data = (void *)WIDE_STRING;
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
1
---------------------------------
11260 70988/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_13.c cppfunc 42
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11261 72296/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_41.c cppfunc 31
data[100-1] = '\0';
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_41_badSink(data);
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_41_badSink(char * data)
memcpy(dest, data, strlen(data)*sizeof(char));
printLine(data);
free(data);
1
---------------------------------
11262 73053/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_14.c cppfunc 38
data = (char *)malloc(100*sizeof(char));
data[100-1] = '\0';
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
11263 153167/color.c cppfunc 120
s
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11264 1628/scpy7-bad.c cppfunc 43
main(int argc, char **argv)
userstr = argv[1];
test(userstr);
test(char *str)
buf = malloc(MAXSIZE);
strcpy(buf, str);
printf("result: %s\n", buf);
free(buf);
1
---------------------------------
11265 72199/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_34.c cppfunc 53
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_34_unionType myUnion;
wchar_t * data = myUnion.unionSecond;
SNPRINTF(data, 100, L"%s", source);
printWLine(data);
free(data);
1
---------------------------------
11266 152891/color.c cppfunc 562
molybdic_huccatoon = getenv("BORESOMENESS_TEETY");
spunking_hidalgoism = ((char *)molybdic_huccatoon);
stonesoup_buffer = malloc((strlen(spunking_hidalgoism) + 1) * sizeof(char ));
strcpy(stonesoup_buffer,spunking_hidalgoism);
stonesoup_printf("Index of first char: %i\n",stonesoup_process_buffer(stonesoup_buffer));
free(stonesoup_buffer);
char stonesoup_process_buffer(char *buffer_param)
free(buffer_param);
free(stonesoup_buffer);
1
---------------------------------
11267 72820/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_31.c cppfunc 40
data[0] = '\0';
char * dataCopy = data;
char * data = dataCopy;
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
11268 72749/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_82_goodG2B.cpp cppfunc 32
void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_82_goodG2B::action(wchar_t * data)
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
11269 79546/CWE134_Uncontrolled_Format_String__char_console_vfprintf_17.c inputfunc 53
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
size_t dataLen = strlen(data);
if (100-dataLen > 1)
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
badVaSinkB(data, data);
static void badVaSinkB(char * data, ...)
badVaSinkB(data, data);
static void badVaSinkB(char * data, ...)
va_start(args, data);
vfprintf(stdout, data, args);
1
---------------------------------
11270 70763/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_44.c cppfunc 35
static void badSink(char * data)
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
11271 79555/CWE134_Uncontrolled_Format_String__char_console_vfprintf_42.c inputfunc 36
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
return data;
data = badSource(data);
badVaSink(data, data);
static void badVaSink(char * data, ...)
va_start(args, data);
vfprintf(stdout, data, args);
1
---------------------------------
11272 70541/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_82a.cpp cppfunc 39
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
1
---------------------------------
11273 110367/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_08.c cppfunc 69
data = -1;
char inputBuffer[CHAR_ARRAY_SIZE] = "";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
data = atoi(inputBuffer);
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11274 79454/CWE134_Uncontrolled_Format_String__char_console_printf_31.c inputfunc 38
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
char * dataCopy = data;
char * data = dataCopy;
printf(data);
1
---------------------------------
11275 72988/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_81_bad.cpp cppfunc 33
void CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_81_bad::action(wchar_t * data) const
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11276 153192/tile-manager.c cppfunc 88
stonesoup_printf("%c",stonesoup_stack_buff_64[stonesoup_ss_i]);
stonesoup_printf("\n");
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11277 148881/emem.c cppfunc 1230
node->left=new_node;
new_node->u.is_subtree=EMEM_TREE_NODE_IS_DATA;
node=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
node=node->left;
new_node->parent=node;
node=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->left=NULL;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->right=NULL;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->key32=key;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->data=data;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->u.is_subtree=EMEM_TREE_NODE_IS_DATA;
node->right=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
node=new_node;
new_node->parent=node;
node=new_node;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
next_tree=lookup_or_insert32(se_tree, *key[0].key, create_sub_tree, se_tree, EMEM_TREE_NODE_IS_SUBTREE);
key[0].length--;
key[0].key++;
emem_tree_insert32_array(next_tree, key, data);
emem_tree_key_t key[2];
aligned[div-1] = 0x00000001;
key[0].key = aligned;
key[1].length = 0;
key[1].key = NULL;
emem_tree_insert32_array(se_tree, key, v);
static void* lookup_or_insert32(emem_tree_t *se_tree, guint32 key, void*(*func)(void*),void* ud, int is_subtree) {
next_tree=lookup_or_insert32(se_tree, *key[0].key, create_sub_tree, se_tree, EMEM_TREE_NODE_IS_SUBTREE);
key++;
emem_tree_insert32_array(next_tree, key, data);
emem_tree_insert32_array(emem_tree_t *se_tree, emem_tree_key_t *key, void *data)
emem_tree_insert32(se_tree, *key[0].key, data);
key++;
emem_tree_insert32_array(next_tree, key, data);
emem_tree_insert32(emem_tree_t *se_tree, guint32 key, void *data)
new_node->key32=key;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
new_node->data=data;
new_node=se_tree->malloc(sizeof(emem_tree_node_t));
emem_tree_insert_string(emem_tree_t* se_tree, const gchar* k, void* v, guint32 flags)
guint32 len = (guint32) strlen(k);
guint32 div = (len+3)/4+1;
aligned = malloc(div * sizeof (guint32));
key[0].length = div;
emem_tree_insert32_array(se_tree, key, v);
1
---------------------------------
11278 72103/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_34.c cppfunc 47
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_34_unionType myUnion;
wchar_t * data = myUnion.unionSecond;
wcsncat(data, source, 100);
printWLine(data);
free(data);
1
---------------------------------
11279 153244/color.c cppfunc 118
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11280 72951/CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_08.c cppfunc 54
data = NULL;
data[0] = L'\0';
wcscpy(data, source);
printWLine(data);
free(data);
1
---------------------------------
11281 71470/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_15.c cppfunc 52
data = NULL;
data[0] = '\0';
SNPRINTF(data, 100, "%s", source);
printLine(data);
free(data);
1
---------------------------------
11282 73012/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_31.c cppfunc 38
data[100-1] = '\0';
char * dataCopy = data;
char * data = dataCopy;
strcat(dest, data);
printLine(data);
free(data);
1
---------------------------------
11283 71192/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_41.c cppfunc 36
data = (wchar_t *)malloc(10*sizeof(wchar_t));
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_41_badSink(data);
void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_41_badSink(wchar_t * data)
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
1
---------------------------------
11284 153225/color.c inputfunc 145
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&inspirationally_saluter,"ASYLUM_DEMOCRATIZING");
if (inspirationally_saluter != 0) {;
epitaxic_manfully = ((char *)inspirationally_saluter);
for (stonesoup_i = 0; stonesoup_i < strlen(epitaxic_manfully); ++stonesoup_i) {
stonesoup_data->buffer[(int) epitaxic_manfully[stonesoup_i]]);
tracepoint(stonesoup_trace, variable_signed_integral, "((int) STONESOUP_TAINT_SOURCE[stonesoup_i])", ((int) epitaxic_manfully[stonesoup_i]), &(epitaxic_manfully[stonesoup_i]), "TRIGGER-STATE");
if (inspirationally_saluter != 0)
free(((char *)inspirationally_saluter));
1
---------------------------------
11285 72818/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_21.c cppfunc 50
data = NULL;
data = badSource(data);
static char * badSource(char * data)
data[0] = '\0';
return data;
data = badSource(data);
strcat(data, source);
printLine(data);
free(data);
1
---------------------------------
11286 153250/color.c inputfunc 555
demotion_prebetray = getenv("FOSSILS_PRUNABLE");
if (demotion_prebetray != 0) {;
remonetized_monomaniac = ((char *)demotion_prebetray);
strncpy(stonesoup_buffer, remonetized_monomaniac, stonesoup_buffer_len);
*stonesoup_buffer_ptr = remonetized_monomaniac;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
tracepoint(stonesoup_trace, variable_address, "*stonesoup_buffer_ptr", *stonesoup_buffer_ptr, "TRIGGER-STATE");
strncpy(stonesoup_buffer, remonetized_monomaniac, stonesoup_buffer_len);
stonesoup_tainted_len = strlen( *stonesoup_buffer_ptr);
if (stonesoup_buffer_ptr != 0) {
free(stonesoup_buffer_ptr);
1
---------------------------------
11287 148966/tvbuff.c cppfunc 1324
tvb_get_ntohieee_float(tvbuff_t *tvb, const int offset)
return get_ieee_float(tvb_get_ntohl(tvb, offset));
tvb_get_ntohl(tvbuff_t *tvb, const gint offset)
ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));
fast_ensure_contiguous(tvbuff_t *tvb, const gint offset, const guint length)
DISSECTOR_ASSERT(tvb && tvb->initialized);
return ensure_contiguous(tvb, offset, length);
u_offset = offset;
return tvb->real_data + u_offset;
return NULL;
ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));
return pntohl(ptr);
IEEE_SP_MANTISSA_WIDTH;
exponent = ((exponent >> IEEE_SP_MANTISSA_WIDTH) - IEEE_SP_BIAS) -
return mantissa * pow(2, exponent);
return get_ieee_float(tvb_get_ntohl(tvb, offset));
ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));
return pletohl(ptr);
return get_ieee_float(tvb_get_letohl(tvb, offset));
get_ieee_float(const guint32 w)
exponent = w & IEEE_SP_EXPONENT_MASK;
exponent = ((exponent >> IEEE_SP_MANTISSA_WIDTH) - IEEE_SP_BIAS) -
return mantissa * pow(2, exponent);
tvb_get_letohieee_float(tvbuff_t *tvb, const int offset)
return get_ieee_float(tvb_get_letohl(tvb, offset));
tvb_get_letohl(tvbuff_t *tvb, const gint offset)
ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));
1
---------------------------------
11288 79406/CWE134_Uncontrolled_Format_String__char_console_fprintf_31.c inputfunc 38
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
data[dataLen-1] = '\0';
data[dataLen] = '\0';
char * dataCopy = data;
char * data = dataCopy;
fprintf(stdout, data);
1
---------------------------------
11289 70739/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_04.c cppfunc 49
data = NULL;
data = (char *)malloc(10*sizeof(char));
strcpy(data, source);
printLine(data);
free(data);
1
---------------------------------
11290 152866/gimpdisplay.c cppfunc 881
*stonesoup_tainted_buff = NULL;
*stonesoup_tainted_buff = NULL;
struct myelemia_schapping lobal_cysteine;
int hut_corea = 44;
char *overvehement_macrocosm;;
stonesoup_read_taint(&overvehement_macrocosm,"4212",hut_corea);
lobal_cysteine . snooled_lections = ((char *)overvehement_macrocosm);
transliterate_actuarian = zalucki_awatch(lobal_cysteine);
stonesoup_buffer_ptr = malloc(65528);
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "CROSSOVER-STATE");
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
tracepoint(stonesoup_trace, variable_address, "*stonesoup_buffer_ptr", *stonesoup_buffer_ptr, "TRIGGER-STATE");
stonesoup_tainted_len = strlen( *stonesoup_buffer_ptr);
free(stonesoup_buffer_ptr);
void stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {
if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {
*stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));
stonesoup_read_taint(&overvehement_macrocosm,"4212",hut_corea);
lobal_cysteine . snooled_lections = ((char *)overvehement_macrocosm);
transliterate_actuarian = zalucki_awatch(lobal_cysteine);
struct myelemia_schapping zalucki_awatch(struct myelemia_schapping sense_dendrocolaptine)
return sense_dendrocolaptine;
transliterate_actuarian = zalucki_awatch(lobal_cysteine);
descendability_heavener = ((char *)transliterate_actuarian . snooled_lections);
strncpy(stonesoup_buffer, descendability_heavener, stonesoup_buffer_len);
*stonesoup_buffer_ptr = descendability_heavener;
tracepoint(stonesoup_trace, variable_address, "stonesoup_buffer_ptr", stonesoup_buffer_ptr, "TRIGGER-STATE");
free(stonesoup_buffer_ptr);
1
---------------------------------
11291 72737/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_61.c cppfunc 37
data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_61b_badSource(data);
wcsncpy(dest, data, wcslen(data));
printWLine(data);
free(data);
1
---------------------------------
11292 73067/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_44.c cppfunc 30
static void badSink(char * data)
strcpy(dest, data);
printLine(data);
free(data);
1
---------------------------------
11293 199235/buffer_underrun_dynamic.c cppfunc 268
int *buf=(int*) calloc(5,sizeof(int));
int index = 3;
*(buf +((-2 * index) + 1)) = 1;
free(buf);
1
---------------------------------
11294 71154/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_62.cpp cppfunc 45
data = NULL;
badSource(data);
void badSource(wchar_t * &data);
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
1
---------------------------------
11295 153209/avdevice.c cppfunc 67
stonesoup_printf("Error: Failed to allocate memory\n");
stonesoup_printf("%s\n",stonesoup_base_path);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11296 148881/ascend-scanner.c cppfunc 1404
(yy_last_accepting_cpos) = yy_cp;
yy_cp = (yy_last_accepting_cpos);
YY_DO_BEFORE_ACTION;
int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
*yy_cp = (yy_hold_char);
(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
yy_next_state = yy_try_NUL_trans( yy_current_state );
if ( ascendwrap( ) )
(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
yy_cp = (yy_c_buf_p);
YY_DO_BEFORE_ACTION;
*yy_cp = (yy_hold_char);
yy_bp = yy_cp;
YY_DO_BEFORE_ACTION;
ascendlval.d = strtol(ascendtext, NULL, 10);
1
---------------------------------
11297 110477/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_32.c cppfunc 47
int *dataPtr2 = &data;
int data = *dataPtr2;
intPointer = (int*)malloc(data * sizeof(int));
intPointer[i] = 0;
printIntLine(intPointer[0]);
free(intPointer);
1
---------------------------------
11298 148881/emem.c cppfunc 717
va_list ap;
va_start(ap,fmt);
dst = se_strdup_vprintf(fmt, ap);
gchar* se_strdup_vprintf(const gchar* fmt, va_list ap) {
G_VA_COPY(ap2, ap);
len = g_printf_string_upper_bound(fmt, ap);
va_end(ap);
1
---------------------------------
11299 152944/color.c cppfunc 90
stonesoup_printf("%s\n", stonesoup_data->buffer);
void stonesoup_printf(char * format, ...) {
va_start(argptr, format);
1
---------------------------------
11300 153790/mem_dbg.c inputfunc 267
stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);
if (stonesoup_tainted_file != 0) {
fclose(stonesoup_tainted_file);
stonesoup_read_taint(&fascism_dilatative,"HYPING_BONDSERVANT");
if (fascism_dilatative != 0) {;
melber_limbering = &fascism_dilatative;
stelai_forras = melber_limbering + 5;
if ( *(stelai_forras - 5) != 0) {
acentric_hypotralia = ((char *)( *(stelai_forras - 5)));
stonesoup_buff_size = ((int )(strlen(acentric_hypotralia)));
strncpy(stonesoup_heap_buff_64, acentric_hypotralia, 64);
for (; stonesoup_ss_i < stonesoup_buff_size; ++stonesoup_ss_i){
if ( *(stelai_forras - 5) != 0)
free(((char *)( *(stelai_forras - 5))));
1
---------------------------------