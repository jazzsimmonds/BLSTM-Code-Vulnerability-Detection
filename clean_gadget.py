#imports
import re 


def get_function_names(file):
    names = []
    f = open(file,"r",encoding="utf8")
    for i in f:
        if not i:
            pass
        else:
            i = i.replace("\n",'')
            names.append(i)
    return names
    
func_keywords = frozenset(get_function_names('functions.txt'))

# keywords up to C11 and C++17; immutable set
keywords = frozenset({'__asm', '__builtin', '__cdecl', '__declspec', '__except', '__export', '__far16', '__far32',
                      '__fastcall', '__finally', '__import', '__inline', '__int16', '__int32', '__int64', '__int8',
                      '__leave', '__optlink', '__packed', '__pascal', '__stdcall', '__system', '__thread', '__try',
                      '__unaligned', '_asm', '_Builtin', '_Cdecl', '_declspec', '_except', '_Export', '_Far16',
                      '_Far32', '_Fastcall', '_finally', '_Import', '_inline', '_int16', '_int32', '_int64',
                      '_int8', '_leave', '_Optlink', '_Packed', '_Pascal', '_stdcall', '_System', '_try', 'alignas',
                      'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand', 'bitor', 'bool', 'break', 'case',
                      'catch', 'char', 'char16_t', 'char32_t', 'class', 'compl', 'const', 'const_cast', 'constexpr',
                      'continue', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
                      'explicit', 'export', 'extern', 'false', 'final', 'float', 'for', 'friend', 'goto', 'if',
                      'inline', 'int', 'long', 'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq', 'nullptr',
                      'operator', 'or', 'or_eq', 'override', 'private', 'protected', 'public', 'register',
                      'reinterpret_cast', 'return', 'short', 'signed', 'sizeof', 'static', 'static_assert',
                      'static_cast', 'struct', 'switch', 'template', 'this', 'thread_local', 'throw', 'true', 'try',
                      'typedef', 'typeid', 'typename', 'union', 'unsigned', 'using', 'virtual', 'void', 'volatile',
                      'wchar_t', 'while', 'xor', 'xor_eq', 'NULL'})

main_set = frozenset({'main'})
main_args = frozenset({'argc', 'argv'})



def remove_nonascii(line):
    #remove any non-ascii characters
    clean_line = '' #variable that will be returned by the function
    new_line = line
    count = 0
    if line.isascii() == True:
        clean_line = line
    else:
        for i in line:
            count+=1
            if i.isascii() == False:
                new_line = new_line.replace(i,'')
                if count == len(line):
                    clean_line = new_line
    return clean_line

    
def clean_gadget(gadget):
    clean_line = [] #will contain the cleaned gadget to be returned
    user_fun = {} #will store user defined functions
    user_var = {} #will store user defined variables  
    
    find_comments = re.compile('(\/\/|\*\/)\s*')
    find_fun = re.compile(r'\b([_A-Za-z]\w*)\b(?=\s*\()')
    find_var = re.compile(r'\b(?<!["\'])([_A-Za-z]\w*)(?<!["\'])\b(?!\s*\()')
    
    
    var_count = 1
    fun_count = 1
    temp_line = ''
    

    for line in gadget:
        #if line isnt a comment
        x = bool(find_comments.search(line))
        if x == False:
            temp_line = remove_nonascii(line)
            found_fun = find_fun.findall(temp_line)
            found_var = find_var.findall(temp_line)
            
            #map user defined functions
            for fun_name in found_fun:
                #check function isnt a known function
                if fun_name not in keywords and fun_name not in main_set and fun_name not in func_keywords:
                    #check function name hasnt already been stored
                    if fun_name not in user_fun:
                        user_fun[fun_name] = 'fun' + str(fun_count)
                        fun_count+=1
           
            #replace user defined function with generated name
            for key, value in user_fun.items():
                if key in temp_line:
                    temp_line = temp_line.replace(key,value)

            #map user defined variables
            for var_name in found_var:
                #check variable isnt a known variable
                if var_name not in keywords and var_name not in main_args:
                    #check variable name hasnt already been stored
                    if var_name not in user_var:
                        user_var[var_name] = 'var' + str(var_count)
                        var_count+=1
            
            #replace user defined variable with generated name
            for key, value in user_var.items():
                pattern = re.compile(fr'(?<!\w){key}(?!\w)')
                temp_line =pattern.sub(value, temp_line)

            clean_line.append(temp_line.replace("\n",''))        

    return clean_line